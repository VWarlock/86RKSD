
AVRASM ver. 2.1.30  E:\COM\Museum\Апогей_БК-01\86RKSD\Исходники и прошивка контроллера\List\86rksd.asm Thu Jul 17 00:19:22 2014

E:\COM\Museum\Апогей_БК-01\86RKSD\Исходники и прошивка контроллера\List\86rksd.asm(1057): warning: Register r5 already defined by the .DEF directive
E:\COM\Museum\Апогей_БК-01\86RKSD\Исходники и прошивка контроллера\List\86rksd.asm(1058): warning: Register r4 already defined by the .DEF directive
E:\COM\Museum\Апогей_БК-01\86RKSD\Исходники и прошивка контроллера\List\86rksd.asm(1059): warning: Register r6 already defined by the .DEF directive
E:\COM\Museum\Апогей_БК-01\86RKSD\Исходники и прошивка контроллера\List\86rksd.asm(1060): warning: Register r9 already defined by the .DEF directive
E:\COM\Museum\Апогей_БК-01\86RKSD\Исходники и прошивка контроллера\List\86rksd.asm(1061): warning: Register r10 already defined by the .DEF directive
                 
                 
                 ;CodeVisionAVR C Compiler V2.05.0 Professional
                 ;(C) Copyright 1998-2010 Pavel Haiduc, HP InfoTech s.r.l.
                 ;http://www.hpinfotech.com
                 
                 ;Chip type                : ATmega8L
                 ;Program type             : Application
                 ;Clock frequency          : 8,000000 MHz
                 ;Memory model             : Small
                 ;Optimize for             : Size
                 ;(s)printf features       : int, width
                 ;(s)scanf features        : int, width
                 ;External RAM size        : 0
                 ;Data Stack size          : 160 byte(s)
                 ;Heap size                : 0 byte(s)
                 ;Promote 'char' to 'int'  : Yes
                 ;'char' is unsigned       : Yes
                 ;8 bit enums              : Yes
                 ;global 'const' stored in FLASH: No
                 ;Enhanced core instructions    : On
                 ;Smart register allocation     : On
                 ;Automatic register allocation : On
                 
                 	#pragma AVRPART ADMIN PART_NAME ATmega8L
                 	#pragma AVRPART MEMORY PROG_FLASH 8192
                 	#pragma AVRPART MEMORY EEPROM 512
                 	#pragma AVRPART MEMORY INT_SRAM SIZE 1119
                 	#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 	.LISTMAC
                 	.EQU UDRE=0x5
                 	.EQU RXC=0x7
                 	.EQU USR=0xB
                 	.EQU UDR=0xC
                 	.EQU SPSR=0xE
                 	.EQU SPDR=0xF
                 	.EQU EERE=0x0
                 	.EQU EEWE=0x1
                 	.EQU EEMWE=0x2
                 	.EQU EECR=0x1C
                 	.EQU EEDR=0x1D
                 	.EQU EEARL=0x1E
                 	.EQU EEARH=0x1F
                 	.EQU WDTCR=0x21
                 	.EQU MCUCR=0x35
                 	.EQU GICR=0x3B
                 	.EQU SPL=0x3D
                 	.EQU SPH=0x3E
                 	.EQU SREG=0x3F
                 
                 	.DEF R0X0=R0
                 	.DEF R0X1=R1
                 	.DEF R0X2=R2
                 	.DEF R0X3=R3
                 	.DEF R0X4=R4
                 	.DEF R0X5=R5
                 	.DEF R0X6=R6
                 	.DEF R0X7=R7
                 	.DEF R0X8=R8
                 	.DEF R0X9=R9
                 	.DEF R0XA=R10
                 	.DEF R0XB=R11
                 	.DEF R0XC=R12
                 	.DEF R0XD=R13
                 	.DEF R0XE=R14
                 	.DEF R0XF=R15
                 	.DEF R0X10=R16
                 	.DEF R0X11=R17
                 	.DEF R0X12=R18
                 	.DEF R0X13=R19
                 	.DEF R0X14=R20
                 	.DEF R0X15=R21
                 	.DEF R0X16=R22
                 	.DEF R0X17=R23
                 	.DEF R0X18=R24
                 	.DEF R0X19=R25
                 	.DEF R0X1A=R26
                 	.DEF R0X1B=R27
                 	.DEF R0X1C=R28
                 	.DEF R0X1D=R29
                 	.DEF R0X1E=R30
                 	.DEF R0X1F=R31
                 
                 	.EQU __SRAM_START=0x0060
                 	.EQU __SRAM_END=0x045F
                 	.EQU __DSTACK_SIZE=0x00A0
                 	.EQU __HEAP_SIZE=0x0000
                 	.EQU __CLEAR_SRAM_SIZE=__SRAM_END-__SRAM_START+1
                 
                 	.MACRO __CPD1N
                 	CPI  R30,LOW(@0)
                 	LDI  R26,HIGH(@0)
                 	CPC  R31,R26
                 	LDI  R26,BYTE3(@0)
                 	CPC  R22,R26
                 	LDI  R26,BYTE4(@0)
                 	CPC  R23,R26
                 	.ENDM
                 
                 	.MACRO __CPD2N
                 	CPI  R26,LOW(@0)
                 	LDI  R30,HIGH(@0)
                 	CPC  R27,R30
                 	LDI  R30,BYTE3(@0)
                 	CPC  R24,R30
                 	LDI  R30,BYTE4(@0)
                 	CPC  R25,R30
                 	.ENDM
                 
                 	.MACRO __CPWRR
                 	CP   R@0,R@2
                 	CPC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __CPWRN
                 	CPI  R@0,LOW(@2)
                 	LDI  R30,HIGH(@2)
                 	CPC  R@1,R30
                 	.ENDM
                 
                 	.MACRO __ADDB1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDB2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW1MN
                 	SUBI R30,LOW(-@0-(@1))
                 	SBCI R31,HIGH(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW2MN
                 	SUBI R26,LOW(-@0-(@1))
                 	SBCI R27,HIGH(-@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDW1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDD1FN
                 	SUBI R30,LOW(-2*@0-(@1))
                 	SBCI R31,HIGH(-2*@0-(@1))
                 	SBCI R22,BYTE3(-2*@0-(@1))
                 	.ENDM
                 
                 	.MACRO __ADDD1N
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	SBCI R22,BYTE3(-@0)
                 	SBCI R23,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __ADDD2N
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	SBCI R24,BYTE3(-@0)
                 	SBCI R25,BYTE4(-@0)
                 	.ENDM
                 
                 	.MACRO __SUBD1N
                 	SUBI R30,LOW(@0)
                 	SBCI R31,HIGH(@0)
                 	SBCI R22,BYTE3(@0)
                 	SBCI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __SUBD2N
                 	SUBI R26,LOW(@0)
                 	SBCI R27,HIGH(@0)
                 	SBCI R24,BYTE3(@0)
                 	SBCI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDBMNN
                 	LDS  R30,@0+(@1)
                 	ANDI R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __ANDWMNN
                 	LDS  R30,@0+(@1)
                 	ANDI R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	LDS  R30,@0+(@1)+1
                 	ANDI R30,HIGH(@2)
                 	STS  @0+(@1)+1,R30
                 	.ENDM
                 
                 	.MACRO __ANDD1N
                 	ANDI R30,LOW(@0)
                 	ANDI R31,HIGH(@0)
                 	ANDI R22,BYTE3(@0)
                 	ANDI R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ANDD2N
                 	ANDI R26,LOW(@0)
                 	ANDI R27,HIGH(@0)
                 	ANDI R24,BYTE3(@0)
                 	ANDI R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORBMNN
                 	LDS  R30,@0+(@1)
                 	ORI  R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __ORWMNN
                 	LDS  R30,@0+(@1)
                 	ORI  R30,LOW(@2)
                 	STS  @0+(@1),R30
                 	LDS  R30,@0+(@1)+1
                 	ORI  R30,HIGH(@2)
                 	STS  @0+(@1)+1,R30
                 	.ENDM
                 
                 	.MACRO __ORD1N
                 	ORI  R30,LOW(@0)
                 	ORI  R31,HIGH(@0)
                 	ORI  R22,BYTE3(@0)
                 	ORI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __ORD2N
                 	ORI  R26,LOW(@0)
                 	ORI  R27,HIGH(@0)
                 	ORI  R24,BYTE3(@0)
                 	ORI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __DELAY_USB
                 	LDI  R24,LOW(@0)
                 __DELAY_USB_LOOP:
                 	DEC  R24
                 	BRNE __DELAY_USB_LOOP
                 	.ENDM
                 
                 	.MACRO __DELAY_USW
                 	LDI  R24,LOW(@0)
                 	LDI  R25,HIGH(@0)
                 __DELAY_USW_LOOP:
                 	SBIW R24,1
                 	BRNE __DELAY_USW_LOOP
                 	.ENDM
                 
                 	.MACRO __GETD1S
                 	LDD  R30,Y+@0
                 	LDD  R31,Y+@0+1
                 	LDD  R22,Y+@0+2
                 	LDD  R23,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __GETD2S
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	LDD  R24,Y+@0+2
                 	LDD  R25,Y+@0+3
                 	.ENDM
                 
                 	.MACRO __PUTD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R31
                 	STD  Y+@0+2,R22
                 	STD  Y+@0+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTD2S
                 	STD  Y+@0,R26
                 	STD  Y+@0+1,R27
                 	STD  Y+@0+2,R24
                 	STD  Y+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __PUTDZ2
                 	STD  Z+@0,R26
                 	STD  Z+@0+1,R27
                 	STD  Z+@0+2,R24
                 	STD  Z+@0+3,R25
                 	.ENDM
                 
                 	.MACRO __CLRD1S
                 	STD  Y+@0,R30
                 	STD  Y+@0+1,R30
                 	STD  Y+@0+2,R30
                 	STD  Y+@0+3,R30
                 	.ENDM
                 
                 	.MACRO __POINTB1MN
                 	LDI  R30,LOW(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW1MN
                 	LDI  R30,LOW(@0+(@1))
                 	LDI  R31,HIGH(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD1M
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __POINTW1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTD1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	LDI  R22,BYTE3(2*@0+(@1))
                 	LDI  R23,BYTE4(2*@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTB2MN
                 	LDI  R26,LOW(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTW2MN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	.ENDM
                 
                 	.MACRO __POINTBRM
                 	LDI  R@0,LOW(@1)
                 	.ENDM
                 
                 	.MACRO __POINTWRM
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __POINTBRMN
                 	LDI  R@0,LOW(@1+(@2))
                 	.ENDM
                 
                 	.MACRO __POINTWRMN
                 	LDI  R@0,LOW(@2+(@3))
                 	LDI  R@1,HIGH(@2+(@3))
                 	.ENDM
                 
                 	.MACRO __POINTWRFN
                 	LDI  R@0,LOW(@2*2+(@3))
                 	LDI  R@1,HIGH(@2*2+(@3))
                 	.ENDM
                 
                 	.MACRO __GETD1N
                 	LDI  R30,LOW(@0)
                 	LDI  R31,HIGH(@0)
                 	LDI  R22,BYTE3(@0)
                 	LDI  R23,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETD2N
                 	LDI  R26,LOW(@0)
                 	LDI  R27,HIGH(@0)
                 	LDI  R24,BYTE3(@0)
                 	LDI  R25,BYTE4(@0)
                 	.ENDM
                 
                 	.MACRO __GETB1MN
                 	LDS  R30,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETB1HMN
                 	LDS  R31,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETW1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	.ENDM
                 
                 	.MACRO __GETD1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	LDS  R22,@0+(@1)+2
                 	LDS  R23,@0+(@1)+3
                 	.ENDM
                 
                 	.MACRO __GETBRMN
                 	LDS  R@0,@1+(@2)
                 	.ENDM
                 
                 	.MACRO __GETWRMN
                 	LDS  R@0,@2+(@3)
                 	LDS  R@1,@2+(@3)+1
                 	.ENDM
                 
                 	.MACRO __GETWRZ
                 	LDD  R@0,Z+@2
                 	LDD  R@1,Z+@2+1
                 	.ENDM
                 
                 	.MACRO __GETD2Z
                 	LDD  R26,Z+@0
                 	LDD  R27,Z+@0+1
                 	LDD  R24,Z+@0+2
                 	LDD  R25,Z+@0+3
                 	.ENDM
                 
                 	.MACRO __GETB2MN
                 	LDS  R26,@0+(@1)
                 	.ENDM
                 
                 	.MACRO __GETW2MN
                 	LDS  R26,@0+(@1)
                 	LDS  R27,@0+(@1)+1
                 	.ENDM
                 
                 	.MACRO __GETD2MN
                 	LDS  R26,@0+(@1)
                 	LDS  R27,@0+(@1)+1
                 	LDS  R24,@0+(@1)+2
                 	LDS  R25,@0+(@1)+3
                 	.ENDM
                 
                 	.MACRO __PUTB1MN
                 	STS  @0+(@1),R30
                 	.ENDM
                 
                 	.MACRO __PUTW1MN
                 	STS  @0+(@1),R30
                 	STS  @0+(@1)+1,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1MN
                 	STS  @0+(@1),R30
                 	STS  @0+(@1)+1,R31
                 	STS  @0+(@1)+2,R22
                 	STS  @0+(@1)+3,R23
                 	.ENDM
                 
                 	.MACRO __PUTB1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	RCALL __EEPROMWRB
                 	.ENDM
                 
                 	.MACRO __PUTW1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	RCALL __EEPROMWRW
                 	.ENDM
                 
                 	.MACRO __PUTD1EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	RCALL __EEPROMWRD
                 	.ENDM
                 
                 	.MACRO __PUTBR0MN
                 	STS  @0+(@1),R0
                 	.ENDM
                 
                 	.MACRO __PUTBMRN
                 	STS  @0+(@1),R@2
                 	.ENDM
                 
                 	.MACRO __PUTWMRN
                 	STS  @0+(@1),R@2
                 	STS  @0+(@1)+1,R@3
                 	.ENDM
                 
                 	.MACRO __PUTBZR
                 	STD  Z+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWZR
                 	STD  Z+@2,R@0
                 	STD  Z+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __GETW1R
                 	MOV  R30,R@0
                 	MOV  R31,R@1
                 	.ENDM
                 
                 	.MACRO __GETW2R
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	.ENDM
                 
                 	.MACRO __GETWRN
                 	LDI  R@0,LOW(@2)
                 	LDI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __PUTW1R
                 	MOV  R@0,R30
                 	MOV  R@1,R31
                 	.ENDM
                 
                 	.MACRO __PUTW2R
                 	MOV  R@0,R26
                 	MOV  R@1,R27
                 	.ENDM
                 
                 	.MACRO __ADDWRN
                 	SUBI R@0,LOW(-@2)
                 	SBCI R@1,HIGH(-@2)
                 	.ENDM
                 
                 	.MACRO __ADDWRR
                 	ADD  R@0,R@2
                 	ADC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __SUBWRN
                 	SUBI R@0,LOW(@2)
                 	SBCI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __SUBWRR
                 	SUB  R@0,R@2
                 	SBC  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ANDWRN
                 	ANDI R@0,LOW(@2)
                 	ANDI R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ANDWRR
                 	AND  R@0,R@2
                 	AND  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __ORWRN
                 	ORI  R@0,LOW(@2)
                 	ORI  R@1,HIGH(@2)
                 	.ENDM
                 
                 	.MACRO __ORWRR
                 	OR   R@0,R@2
                 	OR   R@1,R@3
                 	.ENDM
                 
                 	.MACRO __EORWRR
                 	EOR  R@0,R@2
                 	EOR  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __GETWRS
                 	LDD  R@0,Y+@2
                 	LDD  R@1,Y+@2+1
                 	.ENDM
                 
                 	.MACRO __PUTBSR
                 	STD  Y+@1,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWSR
                 	STD  Y+@2,R@0
                 	STD  Y+@2+1,R@1
                 	.ENDM
                 
                 	.MACRO __MOVEWRR
                 	MOV  R@0,R@2
                 	MOV  R@1,R@3
                 	.ENDM
                 
                 	.MACRO __INWR
                 	IN   R@0,@2
                 	IN   R@1,@2+1
                 	.ENDM
                 
                 	.MACRO __OUTWR
                 	OUT  @2+1,R@1
                 	OUT  @2,R@0
                 	.ENDM
                 
                 	.MACRO __CALL1MN
                 	LDS  R30,@0+(@1)
                 	LDS  R31,@0+(@1)+1
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL1FN
                 	LDI  R30,LOW(2*@0+(@1))
                 	LDI  R31,HIGH(2*@0+(@1))
                 	RCALL __GETW1PF
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __CALL2EN
                 	LDI  R26,LOW(@0+(@1))
                 	LDI  R27,HIGH(@0+(@1))
                 	RCALL __EEPROMRDW
                 	ICALL
                 	.ENDM
                 
                 	.MACRO __GETW1STACK
                 	IN   R26,SPL
                 	IN   R27,SPH
                 	ADIW R26,@0+1
                 	LD   R30,X+
                 	LD   R31,X
                 	.ENDM
                 
                 	.MACRO __GETD1STACK
                 	IN   R26,SPL
                 	IN   R27,SPH
                 	ADIW R26,@0+1
                 	LD   R30,X+
                 	LD   R31,X+
                 	LD   R22,X
                 	.ENDM
                 
                 	.MACRO __NBST
                 	BST  R@0,@1
                 	IN   R30,SREG
                 	LDI  R31,0x40
                 	EOR  R30,R31
                 	OUT  SREG,R30
                 	.ENDM
                 
                 
                 	.MACRO __PUTB1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SN
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	RCALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNS
                 	LDD  R26,Y+@0
                 	LDD  R27,Y+@0+1
                 	ADIW R26,@1
                 	RCALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMN
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	RCALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1PMNS
                 	LDS  R26,@0
                 	LDS  R27,@0+1
                 	ADIW R26,@1
                 	RCALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RN
                 	MOVW R26,R@0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	RCALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RNS
                 	MOVW R26,R@0
                 	ADIW R26,@1
                 	RCALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RON
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	RCALL __PUTDP1
                 	.ENDM
                 
                 	.MACRO __PUTB1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1RONS
                 	MOV  R26,R@0
                 	MOV  R27,R@1
                 	ADIW R26,@2
                 	RCALL __PUTDP1
                 	.ENDM
                 
                 
                 	.MACRO __GETB1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R30,Z
                 	.ENDM
                 
                 	.MACRO __GETB1HSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	.ENDM
                 
                 	.MACRO __GETW1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R31,Z
                 	MOV  R30,R0
                 	.ENDM
                 
                 	.MACRO __GETD1SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R0,Z+
                 	LD   R1,Z+
                 	LD   R22,Z+
                 	LD   R23,Z
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __GETB2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R26,X
                 	.ENDM
                 
                 	.MACRO __GETW2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	.ENDM
                 
                 	.MACRO __GETD2SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R1,X+
                 	LD   R24,X+
                 	LD   R25,X
                 	MOVW R26,R0
                 	.ENDM
                 
                 	.MACRO __GETBRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	LD   R@0,Z
                 	.ENDM
                 
                 	.MACRO __GETWRSX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	LD   R@0,Z+
                 	LD   R@1,Z
                 	.ENDM
                 
                 	.MACRO __GETBRSX2
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	LD   R@0,X
                 	.ENDM
                 
                 	.MACRO __GETWRSX2
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@2)
                 	SBCI R27,HIGH(-@2)
                 	LD   R@0,X+
                 	LD   R@1,X
                 	.ENDM
                 
                 	.MACRO __LSLW8SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	LD   R31,Z
                 	CLR  R30
                 	.ENDM
                 
                 	.MACRO __PUTB1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __CLRW1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __CLRD1SX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	ST   X+,R30
                 	ST   X+,R30
                 	ST   X+,R30
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTB2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z,R26
                 	.ENDM
                 
                 	.MACRO __PUTW2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z,R27
                 	.ENDM
                 
                 	.MACRO __PUTD2SX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@0)
                 	SBCI R31,HIGH(-@0)
                 	ST   Z+,R26
                 	ST   Z+,R27
                 	ST   Z+,R24
                 	ST   Z,R25
                 	.ENDM
                 
                 	.MACRO __PUTBSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@1)
                 	SBCI R31,HIGH(-@1)
                 	ST   Z,R@0
                 	.ENDM
                 
                 	.MACRO __PUTWSRX
                 	MOVW R30,R28
                 	SUBI R30,LOW(-@2)
                 	SBCI R31,HIGH(-@2)
                 	ST   Z+,R@0
                 	ST   Z,R@1
                 	.ENDM
                 
                 	.MACRO __PUTB1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X,R30
                 	.ENDM
                 
                 	.MACRO __PUTW1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X,R31
                 	.ENDM
                 
                 	.MACRO __PUTD1SNX
                 	MOVW R26,R28
                 	SUBI R26,LOW(-@0)
                 	SBCI R27,HIGH(-@0)
                 	LD   R0,X+
                 	LD   R27,X
                 	MOV  R26,R0
                 	SUBI R26,LOW(-@1)
                 	SBCI R27,HIGH(-@1)
                 	ST   X+,R30
                 	ST   X+,R31
                 	ST   X+,R22
                 	ST   X,R23
                 	.ENDM
                 
                 	.MACRO __MULBRR
                 	MULS R@0,R@1
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRRU
                 	MUL  R@0,R@1
                 	MOVW R30,R0
                 	.ENDM
                 
                 	.MACRO __MULBRR0
                 	MULS R@0,R@1
                 	.ENDM
                 
                 	.MACRO __MULBRRU0
                 	MUL  R@0,R@1
                 	.ENDM
                 
                 	.MACRO __MULBNWRU
                 	LDI  R26,@2
                 	MUL  R26,R@0
                 	MOVW R30,R0
                 	MUL  R26,R@1
                 	ADD  R31,R0
                 	.ENDM
                 
                 ;NAME DEFINITIONS FOR GLOBAL VARIABLES ALLOCATED TO REGISTERS
                 	.DEF _fs_type=R5
                 	.DEF _fs_csize=R4
                 	.DEF _fs_n_rootdir=R6
                 	.DEF _sd_sdhc=R9
                 	.DEF _readLength=R10
                 
                 	.CSEG
                 	.ORG 0x00
                 
                 ;START OF CODE MARKER
                 __START_OF_CODE:
                 
                 ;INTERRUPT VECTORS
000000 c031      	RJMP __RESET
000001 cffe      	RJMP 0x00
000002 cffd      	RJMP 0x00
000003 cffc      	RJMP 0x00
000004 cffb      	RJMP 0x00
000005 cffa      	RJMP 0x00
000006 cff9      	RJMP 0x00
000007 cff8      	RJMP 0x00
000008 cff7      	RJMP 0x00
000009 cff6      	RJMP 0x00
00000a cff5      	RJMP 0x00
00000b cff4      	RJMP 0x00
00000c cff3      	RJMP 0x00
00000d cff2      	RJMP 0x00
00000e cff1      	RJMP 0x00
00000f cff0      	RJMP 0x00
000010 cfef      	RJMP 0x00
000011 cfee      	RJMP 0x00
000012 cfed      	RJMP 0x00
                 
                 _0x20000:
000013 2c2b
000014 3d3b
000015 5d5b
000016 3f2a      	.DB  0x2B,0x2C,0x3B,0x3D,0x5B,0x5D,0x2A,0x3F
000017 3a3c
000018 5c3e
000019 227c
E:\COM\Museum\Апогей_БК-01\86RKSD\Исходники и прошивка контроллера\List\86rksd.asm(1092): warning: .cseg .db misalignment - padding zero byte
00001a 0000      	.DB  0x3C,0x3A,0x3E,0x5C,0x7C,0x22,0x0
                 _0x60000:
00001b 3156
00001c 302e
00001d 3120
00001e 2d30      	.DB  0x56,0x31,0x2E,0x30,0x20,0x31,0x30,0x2D
00001f 3530
000020 322d
000021 3130
000022 2034      	.DB  0x30,0x35,0x2D,0x32,0x30,0x31,0x34,0x20
000023 6200
000024 6f6f
000025 2f74
000026 6473      	.DB  0x0,0x62,0x6F,0x6F,0x74,0x2F,0x73,0x64
000027 6962
000028 736f
000029 722e
00002a 006b      	.DB  0x62,0x69,0x6F,0x73,0x2E,0x72,0x6B,0x0
00002b 6f62
00002c 746f
00002d 622f
00002e 6f6f      	.DB  0x62,0x6F,0x6F,0x74,0x2F,0x62,0x6F,0x6F
00002f 2e74
000030 6b72
E:\COM\Museum\Апогей_БК-01\86RKSD\Исходники и прошивка контроллера\List\86rksd.asm(1099): warning: .cseg .db misalignment - padding zero byte
000031 0000      	.DB  0x74,0x2E,0x72,0x6B,0x0
                 __RESET:
000032 94f8      	CLI
000033 27ee      	CLR  R30
000034 bbec      	OUT  EECR,R30
                 
                 ;INTERRUPT VECTORS ARE PLACED
                 ;AT THE START OF FLASH
000035 e0f1      	LDI  R31,1
000036 bffb      	OUT  GICR,R31
000037 bfeb      	OUT  GICR,R30
000038 bfe5      	OUT  MCUCR,R30
                 
                 ;DISABLE WATCHDOG
000039 e1f8      	LDI  R31,0x18
00003a bdf1      	OUT  WDTCR,R31
00003b bde1      	OUT  WDTCR,R30
                 
                 ;CLEAR R2-R14
00003c e08d      	LDI  R24,(14-2)+1
00003d e0a2      	LDI  R26,2
00003e 27bb      	CLR  R27
                 __CLEAR_REG:
00003f 93ed      	ST   X+,R30
000040 958a      	DEC  R24
000041 f7e9      	BRNE __CLEAR_REG
                 
                 ;CLEAR SRAM
000042 e080      	LDI  R24,LOW(__CLEAR_SRAM_SIZE)
000043 e094      	LDI  R25,HIGH(__CLEAR_SRAM_SIZE)
000044 e6a0      	LDI  R26,__SRAM_START
                 __CLEAR_SRAM:
000045 93ed      	ST   X+,R30
000046 9701      	SBIW R24,1
000047 f7e9      	BRNE __CLEAR_SRAM
                 
                 ;HARDWARE STACK POINTER INITIALIZATION
000048 e5ef      	LDI  R30,LOW(__SRAM_END-__HEAP_SIZE)
000049 bfed      	OUT  SPL,R30
00004a e0e4      	LDI  R30,HIGH(__SRAM_END-__HEAP_SIZE)
00004b bfee      	OUT  SPH,R30
                 
                 ;DATA STACK POINTER INITIALIZATION
00004c e0c0      	LDI  R28,LOW(__SRAM_START+__DSTACK_SIZE)
00004d e0d1      	LDI  R29,HIGH(__SRAM_START+__DSTACK_SIZE)
                 
00004e c996      	RJMP _main
                 
                 	.ESEG
                 	.ORG 0
                 
                 	.DSEG
                 	.ORG 0x100
                 
                 	.CSEG
                 ;// SD Controller for Computer "Radio 86RK" / "Apogee BK01"
                 ;// (c) 10-05-2014 vinxru (aleksey.f.morozov@gmail.com)
                 ;
                 ;#include "proto.h"
                 	#ifndef __SLEEP_DEFINED__
                 	#define __SLEEP_DEFINED__
                 	.EQU __se_bit=0x80
                 	.EQU __sm_mask=0x70
                 	.EQU __sm_powerdown=0x20
                 	.EQU __sm_powersave=0x30
                 	.EQU __sm_standby=0x60
                 	.EQU __sm_ext_standby=0x70
                 	.EQU __sm_adc_noise_red=0x10
                 	.SET power_ctrl_reg=mcucr
                 	#endif
                 ;
                 ;void wait() {
                 ; 0000 0006 void wait() {
                 
                 	.CSEG
                 _wait:
                 ; 0000 0007     // Ждем перепад 0->1
                 ; 0000 0008     while(!PINC.5);
                 _0x3:
00004f 9b9d      	SBIS 0x13,5
000050 cffe      	RJMP _0x3
                 ; 0000 0009     while(PINC.5);
                 _0x6:
000051 999d      	SBIC 0x13,5
000052 cffe      	RJMP _0x6
                 ; 0000 000A //    while((PINC&0x3F)==0);
                 ; 0000 000B //    while((PINC&0x3F)==0x20);
                 ; 0000 000C     if((PINC&0x3F)==0) return;
000053 b3e3      	IN   R30,0x13
000054 73ef      	ANDI R30,LOW(0x3F)
000055 f409      	BRNE _0x9
000056 9508      	RET
                 ; 0000 000D #asm
                 _0x9:
                 ; 0000 000E     RJMP 0
000057 cfa8          RJMP 0
                 ; 0000 000F #endasm
                 ; 0000 0010 }
000058 9508      	RET
                 ;
                 ;void sendStart(BYTE c) {
                 ; 0000 0012 void sendStart(BYTE c) {
                 _sendStart:
                 ; 0000 0013     wait();
                 ;	c -> Y+0
000059 dff5      	RCALL _wait
                 ; 0000 0014     DATA_OUT
00005a efef      	LDI  R30,LOW(255)
00005b bbe1      	OUT  0x11,R30
                 ; 0000 0015     PORTD = c;
00005c 81e8      	LD   R30,Y
00005d bbe2      	OUT  0x12,R30
                 ; 0000 0016 }
00005e 9621      	ADIW R28,1
00005f 9508      	RET
                 ;
                 ;void recvStart() {
                 ; 0000 0018 void recvStart() {
                 _recvStart:
                 ; 0000 0019     wait();
000060 dfee      	RCALL _wait
                 ; 0000 001A     DATA_IN
000061 e0e0      	LDI  R30,LOW(0)
000062 bbe1      	OUT  0x11,R30
                 ; 0000 001B     PORTD = 0xFF;
000063 efef      	LDI  R30,LOW(255)
000064 bbe2      	OUT  0x12,R30
                 ; 0000 001C }
000065 9508      	RET
                 ;
                 ;BYTE wrecv() {
                 ; 0000 001E BYTE wrecv() {
                 _wrecv:
                 ; 0000 001F     wait();
000066 dfe8      	RCALL _wait
                 ; 0000 0020     return PIND;
000067 b3e0      	IN   R30,0x10
000068 9508      	RET
                 ; 0000 0021 }
                 ;
                 ;void send(BYTE c) {
                 ; 0000 0023 void send(BYTE c) {
                 _send:
                 ; 0000 0024     wait();
                 ;	c -> Y+0
000069 dfe5      	RCALL _wait
                 ; 0000 0025     PORTD = c;
00006a 81e8      	LD   R30,Y
00006b bbe2      	OUT  0x12,R30
                 ; 0000 0026 }
00006c c68a      	RJMP _0x202000F
                 ;/*
                 ;It is an open source software to implement FAT file system to
                 ;small embedded systems. This is a free software and is opened for education,
                 ;research and commercial developments under license policy of following trems.
                 ;
                 ;(C) 2013-2014 vinxru
                 ;(C) 2010, ChaN, all right reserved.
                 ;
                 ;It is a free software and there is NO WARRANTY.
                 ;No restriction on use. You can use, modify and redistribute it for
                 ;personal, non-profit or commercial use UNDER YOUR RESPONSIBILITY.
                 ;Redistributions of source code must retain the above copyright notice.
                 ;
                 ;Version 1.0 10-05-2014
                 ;
                 ;P.S. goto allows you to save memory! Like other horrors bellow.
                 ;
                 ;Program size: 3070 words (6140 bytes), 75% of FLASH at ATMega8 !!!
                 ;*/
                 ;
                 ;/*
                 ;Я не стал добавлять контроль на специальные имена
                 ;CON,PRN,AUX,CLOCK$,NUL,COM1,COM2,COM3,COM4,LPT1,LPT2,LPT3
                 ;что бы не занимать микроконтроллер. Файлы с такими именами
                 ;оставляю на совести программиста.
                 ;*/
                 ;
                 ;//#include <stdafx.h>
                 ;#include "fs.h"
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include "sd.h"
                 ;#include <string.h>
                 ;
                 ;/* Для наглядности */
                 ;
                 ;#define	LD_WORD(ptr)    (*(WORD*)(ptr))
                 ;#define	LD_DWORD(ptr)   (*(DWORD*)(ptr))
                 ;
                 ;/* Значения fs_type */
                 ;
                 ;#define FS_FAT16	0
                 ;#define FS_FAT32	1
                 ;#define FS_ERROR	2
                 ;
                 ;/* Специальные значения кластеров */
                 ;
                 ;#define FREE_CLUSTER    0
                 ;#define LAST_CLUSTER    0x0FFFFFFF
                 ;
                 ;/* Системные переменные. Информация из boot-сектора */
                 ;
                 ;typedef struct {
                 ;#ifndef FS_DISABLE_CHECK
                 ;  BYTE  opened;              /* Что открыто: OPENED_NONE, OPENED_FILE, OPENED_DIR */
                 ;#endif
                 ;  BYTE  entry_able;          /* Результат выполнения функции fs_dirread */
                 ;  WORD  entry_index;         /* Номер записи в каталоге */
                 ;  DWORD entry_cluster;       /* Кластер записи в каталоге */
                 ;  DWORD entry_sector;        /* Сектор записи в каталоге */
                 ;  DWORD entry_start_cluster; /* Первый сектор файла или каталога (0 - корневой каталог FAT16) */
                 ;  DWORD ptr;                 /* Указатель чтения/записи файла*/
                 ;  DWORD size;                /* Размер файла / File size */
                 ;  DWORD cluster;             /* Текущий кластер файла */
                 ;  DWORD sector;              /* Текущий сектор файла */
                 ;  BYTE  changed;             /* Размер файла изменился, надо сохранить */
                 ;} File;
                 ;
                 ;BYTE  fs_type;         /* FS_FAT16, FS_FAT32, FS_ERROR */
                 ;DWORD fs_fatbase;      /* Адрес первой FAT */
                 ;DWORD fs_fatbase2;     /* Адрес второй FAT */
                 ;BYTE  fs_csize;        /* Размер кластера в секторах */
                 ;WORD  fs_n_rootdir;    /* Кол-во записей в корневом каталоге (только FAT16) */
                 ;DWORD fs_n_fatent;     /* Кол-во кластеров */
                 ;DWORD fs_dirbase;      /* Корневой каталог (сектор для FAT16, кластер для FAT32) */
                 ;DWORD fs_database;     /* Адрес второго кластера */
                 ;
                 ;/* Системные переменные. Остальное */
                 ;
                 ;BYTE  lastError;       /* Последняя ошибка */
                 ;DWORD fs_fatoptim;     /* Первый свободный кластер */
                 ;DWORD fs_tmp;          /* Используеются для разных целей */
                 ;WORD  fs_wtotal;       /* Используется функциями fs_write_start, fs_write_end*/
                 ;
                 ;/* Открытые файлы/папки */
                 ;
                 ;File fs_file;
                 ;
                 ;#ifndef FS_DISABLE_SWAP
                 ;File fs_secondFile;
                 ;#endif
                 ;
                 ;/* Структура boot-сектора */
                 ;
                 ;#define BPB_SecPerClus    13
                 ;#define BPB_RsvdSecCnt    14
                 ;#define BPB_NumFATs       16
                 ;#define BPB_RootEntCnt    17
                 ;#define BPB_TotSec16      19
                 ;#define BPB_FATSz16       22
                 ;#define BPB_TotSec32      32
                 ;#define BS_FilSysType     54
                 ;#define BPB_FATSz32       36
                 ;#define BPB_RootClus      44
                 ;#define BS_FilSysType32   82
                 ;#define MBR_Table         446
                 ;
                 ;/**************************************************************************
                 ;*  Чтение сектора в буфер                                                 *
                 ;**************************************************************************/
                 ;
                 ;static BYTE sd_readBuf(DWORD sector) {
                 ; 0001 006E static BYTE sd_readBuf(DWORD sector) {
                 
                 	.CSEG
                 _sd_readBuf_G001:
                 ; 0001 006F   return sd_read(buf, sector, 0, 512);
                 ;	sector -> Y+0
00006d da6d      	RCALL SUBOPT_0x0
00006e da76      	RCALL SUBOPT_0x1
00006f da78      	RCALL SUBOPT_0x2
000070 e0e0      	LDI  R30,LOW(512)
000071 e0f2      	LDI  R31,HIGH(512)
000072 da78      	RCALL SUBOPT_0x3
000073 c143      	RJMP _0x202001A
                 ; 0001 0070 }
                 ;
                 ;/**************************************************************************
                 ;*  Запись буфера в сектор                                                 *
                 ;**************************************************************************/
                 ;
                 ;static BYTE sd_writeBuf(DWORD sector) {
                 ; 0001 0076 static BYTE sd_writeBuf(DWORD sector) {
                 _sd_writeBuf_G001:
                 ; 0001 0077   return sd_write512(buf, sector);
                 ;	sector -> Y+0
000074 da66      	RCALL SUBOPT_0x0
000075 d760      	RCALL _sd_write512
000076 c140      	RJMP _0x202001A
                 ; 0001 0078 }
                 ;
                 ;/**************************************************************************
                 ;*  Инициализация                                                          *
                 ;**************************************************************************/
                 ;
                 ;BYTE fs_init() {
                 ; 0001 007E BYTE fs_init() {
                 _fs_init:
                 ; 0001 007F   DWORD bsect, fsize, tsect;
                 ; 0001 0080 
                 ; 0001 0081   /* Сбрасываем оптимизацию */
                 ; 0001 0082   fs_fatoptim = 2;
000077 972c      	SBIW R28,12
                 ;	bsect -> Y+8
                 ;	fsize -> Y+4
                 ;	tsect -> Y+0
                +
000078 e0e2     +LDI R30 , LOW ( 0x2 )
000079 e0f0     +LDI R31 , HIGH ( 0x2 )
00007a e060     +LDI R22 , BYTE3 ( 0x2 )
00007b e070     +LDI R23 , BYTE4 ( 0x2 )
                 	__GETD1N 0x2
00007c da70      	RCALL SUBOPT_0x4
                 ; 0001 0083 
                 ; 0001 0084   /* Предотвращаем ошибки программиста */
                 ; 0001 0085 #ifndef FS_DISABLE_CHECK
                 ; 0001 0086   fs_file.opened = OPENED_NONE;
00007d da78      	RCALL SUBOPT_0x5
                 ; 0001 0087 #ifndef FS_DISABLE_SWAP
                 ; 0001 0088   fs_secondFile.opened = OPENED_NONE;
00007e da7b      	RCALL SUBOPT_0x6
                 ; 0001 0089 #endif
                 ; 0001 008A   fs_type = FS_ERROR;
00007f e0e2      	LDI  R30,LOW(2)
000080 2e5e      	MOV  R5,R30
                 ; 0001 008B #endif
                 ; 0001 008C 
                 ; 0001 008D   /* Инициализация накопителя */
                 ; 0001 008E   if(sd_init()) return 1;
000081 d6f1      	RCALL _sd_init
000082 30e0      	CPI  R30,0
000083 f011      	BREQ _0x20003
000084 e0e1      	LDI  R30,LOW(1)
000085 c117      	RJMP _0x202001B
                 ; 0001 008F 
                 ; 0001 0090   /* Ищем файловую систему */
                 ; 0001 0091   bsect = 0;
                 _0x20003:
000086 e0e0      	LDI  R30,LOW(0)
                +
000087 87e8     +STD Y + 8 , R30
000088 87e9     +STD Y + 8 + 1 , R30
000089 87ea     +STD Y + 8 + 2 , R30
00008a 87eb     +STD Y + 8 + 3 , R30
                 	__CLRD1S 8
                 ; 0001 0092   while(1) {
                 _0x20004:
                 ; 0001 0093     if(sd_readBuf(bsect)) return 1;
00008b da72      	RCALL SUBOPT_0x7
00008c da76      	RCALL SUBOPT_0x8
00008d f011      	BREQ _0x20007
00008e e0e1      	LDI  R30,LOW(1)
00008f c10d      	RJMP _0x202001B
                 ; 0001 0094     if(LD_WORD(buf + 510) == 0xAA55) {
                 _0x20007:
                +
000090 91e0 037e+LDS R30 , _buf + ( 510 )
000092 91f0 037f+LDS R31 , _buf + ( 510 ) + 1
                 	__GETW1MN _buf,510
000094 35e5      	CPI  R30,LOW(0xAA55)
000095 eaaa      	LDI  R26,HIGH(0xAA55)
000096 07fa      	CPC  R31,R26
000097 f519      	BRNE _0x20008
                 ; 0001 0095       if(LD_WORD(buf + BS_FilSysType  ) == 0x4146) break;
                +
000098 91e0 01b6+LDS R30 , _buf + ( 54 )
00009a 91f0 01b7+LDS R31 , _buf + ( 54 ) + 1
                 	__GETW1MN _buf,54
00009c 34e6      	CPI  R30,LOW(0x4146)
00009d e4a1      	LDI  R26,HIGH(0x4146)
00009e 07fa      	CPC  R31,R26
00009f f0f9      	BREQ _0x20006
                 ; 0001 0096       if(LD_WORD(buf + BS_FilSysType32) == 0x4146) break;
                +
0000a0 91e0 01d2+LDS R30 , _buf + ( 82 )
0000a2 91f0 01d3+LDS R31 , _buf + ( 82 ) + 1
                 	__GETW1MN _buf,82
0000a4 34e6      	CPI  R30,LOW(0x4146)
0000a5 e4a1      	LDI  R26,HIGH(0x4146)
0000a6 07fa      	CPC  R31,R26
0000a7 f0b9      	BREQ _0x20006
                 ; 0001 0097       /* Возможно это MBR */
                 ; 0001 0098       if(bsect == 0 && buf[MBR_Table+4]) {
0000a8 da5e      	RCALL SUBOPT_0x9
0000a9 de51      	RCALL __CPD02
0000aa f421      	BRNE _0x2000C
                +
0000ab 91e0 0342+LDS R30 , _buf + ( 450 )
                 	__GETB1MN _buf,450
0000ad 30e0      	CPI  R30,0
0000ae f409      	BRNE _0x2000D
                 _0x2000C:
0000af c00b      	RJMP _0x2000B
                 _0x2000D:
                 ; 0001 0099         bsect = LD_DWORD(buf + (MBR_Table + 8));
                +
0000b0 91e0 0346+LDS R30 , _buf + ( 454 )
0000b2 91f0 0347+LDS R31 , _buf + ( 454 ) + 1
0000b4 9160 0348+LDS R22 , _buf + ( 454 ) + 2
0000b6 9170 0349+LDS R23 , _buf + ( 454 ) + 3
                 	__GETD1MN _buf,454
0000b8 da53      	RCALL SUBOPT_0xA
                 ; 0001 009A         if(bsect != 0) continue;
0000b9 de39      	RCALL __CPD10
0000ba f681      	BRNE _0x20004
                 ; 0001 009B       }
                 ; 0001 009C     }
                 _0x2000B:
                 ; 0001 009D abort_noFS:
                 _0x20008:
                 _0x2000F:
                 ; 0001 009E     lastError = ERR_NO_FILESYSTEM; return 1;
0000bb e0e1      	LDI  R30,LOW(1)
0000bc da54      	RCALL SUBOPT_0xB
0000bd e0e1      	LDI  R30,LOW(1)
0000be c0de      	RJMP _0x202001B
                 ; 0001 009F   }
                 _0x20006:
                 ; 0001 00A0 
                 ; 0001 00A1   /* Размер таблицы FAT в секторах */
                 ; 0001 00A2   fsize = LD_WORD(buf + BPB_FATSz16);
                +
0000bf 91e0 0196+LDS R30 , _buf + ( 22 )
0000c1 91f0 0197+LDS R31 , _buf + ( 22 ) + 1
                 	__GETW1MN _buf,22
0000c3 da50      	RCALL SUBOPT_0xC
0000c4 da52      	RCALL SUBOPT_0xD
                 ; 0001 00A3   if(fsize == 0) fsize = LD_DWORD(buf + BPB_FATSz32);
0000c5 da56      	RCALL SUBOPT_0xE
0000c6 de2c      	RCALL __CPD10
0000c7 f449      	BRNE _0x20010
                +
0000c8 91e0 01a4+LDS R30 , _buf + ( 36 )
0000ca 91f0 01a5+LDS R31 , _buf + ( 36 ) + 1
0000cc 9160 01a6+LDS R22 , _buf + ( 36 ) + 2
0000ce 9170 01a7+LDS R23 , _buf + ( 36 ) + 3
                 	__GETD1MN _buf,36
0000d0 da46      	RCALL SUBOPT_0xD
                 ; 0001 00A4 
                 ; 0001 00A5   /* Размер файловой системы в секторах */
                 ; 0001 00A6   tsect = LD_WORD( buf + BPB_TotSec16);
                 _0x20010:
                +
0000d1 91e0 0193+LDS R30 , _buf + ( 19 )
0000d3 91f0 0194+LDS R31 , _buf + ( 19 ) + 1
                 	__GETW1MN _buf,19
0000d5 da4b      	RCALL SUBOPT_0xF
                 ; 0001 00A7   if(tsect == 0) tsect = LD_DWORD(buf + BPB_TotSec32);
0000d6 da4d      	RCALL SUBOPT_0x10
0000d7 de1b      	RCALL __CPD10
0000d8 f449      	BRNE _0x20011
                +
0000d9 91e0 01a0+LDS R30 , _buf + ( 32 )
0000db 91f0 01a1+LDS R31 , _buf + ( 32 ) + 1
0000dd 9160 01a2+LDS R22 , _buf + ( 32 ) + 2
0000df 9170 01a3+LDS R23 , _buf + ( 32 ) + 3
                 	__GETD1MN _buf,32
0000e1 da44      	RCALL SUBOPT_0x11
                 ; 0001 00A8 
                 ; 0001 00A9   /* Размер корневого каталога (должно быть кратно 16 и для FAT32 должно быть рано нулю) */
                 ; 0001 00AA   fs_n_rootdir = LD_WORD(buf + BPB_RootEntCnt);
                 _0x20011:
                +
0000e2 9060 0191+LDS R6 , _buf + ( 17 )
0000e4 9070 0192+LDS R7 , _buf + ( 17 ) + 1
                 	__GETWRMN 6,7,_buf,17
                 ; 0001 00AB 
                 ; 0001 00AC   /* Адреса таблиц FAT в секторах */
                 ; 0001 00AD   fs_fatbase  = bsect + LD_WORD(buf + BPB_RsvdSecCnt);
0000e6 da41      	RCALL SUBOPT_0x12
0000e7 da1f      	RCALL SUBOPT_0x9
0000e8 da44      	RCALL SUBOPT_0x13
0000e9 93e0 0387 	STS  _fs_fatbase,R30
0000eb 93f0 0388 	STS  _fs_fatbase+1,R31
0000ed 9360 0389 	STS  _fs_fatbase+2,R22
0000ef 9370 038a 	STS  _fs_fatbase+3,R23
                 ; 0001 00AE   fs_fatbase2 = 0;
0000f1 e0e0      	LDI  R30,LOW(0)
0000f2 93e0 038b 	STS  _fs_fatbase2,R30
0000f4 93e0 038c 	STS  _fs_fatbase2+1,R30
0000f6 93e0 038d 	STS  _fs_fatbase2+2,R30
0000f8 93e0 038e 	STS  _fs_fatbase2+3,R30
                 ; 0001 00AF   if(buf[BPB_NumFATs] >= 2) fs_fatbase2 = fs_fatbase + fsize;
                +
0000fa 91a0 0190+LDS R26 , _buf + ( 16 )
                 	__GETB2MN _buf,16
0000fc 30a2      	CPI  R26,LOW(0x2)
0000fd f050      	BRLO _0x20012
0000fe da31      	RCALL SUBOPT_0x14
0000ff dcec      	RCALL __ADDD12
000100 93e0 038b 	STS  _fs_fatbase2,R30
000102 93f0 038c 	STS  _fs_fatbase2+1,R31
000104 9360 038d 	STS  _fs_fatbase2+2,R22
000106 9370 038e 	STS  _fs_fatbase2+3,R23
                 ; 0001 00B0 
                 ; 0001 00B1   /* Кол-во секторов на кластер */
                 ; 0001 00B2   fs_csize = buf[BPB_SecPerClus];
                 _0x20012:
                +
000108 9040 018d+LDS R4 , _buf + ( 13 )
                 	__GETBRMN 4,_buf,13
                 ; 0001 00B3 
                 ; 0001 00B4   /* Кол-во кластеров */
                 ; 0001 00B5   fsize *= buf[BPB_NumFATs];
                +
00010a 91e0 0190+LDS R30 , _buf + ( 16 )
                 	__GETB1MN _buf,16
00010c da2d      	RCALL SUBOPT_0x15
00010d da2e      	RCALL SUBOPT_0x16
00010e da32      	RCALL SUBOPT_0x17
00010f dd37      	RCALL __MULD12U
000110 da06      	RCALL SUBOPT_0xD
                 ; 0001 00B6   fs_n_fatent = (tsect - LD_WORD(buf + BPB_RsvdSecCnt) - fsize - fs_n_rootdir / 16) / fs_csize + 2;
000111 da16      	RCALL SUBOPT_0x12
000112 da30      	RCALL SUBOPT_0x18
000113 da00      	RCALL SUBOPT_0xC
000114 ddd1      	RCALL __SWAPD12
000115 dce0      	RCALL __SUBD12
000116 da25      	RCALL SUBOPT_0x16
000117 dcde      	RCALL __SUBD12
000118 da2c      	RCALL SUBOPT_0x19
000119 01f3      	MOVW R30,R6
00011a dd0f      	RCALL __LSRW4
00011b d9f8      	RCALL SUBOPT_0xC
00011c dcde      	RCALL __SUBD21
00011d da2a      	RCALL SUBOPT_0x1A
00011e dd5b      	RCALL __DIVD21U
                +
00011f 5fee     +SUBI R30 , LOW ( - 2 )
000120 4fff     +SBCI R31 , HIGH ( - 2 )
000121 4f6f     +SBCI R22 , BYTE3 ( - 2 )
000122 4f7f     +SBCI R23 , BYTE4 ( - 2 )
                 	__ADDD1N 2
000123 93e0 038f 	STS  _fs_n_fatent,R30
000125 93f0 0390 	STS  _fs_n_fatent+1,R31
000127 9360 0391 	STS  _fs_n_fatent+2,R22
000129 9370 0392 	STS  _fs_n_fatent+3,R23
                 ; 0001 00B7 
                 ; 0001 00B8   /* Адрес 2-ого кластера */
                 ; 0001 00B9   fs_database = fs_fatbase + fsize + fs_n_rootdir / 16;
00012b da04      	RCALL SUBOPT_0x14
00012c dcc4      	RCALL __ADDD21
00012d 01f3      	MOVW R30,R6
00012e dcfb      	RCALL __LSRW4
00012f d9fd      	RCALL SUBOPT_0x13
000130 93e0 0397 	STS  _fs_database,R30
000132 93f0 0398 	STS  _fs_database+1,R31
000134 9360 0399 	STS  _fs_database+2,R22
000136 9370 039a 	STS  _fs_database+3,R23
                 ; 0001 00BA 
                 ; 0001 00BB   /* Определение файловой системы */
                 ; 0001 00BC 
                 ; 0001 00BD   /* FAT 12 */
                 ; 0001 00BE   if(fs_n_fatent < 0xFF7) goto abort_noFS;
000138 da12      	RCALL SUBOPT_0x1B
                +
000139 3fa7     +CPI R26 , LOW ( 0xFF7 )
00013a e0ef     +LDI R30 , HIGH ( 0xFF7 )
00013b 07be     +CPC R27 , R30
00013c e0e0     +LDI R30 , BYTE3 ( 0xFF7 )
00013d 078e     +CPC R24 , R30
00013e e0e0     +LDI R30 , BYTE4 ( 0xFF7 )
00013f 079e     +CPC R25 , R30
                 	__CPD2N 0xFF7
000140 f408      	BRSH _0x20013
000141 cf79      	RJMP _0x2000F
                 ; 0001 00BF 
                 ; 0001 00C0   /* FAT 16 */
                 ; 0001 00C1   if(fs_n_fatent < 0xFFF7) {
                 _0x20013:
000142 da08      	RCALL SUBOPT_0x1B
                +
000143 3fa7     +CPI R26 , LOW ( 0xFFF7 )
000144 efef     +LDI R30 , HIGH ( 0xFFF7 )
000145 07be     +CPC R27 , R30
000146 e0e0     +LDI R30 , BYTE3 ( 0xFFF7 )
000147 078e     +CPC R24 , R30
000148 e0e0     +LDI R30 , BYTE4 ( 0xFFF7 )
000149 079e     +CPC R25 , R30
                 	__CPD2N 0xFFF7
00014a f428      	BRSH _0x20014
                 ; 0001 00C2     fs_dirbase = fs_fatbase + fsize;
00014b d9e4      	RCALL SUBOPT_0x14
00014c dc9f      	RCALL __ADDD12
00014d da06      	RCALL SUBOPT_0x1C
                 ; 0001 00C3     fs_type = FS_FAT16;
00014e 2455      	CLR  R5
                 ; 0001 00C4     return 0;
00014f c04c      	RJMP _0x202001C
                 ; 0001 00C5   }
                 ; 0001 00C6 
                 ; 0001 00C7   /* FAT 32 */
                 ; 0001 00C8   fs_dirbase = LD_DWORD(buf + BPB_RootClus);
                 _0x20014:
                +
000150 91e0 01ac+LDS R30 , _buf + ( 44 )
000152 91f0 01ad+LDS R31 , _buf + ( 44 ) + 1
000154 9160 01ae+LDS R22 , _buf + ( 44 ) + 2
000156 9170 01af+LDS R23 , _buf + ( 44 ) + 3
                 	__GETD1MN _buf,44
000158 d9fb      	RCALL SUBOPT_0x1C
                 ; 0001 00C9 
                 ; 0001 00CA   /* Сбрасываем счетчик свободного места */
                 ; 0001 00CB   if(LD_WORD(buf + BPB_RsvdSecCnt)>0) {
                +
000159 91a0 018e+LDS R26 , _buf + ( 14 )
00015b 91b0 018f+LDS R27 , _buf + ( 14 ) + 1
                 	__GETW2MN _buf,14
00015d dd99      	RCALL __CPW02
00015e f5d8      	BRSH _0x20015
                 ; 0001 00CC     bsect++;
00015f d99e      	RCALL SUBOPT_0x7
000160 d9fc      	RCALL SUBOPT_0x1D
000161 d9aa      	RCALL SUBOPT_0xA
                 ; 0001 00CD     if(sd_readBuf(bsect)) return 1;
000162 d9a0      	RCALL SUBOPT_0x8
000163 f011      	BREQ _0x20016
000164 e0e1      	LDI  R30,LOW(1)
000165 c037      	RJMP _0x202001B
                 ; 0001 00CE     if(LD_DWORD(buf) == 0x41615252 && LD_DWORD(buf + 0x1E4) == 0x61417272 && LD_DWORD(buf + 0x1FC) == 0xAA550000) {
                 _0x20016:
000166 91a0 0180 	LDS  R26,_buf
000168 91b0 0181 	LDS  R27,_buf+1
00016a 9180 0182 	LDS  R24,_buf+2
00016c 9190 0183 	LDS  R25,_buf+3
                +
00016e 35a2     +CPI R26 , LOW ( 0x41615252 )
00016f e5e2     +LDI R30 , HIGH ( 0x41615252 )
000170 07be     +CPC R27 , R30
000171 e6e1     +LDI R30 , BYTE3 ( 0x41615252 )
000172 078e     +CPC R24 , R30
000173 e4e1     +LDI R30 , BYTE4 ( 0x41615252 )
000174 079e     +CPC R25 , R30
                 	__CPD2N 0x41615252
000175 f4c9      	BRNE _0x20018
                +
000176 91e0 0364+LDS R30 , _buf + ( 484 )
000178 91f0 0365+LDS R31 , _buf + ( 484 ) + 1
00017a 9160 0366+LDS R22 , _buf + ( 484 ) + 2
00017c 9170 0367+LDS R23 , _buf + ( 484 ) + 3
                 	__GETD1MN _buf,484
                +
00017e 37e2     +CPI R30 , LOW ( 0x61417272 )
00017f e7a2     +LDI R26 , HIGH ( 0x61417272 )
000180 07fa     +CPC R31 , R26
000181 e4a1     +LDI R26 , BYTE3 ( 0x61417272 )
000182 076a     +CPC R22 , R26
000183 e6a1     +LDI R26 , BYTE4 ( 0x61417272 )
000184 077a     +CPC R23 , R26
                 	__CPD1N 0x61417272
000185 f449      	BRNE _0x20018
000186 d9db      	RCALL SUBOPT_0x1E
                +
000187 30e0     +CPI R30 , LOW ( 0xAA550000 )
000188 e0a0     +LDI R26 , HIGH ( 0xAA550000 )
000189 07fa     +CPC R31 , R26
00018a e5a5     +LDI R26 , BYTE3 ( 0xAA550000 )
00018b 076a     +CPC R22 , R26
00018c eaaa     +LDI R26 , BYTE4 ( 0xAA550000 )
00018d 077a     +CPC R23 , R26
                 	__CPD1N 0xAA550000
00018e f009      	BREQ _0x20019
                 _0x20018:
00018f c00a      	RJMP _0x20017
                 _0x20019:
                 ; 0001 00CF       LD_DWORD(buf + 0x1E8) = 0xFFFFFFFF;
                +
000190 e6e8     +LDI R30 , LOW ( _buf + ( 488 ) )
000191 e0f3     +LDI R31 , HIGH ( _buf + ( 488 ) )
                 	__POINTW1MN _buf,488
000192 d9d8      	RCALL SUBOPT_0x1F
                 ; 0001 00D0       LD_DWORD(buf + 0x1EC) = 0xFFFFFFFF;
                +
000193 e6ec     +LDI R30 , LOW ( _buf + ( 492 ) )
000194 e0f3     +LDI R31 , HIGH ( _buf + ( 492 ) )
                 	__POINTW1MN _buf,492
000195 d9d5      	RCALL SUBOPT_0x1F
                 ; 0001 00D1       if(sd_writeBuf(bsect)) return 1;
000196 d9da      	RCALL SUBOPT_0x20
000197 f011      	BREQ _0x2001A
000198 e0e1      	LDI  R30,LOW(1)
000199 c003      	RJMP _0x202001B
                 ; 0001 00D2     }
                 _0x2001A:
                 ; 0001 00D3   }
                 _0x20017:
                 ; 0001 00D4   fs_type = FS_FAT32;
                 _0x20015:
00019a e0e1      	LDI  R30,LOW(1)
00019b 2e5e      	MOV  R5,R30
                 ; 0001 00D5 
                 ; 0001 00D6   return 0;
                 _0x202001C:
00019c e0e0      	LDI  R30,LOW(0)
                 _0x202001B:
00019d 962c      	ADIW R28,12
00019e 9508      	RET
                 ; 0001 00D7 }
                 ;
                 ;/**************************************************************************
                 ;*  Проверка наличия диска и если нужно, то его инициализация              *
                 ;**************************************************************************/
                 ;
                 ;BYTE fs_check() {
                 ; 0001 00DD BYTE fs_check() {
                 _fs_check:
                 ; 0001 00DE   if(!sd_check()) return 0;
00019f d59d      	RCALL _sd_check
0001a0 30e0      	CPI  R30,0
0001a1 f409      	BRNE _0x2001B
0001a2 c54e      	RJMP _0x2020011
                 ; 0001 00DF   return fs_init();
                 _0x2001B:
0001a3 ded3      	RCALL _fs_init
0001a4 9508      	RET
                 ; 0001 00E0 }
                 ;
                 ;/**************************************************************************
                 ;*  Получить кластер из FS_DIRENTRY                                        *
                 ;*  Функция не портит buf (функции, в которых этого не написано, портят)   *
                 ;**************************************************************************/
                 ;
                 ;static DWORD fs_getEntryCluster() {
                 ; 0001 00E7 static DWORD fs_getEntryCluster() {
                 _fs_getEntryCluster_G001:
                 ; 0001 00E8   DWORD c = LD_WORD(FS_DIRENTRY + DIR_FstClusLO);
                 ; 0001 00E9   if(fs_type != FS_FAT16) c |= ((DWORD)LD_WORD(FS_DIRENTRY + DIR_FstClusHI)) << 16;
0001a5 9724      	SBIW R28,4
                 ;	c -> Y+0
                +
0001a6 91e0 037a+LDS R30 , _buf + ( 506 )
0001a8 91f0 037b+LDS R31 , _buf + ( 506 ) + 1
                 	__GETW1MN _buf,506
0001aa d976      	RCALL SUBOPT_0xF
0001ab 2055      	TST  R5
0001ac f049      	BREQ _0x2001C
                +
0001ad 91e0 0374+LDS R30 , _buf + ( 500 )
0001af 91f0 0375+LDS R31 , _buf + ( 500 ) + 1
                 	__GETW1MN _buf,500
0001b1 d962      	RCALL SUBOPT_0xC
0001b2 dc8a      	RCALL __LSLD16
0001b3 d98f      	RCALL SUBOPT_0x18
0001b4 dc4b      	RCALL __ORD12
0001b5 d970      	RCALL SUBOPT_0x11
                 ; 0001 00EA   return c;
                 _0x2001C:
0001b6 d96d      	RCALL SUBOPT_0x10
                 _0x202001A:
0001b7 9624      	ADIW R28,4
0001b8 9508      	RET
                 ; 0001 00EB }
                 ;
                 ;/**************************************************************************
                 ;*  Получить следующий кластер.                                            *
                 ;*  Аргумент и результат находятся в fs_tmp.                               *
                 ;**************************************************************************/
                 ;
                 ;static BYTE fs_nextCluster() {
                 ; 0001 00F2 static BYTE fs_nextCluster() {
                 _fs_nextCluster_G001:
                 ; 0001 00F3   if(fs_type == FS_FAT16) {
0001b9 2055      	TST  R5
0001ba f489      	BRNE _0x2001D
                 ; 0001 00F4     if(sd_read((BYTE*)&fs_tmp, fs_fatbase + fs_tmp / 256, (WORD)(BYTE)fs_tmp * 2, 2)) goto abort;
0001bb d9ba      	RCALL SUBOPT_0x21
0001bc d9c5      	RCALL SUBOPT_0x22
0001bd d9ca      	RCALL SUBOPT_0x23
0001be e0e2      	LDI  R30,LOW(2)
0001bf 9fea      	MUL  R30,R26
0001c0 921a      	ST   -Y,R1
0001c1 920a      	ST   -Y,R0
0001c2 d9d2      	RCALL SUBOPT_0x24
0001c3 d927      	RCALL SUBOPT_0x3
0001c4 30e0      	CPI  R30,0
0001c5 f519      	BRNE _0x2001F
                 ; 0001 00F5     fs_tmp &= 0xFFFF;
0001c6 d9d1      	RCALL SUBOPT_0x25
                +
0001c7 7fef     +ANDI R30 , LOW ( 0xFFFF )
0001c8 7fff     +ANDI R31 , HIGH ( 0xFFFF )
0001c9 7060     +ANDI R22 , BYTE3 ( 0xFFFF )
0001ca 7070     +ANDI R23 , BYTE4 ( 0xFFFF )
                 	__ANDD1N 0xFFFF
0001cb c00e      	RJMP _0x2010A
                 ; 0001 00F6   } else {
                 _0x2001D:
                 ; 0001 00F7     if(sd_read((BYTE*)&fs_tmp, fs_fatbase + fs_tmp / 128, (WORD)((BYTE)fs_tmp % 128) * 4, 4)) goto abort;
0001cc d9a9      	RCALL SUBOPT_0x21
0001cd d9d3      	RCALL SUBOPT_0x26
0001ce d9b9      	RCALL SUBOPT_0x23
0001cf d9d7      	RCALL SUBOPT_0x27
0001d0 dc54      	RCALL __LSLW2
0001d1 d9da      	RCALL SUBOPT_0x28
0001d2 d918      	RCALL SUBOPT_0x3
0001d3 30e0      	CPI  R30,0
0001d4 f4a1      	BRNE _0x2001F
                 ; 0001 00F8     fs_tmp &= 0x0FFFFFFF;
0001d5 d9c2      	RCALL SUBOPT_0x25
                +
0001d6 7fef     +ANDI R30 , LOW ( 0xFFFFFFF )
0001d7 7fff     +ANDI R31 , HIGH ( 0xFFFFFFF )
0001d8 7f6f     +ANDI R22 , BYTE3 ( 0xFFFFFFF )
0001d9 707f     +ANDI R23 , BYTE4 ( 0xFFFFFFF )
                 	__ANDD1N 0xFFFFFFF
                 _0x2010A:
0001da 93e0 0380 	STS  _fs_tmp,R30
0001dc 93f0 0381 	STS  _fs_tmp+1,R31
0001de 9360 0382 	STS  _fs_tmp+2,R22
0001e0 9370 0383 	STS  _fs_tmp+3,R23
                 ; 0001 00F9   }
                 ; 0001 00FA   /* Для удобства разработки заменяем последний кластер на ноль. */
                 ; 0001 00FB   if(fs_tmp < 2 || fs_tmp >= fs_n_fatent)
0001e2 d9cd      	RCALL SUBOPT_0x29
0001e3 d9d5      	RCALL SUBOPT_0x2A
0001e4 f010      	BRLO _0x20023
0001e5 d9db      	RCALL SUBOPT_0x2B
0001e6 f008      	BRLO _0x20022
                 _0x20023:
                 ; 0001 00FC     fs_tmp = 0;
0001e7 d9e4      	RCALL SUBOPT_0x2C
                 ; 0001 00FD   return 0;
                 _0x20022:
0001e8 c508      	RJMP _0x2020011
                 ; 0001 00FE abort:
                 _0x2001F:
                 ; 0001 00FF   return 1;
0001e9 c4fc      	RJMP _0x2020014
                 ; 0001 0100 }
                 ;
                 ;/**************************************************************************
                 ;*  Преобразовать номер кластера в номер сектора                           *
                 ;*  Аргумент и результат находятся в fs_tmp.                               *
                 ;*  Функция не портит buf                                                  *
                 ;***************************************************************************/
                 ;
                 ;static void fs_clust2sect() {
                 ; 0001 0108 static void fs_clust2sect() {
                 _fs_clust2sect_G001:
                 ; 0001 0109   fs_tmp = (fs_tmp - 2) * fs_csize + fs_database;
0001ea d9ad      	RCALL SUBOPT_0x25
                +
0001eb 50e2     +SUBI R30 , LOW ( 2 )
0001ec 40f0     +SBCI R31 , HIGH ( 2 )
0001ed 4060     +SBCI R22 , BYTE3 ( 2 )
0001ee 4070     +SBCI R23 , BYTE4 ( 2 )
                 	__SUBD1N 2
0001ef d9e6      	RCALL SUBOPT_0x2D
0001f0 dc56      	RCALL __MULD12U
0001f1 d9e6      	RCALL SUBOPT_0x2E
0001f2 dbf9      	RCALL __ADDD12
0001f3 d9ed      	RCALL SUBOPT_0x2F
                 ; 0001 010A }
0001f4 9508      	RET
                 ;
                 ;/**************************************************************************
                 ;*  Получить очередной файл или папку                                      *
                 ;*  Удаленные файлы, метки тома, последний элемент, LFN показываются       *
                 ;*                                                                         *
                 ;*  Описание работы полностью идентично функции ниже, поэтому здесь не     *
                 ;*  приведено                                                              *
                 ;*                                                                         *
                 ;*  Функция не портит buf[0..MAX_FILENAME-1]                               *
                 ;***************************************************************************/
                 ;
                 ;static BYTE fs_readdirInt() {
                 ; 0001 0116 static BYTE fs_readdirInt() {
                 _fs_readdirInt_G001:
                 ; 0001 0117   if(fs_file.entry_able) {
0001f5 d9f4      	RCALL SUBOPT_0x30
0001f6 f199      	BREQ _0x20025
                 ; 0001 0118     fs_file.entry_index++;
                +
0001f7 eaa1     +LDI R26 , LOW ( _fs_file + ( 2 ) )
0001f8 e0b3     +LDI R27 , HIGH ( _fs_file + ( 2 ) )
                 	__POINTW2MN _fs_file,2
0001f9 91ed      	LD   R30,X+
0001fa 91fd      	LD   R31,X+
0001fb 9631      	ADIW R30,1
0001fc 93fe      	ST   -X,R31
0001fd 93ee      	ST   -X,R30
                 ; 0001 0119 
                 ; 0001 011A     /* В папке не может быть больше 65536 файлов, а в корне FAT16 не больше  fs_n_rootdir */
                 ; 0001 011B     if(fs_file.entry_index == 0 || (fs_file.entry_cluster == 0 && fs_file.entry_index == fs_n_rootdir)) {
0001fe d9ef      	RCALL SUBOPT_0x31
0001ff 9710      	SBIW R26,0
000200 f039      	BREQ _0x20027
000201 d9f1      	RCALL SUBOPT_0x32
000202 f421      	BRNE _0x20028
000203 d9ea      	RCALL SUBOPT_0x31
000204 166a      	CP   R6,R26
000205 067b      	CPC  R7,R27
000206 f009      	BREQ _0x20027
                 _0x20028:
000207 c006      	RJMP _0x20026
                 _0x20027:
                 ; 0001 011C       fs_file.entry_index = 0;
000208 d9f4      	RCALL SUBOPT_0x33
                 ; 0001 011D retEnd:
                 _0x2002B:
                 ; 0001 011E       FS_DIRENTRY[DIR_Name] = 0; /* Признак последнего файла для пользователя вызывающего fs_dirread */
000209 e0e0      	LDI  R30,LOW(0)
                +
00020a 93e0 0360+STS _buf + ( 480 ) , R30
                 	__PUTB1MN _buf,480
                 ; 0001 011F       fs_file.entry_able = 0;
00020c d9f6      	RCALL SUBOPT_0x34
                 ; 0001 0120       return 0;
00020d c4e3      	RJMP _0x2020011
                 ; 0001 0121     }
                 ; 0001 0122 
                 ; 0001 0123     /* Граница сектора */
                 ; 0001 0124     if(fs_file.entry_index % 16 == 0) {
                 _0x20026:
00020e d9f8      	RCALL SUBOPT_0x35
00020f 70ef      	ANDI R30,LOW(0xF)
000210 f4c1      	BRNE _0x2002C
                 ; 0001 0125       fs_file.entry_sector++;
                +
000211 eaa7     +LDI R26 , LOW ( _fs_file + ( 8 ) )
000212 e0b3     +LDI R27 , HIGH ( _fs_file + ( 8 ) )
                 	__POINTW2MN _fs_file,8
000213 d9f8      	RCALL SUBOPT_0x36
                 ; 0001 0126 
                 ; 0001 0127       /* Граница кластера */
                 ; 0001 0128       if(fs_file.entry_cluster != 0 && ((fs_file.entry_index / 16) % fs_csize) == 0) {
000214 d9de      	RCALL SUBOPT_0x32
000215 f041      	BREQ _0x2002E
000216 d9f0      	RCALL SUBOPT_0x35
000217 dc12      	RCALL __LSRW4
000218 01df      	MOVW R26,R30
000219 2de4      	MOV  R30,R4
00021a d91f      	RCALL SUBOPT_0x15
00021b dc83      	RCALL __MODW21U
00021c 9730      	SBIW R30,0
00021d f009      	BREQ _0x2002F
                 _0x2002E:
00021e c00a      	RJMP _0x2002D
                 _0x2002F:
                 ; 0001 0129 
                 ; 0001 012A         /* Следующий кластер */
                 ; 0001 012B         fs_tmp = fs_file.entry_cluster;
00021f d9f0      	RCALL SUBOPT_0x37
000220 d9c0      	RCALL SUBOPT_0x2F
                 ; 0001 012C         if(fs_nextCluster()) return 1;
000221 df97      	RCALL _fs_nextCluster_G001
000222 30e0      	CPI  R30,0
000223 f009      	BREQ _0x20030
000224 c4c1      	RJMP _0x2020014
                 ; 0001 012D         if(fs_tmp == 0) goto retEnd; /* Последний кластер, устаналиваем fs_file.entry_able = 0 */
                 _0x20030:
000225 d972      	RCALL SUBOPT_0x25
000226 dccc      	RCALL __CPD10
000227 f309      	BREQ _0x2002B
                 ; 0001 012E 
                 ; 0001 012F         /* Сохраняем */
                 ; 0001 0130         fs_file.entry_cluster = fs_tmp;
000228 d9f0      	RCALL SUBOPT_0x38
                 ; 0001 0131         fs_clust2sect();
                 ; 0001 0132         fs_file.entry_sector = fs_tmp;
                 ; 0001 0133       }
                 ; 0001 0134     }
                 _0x2002D:
                 ; 0001 0135   } else {
                 _0x2002C:
000229 c013      	RJMP _0x20032
                 _0x20025:
                 ; 0001 0136     fs_file.entry_index = 0;
00022a d9d2      	RCALL SUBOPT_0x33
                 ; 0001 0137     fs_file.entry_able  = 1;
00022b e0e1      	LDI  R30,LOW(1)
                +
00022c 93e0 03a0+STS _fs_file + ( 1 ) , R30
                 	__PUTB1MN _fs_file,1
                 ; 0001 0138     fs_tmp = fs_file.entry_start_cluster;
00022e d9fe      	RCALL SUBOPT_0x39
00022f d9b1      	RCALL SUBOPT_0x2F
                 ; 0001 0139 
                 ; 0001 013A     /* Первый кластер и сектор папки. Этот код не имеет смысла выполнять
                 ; 0001 013B     для FAT16, но зато код хорошо сжимается. Т.к. этот кусок кода аналогичен
                 ; 0001 013C     куску выше. */
                 ; 0001 013D     fs_file.entry_cluster = fs_tmp;
000230 d9e8      	RCALL SUBOPT_0x38
                 ; 0001 013E     fs_clust2sect();
                 ; 0001 013F     fs_file.entry_sector = fs_tmp;
                 ; 0001 0140 
                 ; 0001 0141     /* Корневая папка FS_FAT16 */
                 ; 0001 0142     if(fs_file.entry_cluster == 0) fs_file.entry_sector = fs_dirbase;
000231 d9de      	RCALL SUBOPT_0x37
000232 dcc0      	RCALL __CPD10
000233 f449      	BRNE _0x20033
000234 da01      	RCALL SUBOPT_0x3A
                +
000235 93e0 03a7+STS _fs_file + ( 8 ) , R30
000237 93f0 03a8+STS _fs_file + ( 8 ) + 1 , R31
000239 9360 03a9+STS _fs_file + ( 8 ) + 2 , R22
00023b 9370 03aa+STS _fs_file + ( 8 ) + 3 , R23
                 	__PUTD1MN _fs_file,8
                 ; 0001 0143   }
                 _0x20033:
                 _0x20032:
                 ; 0001 0144 
                 ; 0001 0145   return sd_read(FS_DIRENTRY, fs_file.entry_sector, (WORD)((fs_file.entry_index % 16) * 32), 32);
00023d da01      	RCALL SUBOPT_0x3B
00023e da03      	RCALL SUBOPT_0x3C
00023f dca1      	RCALL __PUTPARD1
000240 d9c6      	RCALL SUBOPT_0x35
000241 da09      	RCALL SUBOPT_0x3D
000242 d8a5      	RCALL SUBOPT_0x2
000243 e2e0      	LDI  R30,LOW(32)
000244 e0f0      	LDI  R31,HIGH(32)
000245 d8a5      	RCALL SUBOPT_0x3
000246 9508      	RET
                 ; 0001 0146 }
                 ;
                 ;/**************************************************************************
                 ;*  Получить очередной файл или папку (удаленные файлы пропускаются)       *
                 ;*                                                                         *
                 ;*  Эта функция вызывается после fs_opendir, которая настраивает все       *
                 ;*  нужные переменные, поэтому вам ничего трогать не надо. Информация      *
                 ;*  ниже приведена для лучшего понимания работы                            *
                 ;*                                                                         *
                 ;*  Если на входе entry_able=0,  то начинается новый поиск в папке         *
                 ;*  по адресу entry_start_cluster. При этом инициализируются переменные:   *
                 ;*  entry_able, entry_index, entry_sector, entry_cluster.                  *
                 ;*                                                                         *
                 ;*  Если на входе fs_file.entry_able=1, то используются эти 4 переменные.  *
                 ;*                                                                         *
                 ;*  На выходе                                                              *
                 ;*    entry_able     - если 0 значит достигнут конец каталога              *
                 ;*    entry_sector   - сектор описателя                                    *
                 ;*    entry_cluster  - кластер описателя                                   *
                 ;*    entry_index    - номер описателя                                     *
                 ;*    FS_DIRENTRY    - описатель                                           *
                 ;*                                                                         *
                 ;*  Функция не портит buf[0..MAX_FILENAME-1]                               *
                 ;**************************************************************************/
                 ;
                 ;BYTE fs_readdir_nocheck() {
                 ; 0001 015F BYTE fs_readdir_nocheck() {
                 _fs_readdir_nocheck:
                 ; 0001 0160   while(!fs_readdirInt()) {
                 _0x20034:
000247 dfad      	RCALL _fs_readdirInt_G001
000248 30e0      	CPI  R30,0
000249 f489      	BRNE _0x20036
                 ; 0001 0161     if(FS_DIRENTRY[DIR_Name] == 0) fs_file.entry_able = 0;
00024a da05      	RCALL SUBOPT_0x3E
00024b f409      	BRNE _0x20037
00024c d9b6      	RCALL SUBOPT_0x34
                 ; 0001 0162     if(fs_file.entry_able == 0) return 0;
                 _0x20037:
00024d d99c      	RCALL SUBOPT_0x30
00024e f409      	BRNE _0x20038
00024f c4a1      	RJMP _0x2020011
                 ; 0001 0163     if(FS_DIRENTRY[DIR_Name] == 0xE5) continue; /*  Может быть еще 0x05 */
                 _0x20038:
000250 da03      	RCALL SUBOPT_0x3F
000251 3ea5      	CPI  R26,LOW(0xE5)
000252 f3a1      	BREQ _0x20034
                 ; 0001 0164     if(FS_DIRENTRY[DIR_Name] == '.') continue;
000253 da00      	RCALL SUBOPT_0x3F
000254 32ae      	CPI  R26,LOW(0x2E)
000255 f389      	BREQ _0x20034
                 ; 0001 0165     if((FS_DIRENTRY[DIR_Attr] & AM_VOL) == 0) return 0;
000256 da00      	RCALL SUBOPT_0x40
000257 70e8      	ANDI R30,LOW(0x8)
000258 f409      	BRNE _0x2003B
000259 c497      	RJMP _0x2020011
                 ; 0001 0166   }
                 _0x2003B:
00025a cfec      	RJMP _0x20034
                 _0x20036:
                 ; 0001 0167   return 1;
00025b c48a      	RJMP _0x2020014
                 ; 0001 0168 }
                 ;
                 ;BYTE fs_readdir() {
                 ; 0001 016A BYTE fs_readdir() {
                 _fs_readdir:
                 ; 0001 016B #ifndef FS_DISABLE_CHECK
                 ; 0001 016C   /* Папка должна быть открыта */
                 ; 0001 016D   if(fs_file.opened != OPENED_DIR) { lastError = ERR_NOT_OPENED; return 1; }
00025c d9fd      	RCALL SUBOPT_0x41
00025d 30a2      	CPI  R26,LOW(0x2)
00025e f009      	BREQ _0x2003C
00025f c483      	RJMP _0x2020012
                 ; 0001 016E #endif
                 ; 0001 016F   return fs_readdir_nocheck();
                 _0x2003C:
000260 dfe6      	RCALL _fs_readdir_nocheck
000261 9508      	RET
                 ; 0001 0170 }
                 ;
                 ;/**************************************************************************
                 ;*  Сохранить изменения в обе таблицы FAT                                  *
                 ;**************************************************************************/
                 ;
                 ;static BYTE fs_saveFatSector(DWORD sector) {
                 ; 0001 0176 static BYTE fs_saveFatSector(DWORD sector) {
                 _fs_saveFatSector_G001:
                 ; 0001 0177   if(fs_fatbase2) if(sd_writeBuf(fs_fatbase2+sector)) return 1;
                 ;	sector -> Y+0
000262 91e0 038b 	LDS  R30,_fs_fatbase2
000264 91f0 038c 	LDS  R31,_fs_fatbase2+1
000266 9160 038d 	LDS  R22,_fs_fatbase2+2
000268 9170 038e 	LDS  R23,_fs_fatbase2+3
00026a dc88      	RCALL __CPD10
00026b f071      	BREQ _0x2003D
00026c d8b7      	RCALL SUBOPT_0x10
00026d 91a0 038b 	LDS  R26,_fs_fatbase2
00026f 91b0 038c 	LDS  R27,_fs_fatbase2+1
000271 9180 038d 	LDS  R24,_fs_fatbase2+2
000273 9190 038e 	LDS  R25,_fs_fatbase2+3
000275 d9e7      	RCALL SUBOPT_0x42
000276 30e0      	CPI  R30,0
000277 f011      	BREQ _0x2003E
000278 e0e1      	LDI  R30,LOW(1)
000279 c73b      	RJMP _0x2020004
                 ; 0001 0178   return sd_writeBuf(fs_fatbase+sector);
                 _0x2003E:
                 _0x2003D:
00027a d8a9      	RCALL SUBOPT_0x10
00027b d9e4      	RCALL SUBOPT_0x43
00027c d9e0      	RCALL SUBOPT_0x42
00027d c737      	RJMP _0x2020004
                 ; 0001 0179 }
                 ;
                 ;/**************************************************************************
                 ;*  Выделить кластер                                                       *
                 ;*                                                                         *
                 ;*  Найденный кластер сохраняется в fs_tmp                                 *
                 ;**************************************************************************/
                 ;
                 ;/* Ради функции fs_getfree пришлось усложнить функцию fs_allocCluster.
                 ;Если функция не используется, то можно с помощью макроса FS_DISABLE_GETFREESPACE
                 ;исключить лишний код */
                 ;
                 ;#ifdef FS_DISABLE_GETFREESPACE
                 ;#define DIS(X)
                 ;#define ALLOCCLUSTER
                 ;#else
                 ;#define DIS(X) X
                 ;#define ALLOCCLUSTER 0
                 ;#endif
                 ;
                 ;static BYTE fs_allocCluster(DIS(BYTE freeSpace)) {
                 ; 0001 018D static BYTE fs_allocCluster(BYTE freeSpace) {
                 _fs_allocCluster_G001:
                 ; 0001 018E   BYTE i;
                 ; 0001 018F   DWORD s;
                 ; 0001 0190   BYTE *a;
                 ; 0001 0191 
                 ; 0001 0192   /* Начинаем поиск с этого кластера */
                 ; 0001 0193   fs_tmp = fs_fatoptim;
00027e 9724      	SBIW R28,4
00027f dc8d      	RCALL __SAVELOCR4
                 ;	freeSpace -> Y+8
                 ;	i -> R17
                 ;	s -> Y+4
                 ;	*a -> R18,R19
000280 d9e8      	RCALL SUBOPT_0x44
000281 d95f      	RCALL SUBOPT_0x2F
                 ; 0001 0194 
                 ; 0001 0195   /* Последовательно перебираем сектора */
                 ; 0001 0196   while(1) {
                 _0x2003F:
                 ; 0001 0197     /* Сектор и смещение */
                 ; 0001 0198     s = fs_tmp / 256, i = (BYTE)fs_tmp, a = (BYTE*)((WORD*)buf + i);
000282 d92d      	RCALL SUBOPT_0x29
000283 d8fe      	RCALL SUBOPT_0x22
000284 d892      	RCALL SUBOPT_0xD
000285 9110 0380 	LDS  R17,_fs_tmp
000287 d9ea      	RCALL SUBOPT_0x45
000288 d9eb      	RCALL SUBOPT_0x46
000289 019f      	MOVW R18,R30
                 ; 0001 0199     if(fs_type != FS_FAT16) s = fs_tmp / 128, i |= 128, a = (BYTE*)((DWORD*)buf - 128 + i);
00028a 2055      	TST  R5
00028b f061      	BREQ _0x20042
00028c d923      	RCALL SUBOPT_0x29
00028d d913      	RCALL SUBOPT_0x26
00028e d888      	RCALL SUBOPT_0xD
00028f 6810      	ORI  R17,LOW(128)
000290 d9ea      	RCALL SUBOPT_0x47
000291 50e0      	SUBI R30,LOW(512)
000292 40f2      	SBCI R31,HIGH(512)
000293 01df      	MOVW R26,R30
000294 d9dd      	RCALL SUBOPT_0x45
000295 db8f      	RCALL __LSLW2
000296 d9e7      	RCALL SUBOPT_0x48
000297 019f      	MOVW R18,R30
                 ; 0001 019A 
                 ; 0001 019B     /* Читаем сектор */
                 ; 0001 019C     if(sd_readBuf(fs_fatbase + s)) goto abort;
                 _0x20042:
000298 d897      	RCALL SUBOPT_0x14
000299 db52      	RCALL __ADDD12
00029a d868      	RCALL SUBOPT_0x8
00029b f5b9      	BRNE _0x20044
                 ; 0001 019D 
                 ; 0001 019E     /* Среди 128/256 чисел в секторе ищем 0 */
                 ; 0001 019F     /* Куча проверок внутри цикла не самое быстрое решение, но зато получается очень компактный код. */
                 ; 0001 01A0     do {
                 _0x20046:
                 ; 0001 01A1       /* Кластеры кончились */
                 ; 0001 01A2       if(fs_tmp >= fs_n_fatent) { DIS(if(freeSpace) return 0;) lastError = ERR_NO_FREE_SPACE; goto abort; }
00029c d924      	RCALL SUBOPT_0x2B
00029d f040      	BRLO _0x20048
00029e d9e2      	RCALL SUBOPT_0x49
00029f f019      	BREQ _0x20049
0002a0 e0e0      	LDI  R30,LOW(0)
0002a1 dc72      	RCALL __LOADLOCR4
0002a2 c614      	RJMP _0x202000A
                 _0x20049:
0002a3 e0e6      	LDI  R30,LOW(6)
0002a4 d86c      	RCALL SUBOPT_0xB
0002a5 c02d      	RJMP _0x20044
                 ; 0001 01A3 
                 ; 0001 01A4       /* Ищем свободный кластер и помечаем как последний */
                 ; 0001 01A5       if(fs_type == FS_FAT16) {
                 _0x20048:
0002a6 2055      	TST  R5
0002a7 f481      	BRNE _0x2004A
                 ; 0001 01A6         if(LD_WORD(a) == 0) { DIS(if(!freeSpace) {) LD_WORD(a) = (WORD)LAST_CLUSTER; goto founded; DIS(} fs_file.sector++;) }
0002a8 01d9      	MOVW R26,R18
0002a9 dc0a      	RCALL __GETW1P
0002aa 9730      	SBIW R30,0
0002ab f449      	BRNE _0x2004B
0002ac d9d4      	RCALL SUBOPT_0x49
0002ad f431      	BRNE _0x2004C
0002ae 01d9      	MOVW R26,R18
0002af efef      	LDI  R30,LOW(65535)
0002b0 efff      	LDI  R31,HIGH(65535)
0002b1 93ed      	ST   X+,R30
0002b2 93fc      	ST   X,R31
0002b3 c018      	RJMP _0x2004D
                 _0x2004C:
0002b4 d9cf      	RCALL SUBOPT_0x4A
                 ; 0001 01A7         a += 2;
                 _0x2004B:
                +
0002b5 5f2e     +SUBI R18 , LOW ( - 2 )
0002b6 4f3f     +SBCI R19 , HIGH ( - 2 )
                 	__ADDWRN 18,19,2
                 ; 0001 01A8       } else {
0002b7 c00d      	RJMP _0x2004E
                 _0x2004A:
                 ; 0001 01A9         if(LD_DWORD(a) == 0) { DIS(if(!freeSpace) {) LD_DWORD(a) = LAST_CLUSTER; goto founded; DIS(} fs_file.sector++;) }
0002b8 01d9      	MOVW R26,R18
0002b9 dbfe      	RCALL __GETD1P
0002ba dc38      	RCALL __CPD10
0002bb f439      	BRNE _0x2004F
0002bc d9c4      	RCALL SUBOPT_0x49
0002bd f421      	BRNE _0x20050
0002be 01d9      	MOVW R26,R18
0002bf d9c7      	RCALL SUBOPT_0x4B
0002c0 dc02      	RCALL __PUTDP1
0002c1 c00a      	RJMP _0x2004D
                 _0x20050:
0002c2 d9c1      	RCALL SUBOPT_0x4A
                 ; 0001 01AA         a += 4;
                 _0x2004F:
                +
0002c3 5f2c     +SUBI R18 , LOW ( - 4 )
0002c4 4f3f     +SBCI R19 , HIGH ( - 4 )
                 	__ADDWRN 18,19,4
                 ; 0001 01AB       }
                 _0x2004E:
                 ; 0001 01AC 
                 ; 0001 01AD       /* Счетчик */
                 ; 0001 01AE       ++fs_tmp, ++i;
0002c5 e8a0      	LDI  R26,LOW(_fs_tmp)
0002c6 e0b3      	LDI  R27,HIGH(_fs_tmp)
0002c7 d944      	RCALL SUBOPT_0x36
0002c8 5f1f      	SUBI R17,-LOW(1)
                 ; 0001 01AF     } while(i != 0);
0002c9 3010      	CPI  R17,0
0002ca f689      	BRNE _0x20046
                 ; 0001 01B0   }
0002cb cfb6      	RJMP _0x2003F
                 ; 0001 01B1 founded:
                 _0x2004D:
                 ; 0001 01B2   /* Оптимизация */
                 ; 0001 01B3   fs_fatoptim = fs_tmp;
0002cc d8cb      	RCALL SUBOPT_0x25
0002cd d81f      	RCALL SUBOPT_0x4
                 ; 0001 01B4 
                 ; 0001 01B5   /* Сохраняем изменения */
                 ; 0001 01B6   return fs_saveFatSector(s);
0002ce d84d      	RCALL SUBOPT_0xE
0002cf dc11      	RCALL __PUTPARD1
0002d0 df91      	RCALL _fs_saveFatSector_G001
0002d1 dc42      	RCALL __LOADLOCR4
0002d2 c5e4      	RJMP _0x202000A
                 ; 0001 01B7 abort:
                 _0x20044:
                 ; 0001 01B8   return 1;
0002d3 e0e1      	LDI  R30,LOW(1)
0002d4 dc3f      	RCALL __LOADLOCR4
0002d5 c5e1      	RJMP _0x202000A
                 ; 0001 01B9 }
                 ;
                 ;#undef DIS
                 ;
                 ;/**************************************************************************
                 ;*  Изменение таблицы FAT                                                  *
                 ;*                                                                         *
                 ;*  Если fs_tmp!=0, то FAT[cluster] = fs_tmp                               *
                 ;*  Если fs_tmp==0, то swap(FAT[cluster], fs_tmp)                          *
                 ;**************************************************************************/
                 ;
                 ;static BYTE fs_setNextCluster(DWORD cluster) {
                 ; 0001 01C4 static BYTE fs_setNextCluster(DWORD cluster) {
                 _fs_setNextCluster_G001:
                 ; 0001 01C5   DWORD s, prev;
                 ; 0001 01C6   void* a;
                 ; 0001 01C7 
                 ; 0001 01C8   /* Вычисляем сектор */
                 ; 0001 01C9   s = cluster / 128;
0002d6 9728      	SBIW R28,8
0002d7 dc37      	RCALL __SAVELOCR2
                 ;	cluster -> Y+10
                 ;	s -> Y+6
                 ;	prev -> Y+2
                 ;	*a -> R16,R17
0002d8 d9b3      	RCALL SUBOPT_0x4C
0002d9 d8c7      	RCALL SUBOPT_0x26
0002da d9b6      	RCALL SUBOPT_0x4D
                 ; 0001 01CA   if(fs_type == FS_FAT16) s = cluster / 256;
0002db 2055      	TST  R5
0002dc f419      	BRNE _0x20051
0002dd d9ae      	RCALL SUBOPT_0x4C
0002de d8a3      	RCALL SUBOPT_0x22
0002df d9b1      	RCALL SUBOPT_0x4D
                 ; 0001 01CB 
                 ; 0001 01CC   /* Читаем сектор */
                 ; 0001 01CD   if(sd_readBuf(fs_fatbase + s)) return 1;
                 _0x20051:
0002e0 d9b5      	RCALL SUBOPT_0x4E
0002e1 d97e      	RCALL SUBOPT_0x43
0002e2 db09      	RCALL __ADDD12
0002e3 d81f      	RCALL SUBOPT_0x8
0002e4 f011      	BREQ _0x20052
0002e5 d9b5      	RCALL SUBOPT_0x4F
0002e6 c4ed      	RJMP _0x202000E
                 ; 0001 01CE 
                 ; 0001 01CF   /* Изменяем отдельный кластер */
                 ; 0001 01D0   if(fs_type == FS_FAT16) {
                 _0x20052:
0002e7 2055      	TST  R5
0002e8 f469      	BRNE _0x20053
                 ; 0001 01D1     a = (WORD*)buf + (BYTE)cluster;
0002e9 85ea      	LDD  R30,Y+10
0002ea d84f      	RCALL SUBOPT_0x15
0002eb d988      	RCALL SUBOPT_0x46
0002ec 018f      	MOVW R16,R30
                 ; 0001 01D2     prev = LD_WORD(a);
0002ed 01d8      	MOVW R26,R16
0002ee dbc5      	RCALL __GETW1P
0002ef d824      	RCALL SUBOPT_0xC
0002f0 d9ad      	RCALL SUBOPT_0x50
                 ; 0001 01D3     LD_WORD(a) = (WORD)fs_tmp;
0002f1 d9b1      	RCALL SUBOPT_0x51
0002f2 01d8      	MOVW R26,R16
0002f3 93ed      	ST   X+,R30
0002f4 93fc      	ST   X,R31
                 ; 0001 01D4   } else {
0002f5 c00d      	RJMP _0x20054
                 _0x20053:
                 ; 0001 01D5     a = (DWORD*)buf + (BYTE)cluster % 128;
0002f6 85aa      	LDD  R26,Y+10
0002f7 d8af      	RCALL SUBOPT_0x27
0002f8 e8a0      	LDI  R26,LOW(_buf)
0002f9 e0b1      	LDI  R27,HIGH(_buf)
0002fa db2a      	RCALL __LSLW2
0002fb d982      	RCALL SUBOPT_0x48
0002fc 018f      	MOVW R16,R30
                 ; 0001 01D6     prev = LD_DWORD(a);
0002fd 01d8      	MOVW R26,R16
0002fe dbb9      	RCALL __GETD1P
0002ff d99e      	RCALL SUBOPT_0x50
                 ; 0001 01D7     LD_DWORD(a) = fs_tmp;
000300 d897      	RCALL SUBOPT_0x25
000301 01d8      	MOVW R26,R16
000302 dbc0      	RCALL __PUTDP1
                 ; 0001 01D8   }
                 _0x20054:
                 ; 0001 01D9 
                 ; 0001 01DA   /* Оптимизация поиска свободного кластера. Внезапно if() if() занимает меньше ПЗУ, чем && */
                 ; 0001 01DB   if(fs_tmp == FREE_CLUSTER) if(cluster < fs_fatoptim) fs_fatoptim = cluster;
000303 d894      	RCALL SUBOPT_0x25
000304 dbee      	RCALL __CPD10
000305 f449      	BRNE _0x20055
000306 d962      	RCALL SUBOPT_0x44
000307 d984      	RCALL SUBOPT_0x4C
000308 dbfd      	RCALL __CPD21
000309 f428      	BRSH _0x20056
                +
00030a 85ea     +LDD R30 , Y + 10
00030b 85fb     +LDD R31 , Y + 10 + 1
00030c 856c     +LDD R22 , Y + 10 + 2
00030d 857d     +LDD R23 , Y + 10 + 3
                 	__GETD1S 10
00030e d7de      	RCALL SUBOPT_0x4
                 ; 0001 01DC 
                 ; 0001 01DD   /* Результат */
                 ; 0001 01DE   if(fs_tmp == LAST_CLUSTER || fs_tmp == FREE_CLUSTER)
                 _0x20056:
                 _0x20055:
00030f d8a0      	RCALL SUBOPT_0x29
                +
000310 3faf     +CPI R26 , LOW ( 0xFFFFFFF )
000311 efef     +LDI R30 , HIGH ( 0xFFFFFFF )
000312 07be     +CPC R27 , R30
000313 efef     +LDI R30 , BYTE3 ( 0xFFFFFFF )
000314 078e     +CPC R24 , R30
000315 e0ef     +LDI R30 , BYTE4 ( 0xFFFFFFF )
000316 079e     +CPC R25 , R30
                 	__CPD2N 0xFFFFFFF
000317 f019      	BREQ _0x20058
000318 d897      	RCALL SUBOPT_0x29
000319 dbe1      	RCALL __CPD02
00031a f411      	BRNE _0x20057
                 _0x20058:
                 ; 0001 01DF     fs_tmp = prev;
00031b d98c      	RCALL SUBOPT_0x52
00031c d8c4      	RCALL SUBOPT_0x2F
                 ; 0001 01E0 
                 ; 0001 01E1   /* Сохраняем сектор */
                 ; 0001 01E2   return fs_saveFatSector(s);
                 _0x20057:
00031d d978      	RCALL SUBOPT_0x4E
00031e dbc2      	RCALL __PUTPARD1
00031f df42      	RCALL _fs_saveFatSector_G001
000320 dbf5      	RCALL __LOADLOCR2
000321 c4b2      	RJMP _0x202000E
                 ; 0001 01E3 }
                 ;
                 ;/**************************************************************************
                 ;*  Установить в описатель кластер                                         *
                 ;**************************************************************************/
                 ;
                 ;static void fs_setEntryCluster(BYTE* entry, DWORD cluster) {
                 ; 0001 01E9 static void fs_setEntryCluster(BYTE* entry, DWORD cluster) {
                 _fs_setEntryCluster_G001:
                 ; 0001 01EA   LD_WORD(entry + DIR_FstClusLO) = (WORD)(cluster);
                 ;	*entry -> Y+4
                 ;	cluster -> Y+0
000322 d98a      	RCALL SUBOPT_0x53
                +
000323 81ac     +LDD R26 , Y + 4
000324 81bd     +LDD R27 , Y + 4 + 1
000325 965a     +ADIW R26 , 26
000326 93ed     +ST X + , R30
000327 93fc     +ST X , R31
                 	__PUTW1SNS 4,26
                 ; 0001 01EB   LD_WORD(entry + DIR_FstClusHI) = (WORD)(cluster >> 16);
000328 d7fb      	RCALL SUBOPT_0x10
000329 db0e      	RCALL __LSRD16
                +
00032a 81ac     +LDD R26 , Y + 4
00032b 81bd     +LDD R27 , Y + 4 + 1
00032c 9654     +ADIW R26 , 20
00032d 93ed     +ST X + , R30
00032e 93fc     +ST X , R31
                 	__PUTW1SNS 4,20
                 ; 0001 01EC }
00032f c790      	RJMP _0x2020002
                 ;
                 ;/**************************************************************************
                 ;*  Очистить кластер и буфер                                               *
                 ;**************************************************************************/
                 ;
                 ;static BYTE fs_eraseCluster(BYTE i) {
                 ; 0001 01F2 static BYTE fs_eraseCluster(BYTE i) {
                 _fs_eraseCluster_G001:
                 ; 0001 01F3   memset(buf, 0, 512);
                 ;	i -> Y+0
000330 d97f      	RCALL SUBOPT_0x54
000331 d980      	RCALL SUBOPT_0x55
000332 e0e0      	LDI  R30,LOW(512)
000333 e0f2      	LDI  R31,HIGH(512)
000334 d980      	RCALL SUBOPT_0x56
                 ; 0001 01F4   for(; i < fs_csize; ++i)
                 _0x2005B:
000335 81a8      	LD   R26,Y
000336 15a4      	CP   R26,R4
000337 f468      	BRSH _0x2005C
                 ; 0001 01F5     if(sd_writeBuf(fs_tmp + i)) return 1;
000338 81e8      	LD   R30,Y
000339 d800      	RCALL SUBOPT_0x15
00033a d875      	RCALL SUBOPT_0x29
00033b d805      	RCALL SUBOPT_0x17
00033c d920      	RCALL SUBOPT_0x42
00033d 30e0      	CPI  R30,0
00033e f011      	BREQ _0x2005D
00033f e0e1      	LDI  R30,LOW(1)
000340 c3b6      	RJMP _0x202000F
                 ; 0001 01F6   return 0;
                 _0x2005D:
000341 81e8      	LD   R30,Y
000342 5fef      	SUBI R30,-LOW(1)
000343 83e8      	ST   Y,R30
000344 cff0      	RJMP _0x2005B
                 _0x2005C:
000345 e0e0      	LDI  R30,LOW(0)
000346 c3b0      	RJMP _0x202000F
                 ; 0001 01F7 }
                 ;
                 ;/**************************************************************************
                 ;*  Выделить описатель в каталоге                                          *
                 ;*                                                                         *
                 ;*  entry_able должно быть равно 0                                         *
                 ;*  entry_start_cluster должен содержать первый кластер папки              *
                 ;**************************************************************************/
                 ;
                 ;static BYTE* fs_allocEntry() {
                 ; 0001 0200 static BYTE* fs_allocEntry() {
                 _fs_allocEntry_G001:
                 ; 0001 0201   /* Ищем в папке пустой описатель. */
                 ; 0001 0202   while(1) {
                 _0x2005E:
                 ; 0001 0203     if(fs_readdirInt()) return 0;
000347 dead      	RCALL _fs_readdirInt_G001
000348 30e0      	CPI  R30,0
000349 f4e9      	BRNE _0x2020019
                 ; 0001 0204 
                 ; 0001 0205     /* Кластеры кончились */
                 ; 0001 0206     if(!fs_file.entry_able) break;
00034a d89f      	RCALL SUBOPT_0x30
00034b f071      	BREQ _0x20060
                 ; 0001 0207 
                 ; 0001 0208     /* Это свободный описатель */
                 ; 0001 0209     if(FS_DIRENTRY[0] == 0xE5 || FS_DIRENTRY[0] == 0) { /* Может быть еще 0x05 */
00034c d907      	RCALL SUBOPT_0x3F
00034d 3ea5      	CPI  R26,LOW(0xE5)
00034e f019      	BREQ _0x20064
00034f d904      	RCALL SUBOPT_0x3F
000350 30a0      	CPI  R26,LOW(0x0)
000351 f439      	BRNE _0x20063
                 _0x20064:
                 ; 0001 020A 
                 ; 0001 020B       /* Читаем сектор */
                 ; 0001 020C       if(sd_readBuf(fs_file.entry_sector)) return 0;
000352 d8ef      	RCALL SUBOPT_0x3C
000353 d7af      	RCALL SUBOPT_0x8
000354 f491      	BRNE _0x2020019
                 ; 0001 020D 
                 ; 0001 020E       /* Найденный описатель */
                 ; 0001 020F       return buf + (fs_file.entry_index % 16) * 32;
000355 d8b1      	RCALL SUBOPT_0x35
000356 d8f4      	RCALL SUBOPT_0x3D
000357 d95f      	RCALL SUBOPT_0x57
000358 9508      	RET
                 ; 0001 0210     }
                 ; 0001 0211   }
                 _0x20063:
000359 cfed      	RJMP _0x2005E
                 _0x20060:
                 ; 0001 0212 
                 ; 0001 0213   /* Ограничение по кол-ву файлов */
                 ; 0001 0214   /* Корневой каталог FAT16 так же вернет fs_file.entry_index == 0 */
                 ; 0001 0215   if(fs_file.entry_index == 0) { lastError = ERR_DIR_FULL; return 0; }
00035a d8ac      	RCALL SUBOPT_0x35
00035b 9730      	SBIW R30,0
00035c f419      	BRNE _0x20067
00035d e0e5      	LDI  R30,LOW(5)
00035e d7b2      	RCALL SUBOPT_0xB
00035f c007      	RJMP _0x2020019
                 ; 0001 0216 
                 ; 0001 0217   /* Выделить кластер. Результат в fs_tmp */
                 ; 0001 0218   if(fs_allocCluster(ALLOCCLUSTER)) return 0;
                 _0x20067:
000360 d951      	RCALL SUBOPT_0x55
000361 d958      	RCALL SUBOPT_0x58
000362 f421      	BRNE _0x2020019
                 ; 0001 0219 
                 ; 0001 021A   /* Добавить еще один кластер к папке. */
                 ; 0001 021B   if(fs_setNextCluster(fs_file.entry_cluster)) return 0; /* fs_tmp сохранится, так как он не LAST и не FREE */
000363 d8ac      	RCALL SUBOPT_0x37
000364 d958      	RCALL SUBOPT_0x59
000365 30e0      	CPI  R30,0
000366 f019      	BREQ _0x20069
                 _0x2020019:
000367 e0e0      	LDI  R30,LOW(0)
000368 e0f0      	LDI  R31,HIGH(0)
000369 9508      	RET
                 ; 0001 021C 
                 ; 0001 021D   /* Заполняем ответ */
                 ; 0001 021E   fs_file.entry_cluster = fs_tmp;
                 _0x20069:
00036a d8ae      	RCALL SUBOPT_0x38
                 ; 0001 021F   fs_clust2sect();
                 ; 0001 0220   fs_file.entry_sector  = fs_tmp;
                 ; 0001 0221 
                 ; 0001 0222   /* Очищаем кластер и за одно BUF (используется переменная fs_tmp) */
                 ; 0001 0223   fs_eraseCluster(0);
00036b d946      	RCALL SUBOPT_0x55
00036c dfc3      	RCALL _fs_eraseCluster_G001
                 ; 0001 0224 
                 ; 0001 0225   /* Найденный описатель */
                 ; 0001 0226   return buf;
00036d d90d      	RCALL SUBOPT_0x47
00036e 9508      	RET
                 ; 0001 0227 }
                 ;
                 ;/**************************************************************************
                 ;*  Открыть/создать файл или папку                                         *
                 ;*                                                                         *
                 ;*  Имя файла в buf. Оно не должно превышать FS_MAXFILE симолов включая 0  *
                 ;*                                                                         *
                 ;*  what = OPENED_NONE - Открыть файл или папку                            *
                 ;*  what = OPENED_FILE - Создать файл (созданный файл открыт)              *
                 ;*  what = OPENED_DIR  - Создать папку (созданная папка не открыта)        *
                 ;*  what | 0x80        - Не создавать файл в папке entry_start_cluster     *
                 ;*                                                                         *
                 ;*  На выходе                                                              *
                 ;*   FS_DIRENTRY                 - описатель                               *
                 ;*   fs_file.entry_able          - 0 (если открыт существующий файл/папка) *
                 ;*   fs_file.entry_sector        - сектор описателя                        *
                 ;*   fs_file.entry_cluster       - кластер описателя                       *
                 ;*   fs_file.entry_index         - номер описателя                         *
                 ;*   fs_file.entry_start_cluster - первый кластер файла или папки          *
                 ;*   fs_parent_dir_cluster       - первый кластер папки предка (CREATE)    *
                 ;*   fs_file.ptr                 - 0 (если открыт файл)                    *
                 ;*   fs_file.size                - размер файла (если открыт файл)         *
                 ;*                                                                         *
                 ;*  Функция не портит buf[0..MAX_FILENAME-1]                               *
                 ;**************************************************************************/
                 ;
                 ;static BYTE fs_open0_create(BYTE dir); /* forward */
                 ;static CONST BYTE* fs_open0_name(CONST BYTE *p); /* forward */
                 ;
                 ;#define FS_DIRFIND      (buf + 469)           /* 11 байт использующиеся внутри функции fs_open0 */
                 ;#define fs_notrootdir (*(BYTE*)&fs_file.size) /* Используется fs_open0, в это время переменные fs_file. не содежат нужных значения */
                 ;#define fs_parent_dir_cluster fs_file.sector  /* Так же используется fs_file.sector для хранения первого кластера папки предка. */
                 ;
                 ;BYTE fs_open0(BYTE what) {
                 ; 0001 0248 BYTE fs_open0(BYTE what) {
                 _fs_open0:
                 ; 0001 0249   CONST BYTE *path;
                 ; 0001 024A   BYTE r;
                 ; 0001 024B 
                 ; 0001 024C   /* Проверка ошибок программиста */
                 ; 0001 024D #ifndef FS_DISABLE_CHECK
                 ; 0001 024E   if(fs_type == FS_ERROR) { lastError = ERR_NO_FILESYSTEM; goto abort; }
00036f db9d      	RCALL __SAVELOCR4
                 ;	what -> Y+4
                 ;	*path -> R16,R17
                 ;	r -> R19
000370 e0e2      	LDI  R30,LOW(2)
000371 15e5      	CP   R30,R5
000372 f411      	BRNE _0x2006A
000373 e0e1      	LDI  R30,LOW(1)
000374 c0a0      	RJMP _0x2010B
                 ; 0001 024F   fs_file.opened = OPENED_NONE;
                 _0x2006A:
000375 d780      	RCALL SUBOPT_0x5
                 ; 0001 0250 #endif
                 ; 0001 0251 
                 ; 0001 0252   /* Предотвращение рекурсии */
                 ; 0001 0253   r = what & 0x80; what &= 0x7F;
000376 81ec      	LDD  R30,Y+4
000377 78e0      	ANDI R30,LOW(0x80)
000378 2f3e      	MOV  R19,R30
000379 81ec      	LDD  R30,Y+4
00037a 77ef      	ANDI R30,0x7F
00037b 83ec      	STD  Y+4,R30
                 ; 0001 0254   fs_parent_dir_cluster = fs_file.entry_start_cluster;
00037c d8b0      	RCALL SUBOPT_0x39
00037d d941      	RCALL SUBOPT_0x5A
                 ; 0001 0255 
                 ; 0001 0256   /* Корневой каталог */
                 ; 0001 0257   fs_notrootdir = 0;
00037e e0e0      	LDI  R30,LOW(0)
                +
00037f 93e0 03b3+STS _fs_file + ( 20 ) , R30
                 	__PUTB1MN _fs_file,20
                 ; 0001 0258   fs_file.entry_start_cluster = fs_dirbase;
000381 d8b4      	RCALL SUBOPT_0x3A
000382 d945      	RCALL SUBOPT_0x5B
                 ; 0001 0259   if(fs_type == FS_FAT16) fs_file.entry_start_cluster =  0;
000383 2055      	TST  R5
000384 f411      	BRNE _0x2006C
000385 d94b      	RCALL SUBOPT_0x5C
000386 d941      	RCALL SUBOPT_0x5B
                 ; 0001 025A 
                 ; 0001 025B   /* Корневая папка */
                 ; 0001 025C   if(buf[0] == 0) {
                 _0x2006C:
000387 91e0 0180 	LDS  R30,_buf
000389 30e0      	CPI  R30,0
00038a f459      	BRNE _0x2006D
                 ; 0001 025D     if(what) goto abort_noPath;
00038b 81ec      	LDD  R30,Y+4
00038c 30e0      	CPI  R30,0
00038d f009      	BREQ _0x2006E
00038e c085      	RJMP _0x2006F
                 ; 0001 025E     FS_DIRENTRY[0] = 0;             /* Признак корневой папки */
                 _0x2006E:
00038f e0e0      	LDI  R30,LOW(0)
                +
000390 93e0 0360+STS _buf + ( 480 ) , R30
                 	__PUTB1MN _buf,480
                 ; 0001 025F     FS_DIRENTRY[DIR_Attr] = AM_DIR; /* Для упрощения определения файл/папка запишем сюда AM_DIR */
000392 e1e0      	LDI  R30,LOW(16)
                +
000393 93e0 036b+STS _buf + ( 491 ) , R30
                 	__PUTB1MN _buf,491
                 ; 0001 0260   } else {
000395 c057      	RJMP _0x20070
                 _0x2006D:
                 ; 0001 0261     path = buf;
                +
000396 e800     +LDI R16 , LOW ( _buf )
000397 e011     +LDI R17 , HIGH ( _buf )
                 	__POINTWRM 16,17,_buf
                 ; 0001 0262     while(1) {
                 _0x20071:
                 ; 0001 0263       /* Получаем очередное имя из path в FS_DIRFIND */
                 ; 0001 0264       path = fs_open0_name(path);
000398 d93d      	RCALL SUBOPT_0x5D
000399 d08e      	RCALL _fs_open0_name_G001
00039a 018f      	MOVW R16,R30
                 ; 0001 0265       if(path == (CONST BYTE*)1) goto abort_noPath;
00039b e0e1      	LDI  R30,LOW(1)
00039c e0f0      	LDI  R31,HIGH(1)
00039d 17e0      	CP   R30,R16
00039e 07f1      	CPC  R31,R17
00039f f409      	BRNE _0x20074
0003a0 c073      	RJMP _0x2006F
                 ; 0001 0266       /* Ищем имя в папке */
                 ; 0001 0267       fs_file.entry_able = 0;
                 _0x20074:
0003a1 d861      	RCALL SUBOPT_0x34
                 ; 0001 0268       while(1) {
                 _0x20075:
                 ; 0001 0269         if(fs_readdir_nocheck()) return 1;
0003a2 dea4      	RCALL _fs_readdir_nocheck
0003a3 30e0      	CPI  R30,0
0003a4 f019      	BREQ _0x20078
0003a5 e0e1      	LDI  R30,LOW(1)
0003a6 db6d      	RCALL __LOADLOCR4
0003a7 c726      	RJMP _0x2020001
                 ; 0001 026A         if(fs_file.entry_able == 0) break;
                 _0x20078:
0003a8 d841      	RCALL SUBOPT_0x30
0003a9 f039      	BREQ _0x20077
                 ; 0001 026B         if(!memcmp(FS_DIRENTRY, FS_DIRFIND, 11)) break;
0003aa d894      	RCALL SUBOPT_0x3B
0003ab d92d      	RCALL SUBOPT_0x5E
0003ac d92f      	RCALL SUBOPT_0x5F
0003ad d73a      	RCALL SUBOPT_0x2
0003ae d6ec      	RCALL _memcmp
0003af 30e0      	CPI  R30,0
0003b0 f789      	BRNE _0x20075
                 ; 0001 026C       }
                 _0x20077:
                 ; 0001 026D       /* Последний элементу пути в режиме создания */
                 ; 0001 026E       if(what && path == 0) {
0003b1 81ec      	LDD  R30,Y+4
0003b2 30e0      	CPI  R30,0
0003b3 f021      	BREQ _0x2007C
0003b4 2400      	CLR  R0
0003b5 1600      	CP   R0,R16
0003b6 0601      	CPC  R0,R17
0003b7 f009      	BREQ _0x2007D
                 _0x2007C:
0003b8 c017      	RJMP _0x2007B
                 _0x2007D:
                 ; 0001 026F         fs_parent_dir_cluster = fs_file.entry_start_cluster; /* Сохраняем в этой переменной результат для фунции fs_move */
0003b9 d873      	RCALL SUBOPT_0x39
0003ba d904      	RCALL SUBOPT_0x5A
                 ; 0001 0270         if(fs_type == FS_FAT32 && fs_parent_dir_cluster == fs_dirbase) fs_parent_dir_cluster = 0;
0003bb e0e1      	LDI  R30,LOW(1)
0003bc 15e5      	CP   R30,R5
0003bd f421      	BRNE _0x2007F
0003be d920      	RCALL SUBOPT_0x60
0003bf d876      	RCALL SUBOPT_0x3A
0003c0 db40      	RCALL __CPD12
0003c1 f009      	BREQ _0x20080
                 _0x2007F:
0003c2 c002      	RJMP _0x2007E
                 _0x20080:
0003c3 d90d      	RCALL SUBOPT_0x5C
0003c4 d8fa      	RCALL SUBOPT_0x5A
                 ; 0001 0271         if(fs_file.entry_able == 0) return fs_open0_create(what-1); /* Продолжим там */
                 _0x2007E:
0003c5 d824      	RCALL SUBOPT_0x30
0003c6 f439      	BRNE _0x20081
0003c7 81ec      	LDD  R30,Y+4
0003c8 d771      	RCALL SUBOPT_0x15
0003c9 9731      	SBIW R30,1
0003ca 93ea      	ST   -Y,R30
0003cb d09c      	RCALL _fs_open0_create_G001
0003cc db47      	RCALL __LOADLOCR4
0003cd c700      	RJMP _0x2020001
                 ; 0001 0272         lastError = ERR_FILE_EXISTS; goto abort;
                 _0x20081:
0003ce e0e8      	LDI  R30,LOW(8)
0003cf c045      	RJMP _0x2010B
                 ; 0001 0273       }
                 ; 0001 0274       /* Файл/папка не найдена */
                 ; 0001 0275       if(fs_file.entry_able == 0) goto abort_noPath;
                 _0x2007B:
0003d0 d819      	RCALL SUBOPT_0x30
0003d1 f409      	BRNE _0x20082
0003d2 c041      	RJMP _0x2006F
                 ; 0001 0276 
                 ; 0001 0277       /* Что то найдено */
                 ; 0001 0278       fs_file.entry_start_cluster = fs_getEntryCluster();
                 _0x20082:
0003d3 ddd1      	RCALL _fs_getEntryCluster_G001
0003d4 d8f3      	RCALL SUBOPT_0x5B
                 ; 0001 0279       /* Это был последний элемент пути */
                 ; 0001 027A       if(path == 0) break;
0003d5 d912      	RCALL SUBOPT_0x61
0003d6 f0b1      	BREQ _0x20073
                 ; 0001 027B       /* Это должна быть папка */
                 ; 0001 027C       if((FS_DIRENTRY[DIR_Attr] & AM_DIR) == 0) goto abort_noPath;
0003d7 d87f      	RCALL SUBOPT_0x40
0003d8 71e0      	ANDI R30,LOW(0x10)
0003d9 f1d1      	BREQ _0x2006F
                 ; 0001 027D       /* Предотвращаем рекурсию для функции fs_move */
                 ; 0001 027E       if(r && fs_file.entry_start_cluster == fs_parent_dir_cluster) goto abort_noPath;
0003da 3030      	CPI  R19,0
0003db f059      	BREQ _0x20086
                +
0003dc 91a0 03ab+LDS R26 , _fs_file + ( 12 )
0003de 91b0 03ac+LDS R27 , _fs_file + ( 12 ) + 1
0003e0 9180 03ad+LDS R24 , _fs_file + ( 12 ) + 2
0003e2 9190 03ae+LDS R25 , _fs_file + ( 12 ) + 3
                 	__GETD2MN _fs_file,12
0003e4 d906      	RCALL SUBOPT_0x62
0003e5 db1b      	RCALL __CPD12
0003e6 f009      	BREQ _0x20087
                 _0x20086:
0003e7 c001      	RJMP _0x20085
                 _0x20087:
0003e8 c02b      	RJMP _0x2006F
                 ; 0001 027F       /* Наденная папка уже не будет корневой */
                 ; 0001 0280       fs_notrootdir = 1;
                 _0x20085:
0003e9 e0e1      	LDI  R30,LOW(1)
                +
0003ea 93e0 03b3+STS _fs_file + ( 20 ) , R30
                 	__PUTB1MN _fs_file,20
                 ; 0001 0281     }
0003ec cfab      	RJMP _0x20071
                 _0x20073:
                 ; 0001 0282   }
                 _0x20070:
                 ; 0001 0283   /* Устанавливаем переменные */
                 ; 0001 0284   fs_file.entry_able = 0;
0003ed d815      	RCALL SUBOPT_0x34
                 ; 0001 0285   fs_file.size  = LD_DWORD(FS_DIRENTRY + DIR_FileSize);
0003ee d773      	RCALL SUBOPT_0x1E
0003ef d904      	RCALL SUBOPT_0x63
                 ; 0001 0286   fs_file.ptr   = 0;
                 ; 0001 0287 #ifndef FS_DISABLE_CHECK
                 ; 0001 0288   fs_file.opened     = OPENED_FILE;
                 ; 0001 0289   if(FS_DIRENTRY[DIR_Attr] & AM_DIR) fs_file.opened = OPENED_DIR;
0003f0 d866      	RCALL SUBOPT_0x40
0003f1 71e0      	ANDI R30,LOW(0x10)
0003f2 f019      	BREQ _0x20088
0003f3 e0e2      	LDI  R30,LOW(2)
0003f4 93e0 039f 	STS  _fs_file,R30
                 ; 0001 028A #endif
                 ; 0001 028B 
                 ; 0001 028C   /* Нельзя дважды открывать файл */
                 ; 0001 028D #ifndef FS_DISABLE_CHECK
                 ; 0001 028E #ifndef FS_DISABLE_SWAP
                 ; 0001 028F   if(fs_secondFile.opened==OPENED_FILE && fs_file.opened==OPENED_FILE && fs_secondFile.entry_sector == fs_file.entry_sector && fs_secondFile.entry_index==fs_file.entry_index) {
                 _0x20088:
0003f6 91a0 03c0 	LDS  R26,_fs_secondFile
0003f8 30a1      	CPI  R26,LOW(0x1)
0003f9 f4a9      	BRNE _0x2008A
0003fa d90e      	RCALL SUBOPT_0x64
0003fb f499      	BRNE _0x2008A
                +
0003fc 91a0 03c8+LDS R26 , _fs_secondFile + ( 8 )
0003fe 91b0 03c9+LDS R27 , _fs_secondFile + ( 8 ) + 1
000400 9180 03ca+LDS R24 , _fs_secondFile + ( 8 ) + 2
000402 9190 03cb+LDS R25 , _fs_secondFile + ( 8 ) + 3
                 	__GETD2MN _fs_secondFile,8
000404 d83d      	RCALL SUBOPT_0x3C
000405 dafb      	RCALL __CPD12
000406 f441      	BRNE _0x2008A
                +
000407 91a0 03c2+LDS R26 , _fs_secondFile + ( 2 )
000409 91b0 03c3+LDS R27 , _fs_secondFile + ( 2 ) + 1
                 	__GETW2MN _fs_secondFile,2
00040b d7fb      	RCALL SUBOPT_0x35
00040c 17ea      	CP   R30,R26
00040d 07fb      	CPC  R31,R27
00040e f009      	BREQ _0x2008B
                 _0x2008A:
00040f c001      	RJMP _0x20089
                 _0x2008B:
                 ; 0001 0290     fs_secondFile.opened = OPENED_NONE; //!9-05-2014 Закрываем второй файл
000410 d6e9      	RCALL SUBOPT_0x6
                 ; 0001 0291   }
                 ; 0001 0292 #endif
                 ; 0001 0293 #endif
                 ; 0001 0294 
                 ; 0001 0295   return 0;
                 _0x20089:
000411 e0e0      	LDI  R30,LOW(0)
000412 db01      	RCALL __LOADLOCR4
000413 c6ba      	RJMP _0x2020001
                 ; 0001 0296 abort_noPath:
                 _0x2006F:
                 ; 0001 0297   lastError = ERR_NO_PATH;
000414 e0e4      	LDI  R30,LOW(4)
                 _0x2010B:
000415 93e0 0384 	STS  _lastError,R30
                 ; 0001 0298 abort:
                 ; 0001 0299   return 1;
000417 e0e1      	LDI  R30,LOW(1)
000418 dafb      	RCALL __LOADLOCR4
000419 c6b4      	RJMP _0x2020001
                 ; 0001 029A }
                 ;
                 ;static BYTE exists(const flash BYTE* str, BYTE c) {
                 ; 0001 029C static BYTE exists(const flash BYTE* str, BYTE c) {
                 _exists_G001:
                 ; 0001 029D   while(*str)
                 ;	*str -> Y+1
                 ;	c -> Y+0
                 _0x2008C:
00041a 81e9      	LDD  R30,Y+1
00041b 81fa      	LDD  R31,Y+1+1
00041c 91e4      	LPM  R30,Z
00041d 30e0      	CPI  R30,0
00041e f039      	BREQ _0x2008E
                 ; 0001 029E     if(*str++ == c)
00041f d8ec      	RCALL SUBOPT_0x65
000420 91a4      	LPM  R26,Z
000421 81e8      	LD   R30,Y
000422 17ea      	CP   R30,R26
000423 f409      	BRNE _0x2008F
                 ; 0001 029F       return c;
000424 c41f      	RJMP _0x202000B
                 ; 0001 02A0   return 0;
                 _0x2008F:
000425 cff4      	RJMP _0x2008C
                 _0x2008E:
000426 e0e0      	LDI  R30,LOW(0)
000427 c41c      	RJMP _0x202000B
                 ; 0001 02A1 }
                 ;
                 ;static CONST BYTE * fs_open0_name(CONST BYTE *p) {
                 ; 0001 02A3 static  BYTE * fs_open0_name( BYTE *p) {
                 _fs_open0_name_G001:
                 ; 0001 02A4   BYTE c, ni, i;
                 ; 0001 02A5 
                 ; 0001 02A6   memset(FS_DIRFIND, ' ', 11);
000428 dae4      	RCALL __SAVELOCR4
                 ;	*p -> Y+4
                 ;	c -> R17
                 ;	ni -> R16
                 ;	i -> R19
000429 d8af      	RCALL SUBOPT_0x5E
00042a d8e8      	RCALL SUBOPT_0x66
                 ; 0001 02A7   i = 0; ni = 8;
00042b e030      	LDI  R19,LOW(0)
00042c e008      	LDI  R16,LOW(8)
                 ; 0001 02A8   while(1) {
                 _0x20090:
                 ; 0001 02A9     c = *p++;
00042d 81ac      	LDD  R26,Y+4
00042e 81bd      	LDD  R27,Y+4+1
00042f 911d      	LD   R17,X+
000430 83ac      	STD  Y+4,R26
000431 83bd      	STD  Y+4+1,R27
                 ; 0001 02AA     if(c == 0) {
000432 3010      	CPI  R17,0
000433 f429      	BRNE _0x20093
                 ; 0001 02AB       if(i == 0) break; /* Пустое имя файла */
000434 3030      	CPI  R19,0
000435 f171      	BREQ _0x20092
                 ; 0001 02AC       return 0;
000436 d6ae      	RCALL SUBOPT_0x1
000437 dadc      	RCALL __LOADLOCR4
000438 c687      	RJMP _0x2020002
                 ; 0001 02AD     }
                 ; 0001 02AE     if(c == '/') return p;
                 _0x20093:
000439 321f      	CPI  R17,47
00043a f419      	BRNE _0x20095
00043b d8db      	RCALL SUBOPT_0x67
00043c dad7      	RCALL __LOADLOCR4
00043d c682      	RJMP _0x2020002
                 ; 0001 02AF     if(c == '.') {
                 _0x20095:
00043e 321e      	CPI  R17,46
00043f f439      	BRNE _0x20096
                 ; 0001 02B0       if(i == 0) break; /* Пустое имя файла */
000440 3030      	CPI  R19,0
000441 f111      	BREQ _0x20092
                 ; 0001 02B1 #ifndef FS_DISABLE_CHECK
                 ; 0001 02B2       if(ni != 8) break; /* Вторая точка */
000442 3008      	CPI  R16,8
000443 f501      	BRNE _0x20092
                 ; 0001 02B3 #endif
                 ; 0001 02B4       i = 8; ni = 11;
000444 e038      	LDI  R19,LOW(8)
000445 e00b      	LDI  R16,LOW(11)
                 ; 0001 02B5       continue;
000446 cfe6      	RJMP _0x20090
                 ; 0001 02B6     }
                 ; 0001 02B7     /* Слишком длинное име */
                 ; 0001 02B8     if(i == ni) break;
                 _0x20096:
000447 1703      	CP   R16,R19
000448 f0d9      	BREQ _0x20092
                 ; 0001 02B9     /* Запрещенные символы */
                 ; 0001 02BA #ifndef FS_DISABLE_CHECK
                 ; 0001 02BB     if(exists((const flash BYTE* )"+,;=[]*?<:>\\|\"", c)) break;
                +
000449 e2e6     +LDI R30 , LOW ( 2 * _0x20000 + ( 0 ) )
00044a e0f0     +LDI R31 , HIGH ( 2 * _0x20000 + ( 0 ) )
                 	__POINTW1FN _0x20000,0
00044b d69c      	RCALL SUBOPT_0x2
00044c 931a      	ST   -Y,R17
00044d dfcc      	RCALL _exists_G001
00044e 30e0      	CPI  R30,0
00044f f4a1      	BRNE _0x20092
                 ; 0001 02BC     if(c <= 0x20) break;
000450 3211      	CPI  R17,33
000451 f090      	BRLO _0x20092
                 ; 0001 02BD     if(c >= 0x80) break;
000452 3810      	CPI  R17,128
000453 f480      	BRSH _0x20092
                 ; 0001 02BE #endif
                 ; 0001 02BF     /* Приводим к верхнему регистру */
                 ; 0001 02C0     if(c >= 'a' && c <= 'z') c -= 0x20;
000454 3611      	CPI  R17,97
000455 f010      	BRLO _0x2009E
000456 371b      	CPI  R17,123
000457 f008      	BRLO _0x2009F
                 _0x2009E:
000458 c003      	RJMP _0x2009D
                 _0x2009F:
000459 d818      	RCALL SUBOPT_0x45
00045a 97b0      	SBIW R30,32
00045b 2f1e      	MOV  R17,R30
                 ; 0001 02C1     /* Сохраняем имя */
                 ; 0001 02C2     FS_DIRFIND[i++] = c;
                 _0x2009D:
                +
00045c e5a5     +LDI R26 , LOW ( _buf + ( 469 ) )
00045d e0b3     +LDI R27 , HIGH ( _buf + ( 469 ) )
                 	__POINTW2MN _buf,469
00045e 2fe3      	MOV  R30,R19
00045f 5f3f      	SUBI R19,-1
000460 d6d9      	RCALL SUBOPT_0x15
000461 d81c      	RCALL SUBOPT_0x48
000462 8310      	ST   Z,R17
                 ; 0001 02C3   }
000463 cfc9      	RJMP _0x20090
                 _0x20092:
                 ; 0001 02C4   /* Ошибка */
                 ; 0001 02C5   return (CONST BYTE*)1;
000464 e0e1      	LDI  R30,LOW(1)
000465 e0f0      	LDI  R31,HIGH(1)
000466 daad      	RCALL __LOADLOCR4
000467 c658      	RJMP _0x2020002
                 ; 0001 02C6 }
                 ;
                 ;static BYTE fs_open0_create(BYTE dir) {
                 ; 0001 02C8 static BYTE fs_open0_create(BYTE dir) {
                 _fs_open0_create_G001:
                 ; 0001 02C9   BYTE  new_name[11];
                 ; 0001 02CA   DWORD allocatedCluster;
                 ; 0001 02CB   BYTE* allocatedEntry;
                 ; 0001 02CC 
                 ; 0001 02CD   /* Сохраняем имя, так как весь буфер будет затерт */
                 ; 0001 02CE   memcpy(new_name, FS_DIRFIND, 11);
000468 972f      	SBIW R28,15
000469 daa5      	RCALL __SAVELOCR2
                 ;	dir -> Y+17
                 ;	new_name -> Y+6
                 ;	allocatedCluster -> Y+2
                 ;	*allocatedEntry -> R16,R17
00046a 01fe      	MOVW R30,R28
00046b 9636      	ADIW R30,6
00046c d67b      	RCALL SUBOPT_0x2
00046d d86b      	RCALL SUBOPT_0x5E
00046e d8ab      	RCALL SUBOPT_0x68
                 ; 0001 02CF 
                 ; 0001 02D0   /* Выделяем кластер для папки */
                 ; 0001 02D1   if(dir) {
00046f f031      	BREQ _0x200A0
                 ; 0001 02D2     if(fs_allocCluster(ALLOCCLUSTER)) goto abort; /* fs_file.entry_start_cluster изменен не будет, там первый кластер папки в которой мы создадим файл */
000470 d841      	RCALL SUBOPT_0x55
000471 d848      	RCALL SUBOPT_0x58
000472 f009      	BREQ _0x200A1
000473 c04d      	RJMP _0x200A2
                 ; 0001 02D3     allocatedCluster = fs_tmp;
                 _0x200A1:
000474 d723      	RCALL SUBOPT_0x25
000475 d828      	RCALL SUBOPT_0x50
                 ; 0001 02D4   }
                 ; 0001 02D5 
                 ; 0001 02D6   /* Добавляем в папку описатель (сектор не сохранен) */
                 ; 0001 02D7   allocatedEntry = fs_allocEntry();
                 _0x200A0:
000476 ded0      	RCALL _fs_allocEntry_G001
000477 018f      	MOVW R16,R30
                 ; 0001 02D8   if(allocatedEntry == 0) {
000478 d86f      	RCALL SUBOPT_0x61
000479 f421      	BRNE _0x200A3
                 ; 0001 02D9 
                 ; 0001 02DA     /* В случае ошибки освобождаем кластер */
                 ; 0001 02DB     fs_tmp = FREE_CLUSTER;
00047a d751      	RCALL SUBOPT_0x2C
                 ; 0001 02DC     fs_setNextCluster(allocatedCluster);
00047b d82c      	RCALL SUBOPT_0x52
00047c d840      	RCALL SUBOPT_0x59
                 ; 0001 02DD     goto abort;
00047d c043      	RJMP _0x200A2
                 ; 0001 02DE   }
                 ; 0001 02DF 
                 ; 0001 02E0   /* Устаналиваем имя в описатель. */
                 ; 0001 02E1   memset(allocatedEntry, 0, 32);
                 _0x200A3:
00047e d857      	RCALL SUBOPT_0x5D
00047f d832      	RCALL SUBOPT_0x55
000480 e2e0      	LDI  R30,LOW(32)
000481 e0f0      	LDI  R31,HIGH(32)
000482 d832      	RCALL SUBOPT_0x56
                 ; 0001 02E2   memcpy(allocatedEntry, new_name, 11);
000483 d852      	RCALL SUBOPT_0x5D
000484 01fe      	MOVW R30,R28
000485 9638      	ADIW R30,8
000486 d661      	RCALL SUBOPT_0x2
000487 d892      	RCALL SUBOPT_0x68
                 ; 0001 02E3 
                 ; 0001 02E4   if(!dir) {
000488 f449      	BRNE _0x200A4
                 ; 0001 02E5     /* Сохраняем описатель на диск */
                 ; 0001 02E6     if(sd_writeBuf(fs_file.entry_sector)) goto abort;
000489 d7b8      	RCALL SUBOPT_0x3C
00048a d895      	RCALL SUBOPT_0x69
00048b f5a9      	BRNE _0x200A2
                 ; 0001 02E7     /* fs_file.entry_sector, fs_file.entry_index - устанавлиается в fs_allocCluster */
                 ; 0001 02E8     fs_file.entry_start_cluster = 0;
00048c d844      	RCALL SUBOPT_0x5C
00048d d83a      	RCALL SUBOPT_0x5B
                 ; 0001 02E9     fs_file.size           = 0;
00048e d842      	RCALL SUBOPT_0x5C
00048f d864      	RCALL SUBOPT_0x63
                 ; 0001 02EA     fs_file.ptr            = 0;
                 ; 0001 02EB #ifndef FS_DISABLE_CHECK
                 ; 0001 02EC     fs_file.opened              = OPENED_FILE;
                 ; 0001 02ED #endif
                 ; 0001 02EE     return 0;
000490 e0e0      	LDI  R30,LOW(0)
000491 c030      	RJMP _0x2020018
                 ; 0001 02EF   }
                 ; 0001 02F0 
                 ; 0001 02F1   /* Это папка */
                 ; 0001 02F2   allocatedEntry[DIR_Attr] = AM_DIR;
                 _0x200A4:
000492 01f8      	MOVW R30,R16
000493 963b      	ADIW R30,11
000494 e1a0      	LDI  R26,LOW(16)
000495 83a0      	STD  Z+0,R26
                 ; 0001 02F3   fs_setEntryCluster(allocatedEntry, allocatedCluster);
000496 d83f      	RCALL SUBOPT_0x5D
000497 d684      	RCALL SUBOPT_0xE
000498 d88b      	RCALL SUBOPT_0x6A
                 ; 0001 02F4 
                 ; 0001 02F5   /* Сохраняем описатель на диск */
                 ; 0001 02F6   if(sd_writeBuf(fs_file.entry_sector)) goto abort;
000499 d7a8      	RCALL SUBOPT_0x3C
00049a d885      	RCALL SUBOPT_0x69
00049b f529      	BRNE _0x200A2
                 ; 0001 02F7 
                 ; 0001 02F8   /* Сектор для новой папки */
                 ; 0001 02F9   fs_tmp = allocatedCluster;
00049c d80b      	RCALL SUBOPT_0x52
00049d d743      	RCALL SUBOPT_0x2F
                 ; 0001 02FA   fs_clust2sect();
00049e dd4b      	RCALL _fs_clust2sect_G001
                 ; 0001 02FB 
                 ; 0001 02FC   /* Очищаем fs_tmp и за одно buf */
                 ; 0001 02FD   fs_eraseCluster(1);
00049f d886      	RCALL SUBOPT_0x6B
0004a0 de8f      	RCALL _fs_eraseCluster_G001
                 ; 0001 02FE 
                 ; 0001 02FF   /* Создаем пустую папку */
                 ; 0001 0300   memset(buf, ' ', 11); buf[0] = '.'; buf[11] = 0x10;
0004a1 d80e      	RCALL SUBOPT_0x54
0004a2 d870      	RCALL SUBOPT_0x66
0004a3 e2ee      	LDI  R30,LOW(46)
0004a4 93e0 0180 	STS  _buf,R30
0004a6 e1e0      	LDI  R30,LOW(16)
                +
0004a7 93e0 018b+STS _buf + ( 11 ) , R30
                 	__PUTB1MN _buf,11
                 ; 0001 0301   fs_setEntryCluster(buf, allocatedCluster);
0004a9 d806      	RCALL SUBOPT_0x54
0004aa d671      	RCALL SUBOPT_0xE
0004ab d878      	RCALL SUBOPT_0x6A
                 ; 0001 0302 
                 ; 0001 0303   memset(buf+32, ' ', 11); buf[32] = '.'; buf[33] = '.'; buf[32+11] = 0x10;
0004ac d87c      	RCALL SUBOPT_0x6C
0004ad d865      	RCALL SUBOPT_0x66
0004ae e2ee      	LDI  R30,LOW(46)
                +
0004af 93e0 01a0+STS _buf + ( 32 ) , R30
                 	__PUTB1MN _buf,32
                +
0004b1 93e0 01a1+STS _buf + ( 33 ) , R30
                 	__PUTB1MN _buf,33
0004b3 e1e0      	LDI  R30,LOW(16)
                +
0004b4 93e0 01ab+STS _buf + ( 43 ) , R30
                 	__PUTB1MN _buf,43
                 ; 0001 0304   if(fs_notrootdir) fs_setEntryCluster(buf + 32, fs_file.entry_start_cluster); /* Сейчас в fs_file.size==0 значит корневой каталог */
                +
0004b6 91e0 03b3+LDS R30 , _fs_file + ( 20 )
                 	__GETB1MN _fs_file,20
0004b8 30e0      	CPI  R30,0
0004b9 f019      	BREQ _0x200A7
0004ba d86e      	RCALL SUBOPT_0x6C
0004bb d771      	RCALL SUBOPT_0x39
0004bc d867      	RCALL SUBOPT_0x6A
                 ; 0001 0305 
                 ; 0001 0306   /* Сохраняем папку */
                 ; 0001 0307   return sd_writeBuf(fs_tmp);
                 _0x200A7:
0004bd d6da      	RCALL SUBOPT_0x25
0004be da22      	RCALL __PUTPARD1
0004bf dbb4      	RCALL _sd_writeBuf_G001
0004c0 c001      	RJMP _0x2020018
                 ; 0001 0308 abort:
                 _0x200A2:
                 ; 0001 0309   return 1;
0004c1 e0e1      	LDI  R30,LOW(1)
                 _0x2020018:
0004c2 da53      	RCALL __LOADLOCR2
0004c3 9662      	ADIW R28,18
0004c4 9508      	RET
                 ; 0001 030A }
                 ;
                 ;/**************************************************************************
                 ;*  Открыть файл                                                           *
                 ;**************************************************************************/
                 ;
                 ;BYTE fs_open() {
                 ; 0001 0310 BYTE fs_open() {
                 _fs_open:
                 ; 0001 0311   if(fs_openany()) goto abort;
0004c5 d7ec      	RCALL SUBOPT_0x55
0004c6 d865      	RCALL SUBOPT_0x6D
0004c7 f431      	BRNE _0x200A9
                 ; 0001 0312 #ifndef FS_DISABLE_CHECK
                 ; 0001 0313   if(fs_file.opened == OPENED_FILE) return 0;
0004c8 d840      	RCALL SUBOPT_0x64
0004c9 f409      	BRNE _0x200AA
0004ca c226      	RJMP _0x2020011
                 ; 0001 0314   fs_file.opened = OPENED_NONE;
                 _0x200AA:
0004cb d62a      	RCALL SUBOPT_0x5
                 ; 0001 0315 #else
                 ; 0001 0316   if((FS_DIRENTRY[DIR_Attr] & AM_DIR) == 0) return 0;
                 ; 0001 0317 #endif
                 ; 0001 0318   lastError = ERR_NO_PATH;
0004cc e0e4      	LDI  R30,LOW(4)
0004cd d643      	RCALL SUBOPT_0xB
                 ; 0001 0319 abort:
                 _0x200A9:
                 ; 0001 031A   return 1;
0004ce c217      	RJMP _0x2020014
                 ; 0001 031B }
                 ;
                 ;/**************************************************************************
                 ;*  Открыть папку                                                          *
                 ;**************************************************************************/
                 ;
                 ;BYTE fs_opendir() {
                 ; 0001 0321 BYTE fs_opendir() {
                 _fs_opendir:
                 ; 0001 0322   if(fs_openany()) goto abort;
0004cf d7e2      	RCALL SUBOPT_0x55
0004d0 d85b      	RCALL SUBOPT_0x6D
0004d1 f439      	BRNE _0x200AC
                 ; 0001 0323 #ifndef FS_DISABLE_CHECK
                 ; 0001 0324   if(fs_file.opened == OPENED_DIR) return 0;
0004d2 d787      	RCALL SUBOPT_0x41
0004d3 30a2      	CPI  R26,LOW(0x2)
0004d4 f409      	BRNE _0x200AD
0004d5 c21b      	RJMP _0x2020011
                 ; 0001 0325   fs_file.opened = OPENED_NONE;
                 _0x200AD:
0004d6 d61f      	RCALL SUBOPT_0x5
                 ; 0001 0326 #else
                 ; 0001 0327   if(FS_DIRENTRY[DIR_Attr] & AM_DIR) return 0;
                 ; 0001 0328 #endif
                 ; 0001 0329   lastError = ERR_NO_PATH;
0004d7 e0e4      	LDI  R30,LOW(4)
0004d8 d638      	RCALL SUBOPT_0xB
                 ; 0001 032A abort:
                 _0x200AC:
                 ; 0001 032B   return 1;
0004d9 c20c      	RJMP _0x2020014
                 ; 0001 032C }
                 ;
                 ;/**************************************************************************
                 ;*  Вычислить номер следующего сектора для чтения/записи                   *
                 ;*  Вызывается только из fs_read0, fs_write_start                          *
                 ;**************************************************************************/
                 ;
                 ;static BYTE fs_nextRWSector() {
                 ; 0001 0333 static BYTE fs_nextRWSector() {
                 _fs_nextRWSector_G001:
                 ; 0001 0334   if(fs_file.ptr == 0) {
0004da d854      	RCALL SUBOPT_0x6E
0004db f419      	BRNE _0x200AE
                 ; 0001 0335     /* Чтение файла еще не начато */
                 ; 0001 0336     fs_tmp = fs_file.entry_start_cluster;
0004dc d750      	RCALL SUBOPT_0x39
0004dd d703      	RCALL SUBOPT_0x2F
                 ; 0001 0337   } else {
0004de c013      	RJMP _0x200AF
                 _0x200AE:
                 ; 0001 0338     /* Еще не конец сектора */
                 ; 0001 0339     if((WORD)fs_file.ptr % 512) return 0;
0004df d859      	RCALL SUBOPT_0x6F
0004e0 9730      	SBIW R30,0
0004e1 f009      	BREQ _0x200B0
0004e2 c20e      	RJMP _0x2020011
                 ; 0001 033A 
                 ; 0001 033B     /* Следующий сектор */
                 ; 0001 033C     fs_file.sector++;
                 _0x200B0:
0004e3 d7a0      	RCALL SUBOPT_0x4A
                 ; 0001 033D 
                 ; 0001 033E     /* Еще не конец кластера */
                 ; 0001 033F     if(((fs_file.sector - fs_database) % fs_csize) != 0) return 0;
0004e4 d806      	RCALL SUBOPT_0x62
0004e5 d6f2      	RCALL SUBOPT_0x2E
0004e6 d90f      	RCALL __SUBD12
0004e7 d6ee      	RCALL SUBOPT_0x2D
0004e8 d9c7      	RCALL __MODD21U
0004e9 da09      	RCALL __CPD10
0004ea f009      	BREQ _0x200B1
0004eb c205      	RJMP _0x2020011
                 ; 0001 0340 
                 ; 0001 0341     /* Следующий кластер */
                 ; 0001 0342     fs_tmp = fs_file.cluster;
                 _0x200B1:
0004ec d852      	RCALL SUBOPT_0x70
0004ed d6f3      	RCALL SUBOPT_0x2F
                 ; 0001 0343     if(fs_nextCluster()) return 1;
0004ee dcca      	RCALL _fs_nextCluster_G001
0004ef 30e0      	CPI  R30,0
0004f0 f009      	BREQ _0x200B2
0004f1 c1f4      	RJMP _0x2020014
                 ; 0001 0344   }
                 _0x200B2:
                 _0x200AF:
                 ; 0001 0345 
                 ; 0001 0346   /* Если это был последний кластер, добавляем новый */
                 ; 0001 0347   if(fs_tmp == 0) {
0004f2 d6a5      	RCALL SUBOPT_0x25
0004f3 d9ff      	RCALL __CPD10
0004f4 f459      	BRNE _0x200B3
                 ; 0001 0348     if(fs_allocCluster(ALLOCCLUSTER)) return 1;
0004f5 d7bc      	RCALL SUBOPT_0x55
0004f6 d7c3      	RCALL SUBOPT_0x58
0004f7 f009      	BREQ _0x200B4
0004f8 c1ed      	RJMP _0x2020014
                 ; 0001 0349     if(fs_file.ptr == 0) fs_file.entry_start_cluster = fs_tmp;
                 _0x200B4:
0004f9 d835      	RCALL SUBOPT_0x6E
0004fa f419      	BRNE _0x200B5
0004fb d69c      	RCALL SUBOPT_0x25
0004fc d7cb      	RCALL SUBOPT_0x5B
                 ; 0001 034A                     else fs_setNextCluster(fs_file.cluster); /* fs_tmp сохранится, так как он не LAST и не FREE */
0004fd c002      	RJMP _0x200B6
                 _0x200B5:
0004fe d840      	RCALL SUBOPT_0x70
0004ff d7bd      	RCALL SUBOPT_0x59
                 ; 0001 034B   }
                 _0x200B6:
                 ; 0001 034C 
                 ; 0001 034D   /* Ок */
                 ; 0001 034E   fs_file.cluster = fs_tmp;
                 _0x200B3:
000500 d697      	RCALL SUBOPT_0x25
                +
000501 93e0 03b7+STS _fs_file + ( 24 ) , R30
000503 93f0 03b8+STS _fs_file + ( 24 ) + 1 , R31
000505 9360 03b9+STS _fs_file + ( 24 ) + 2 , R22
000507 9370 03ba+STS _fs_file + ( 24 ) + 3 , R23
                 	__PUTD1MN _fs_file,24
                 ; 0001 034F   fs_clust2sect();
000509 dce0      	RCALL _fs_clust2sect_G001
                 ; 0001 0350   fs_file.sector  = fs_tmp;
00050a d68d      	RCALL SUBOPT_0x25
00050b d7b3      	RCALL SUBOPT_0x5A
                 ; 0001 0351   return 0;
00050c c1e4      	RJMP _0x2020011
                 ; 0001 0352 }
                 ;
                 ;/**************************************************************************
                 ;*  Прочитать из файла несколько байт в buf                                *
                 ;*                                                                         *
                 ;*  Пользователь не должен выходить за пределы файла при чтении, иначе     *
                 ;*  возникнет утечка свобожного места на диске.                            *
                 ;*                                                                         *
                 ;*  Аргументы:                                                             *
                 ;*    ptr      - буфер для чтения, может быть buf                          *
                 ;*    len      - кол-во байт, которые необходимо прочитать                 *
                 ;**************************************************************************/
                 ;
                 ;BYTE fs_read0(BYTE* ptr, WORD len) {
                 ; 0001 035F BYTE fs_read0(BYTE* ptr, WORD len) {
                 _fs_read0:
                 ; 0001 0360   WORD sectorLen;
                 ; 0001 0361 
                 ; 0001 0362   /* Проверка ошибок программиста */
                 ; 0001 0363 #ifndef FS_DISABLE_CHECK
                 ; 0001 0364   if(fs_file.opened != OPENED_FILE) { lastError = ERR_NOT_OPENED; goto abort; }
00050d da01      	RCALL __SAVELOCR2
                 ;	*ptr -> Y+4
                 ;	len -> Y+2
                 ;	sectorLen -> R16,R17
00050e d7fa      	RCALL SUBOPT_0x64
00050f f011      	BREQ _0x200B7
000510 d837      	RCALL SUBOPT_0x71
000511 c035      	RJMP _0x200B8
                 ; 0001 0365 #endif
                 ; 0001 0366 
                 ; 0001 0367   while(len) {
                 _0x200B7:
                 _0x200B9:
000512 d837      	RCALL SUBOPT_0x72
000513 9730      	SBIW R30,0
000514 f149      	BREQ _0x200BB
                 ; 0001 0368     /* Если указатель находится на границе сектора */
                 ; 0001 0369     if(fs_nextRWSector()) goto abort;
000515 dfc4      	RCALL _fs_nextRWSector_G001
000516 30e0      	CPI  R30,0
000517 f579      	BRNE _0x200B8
                 ; 0001 036A 
                 ; 0001 036B     /* Кол-во байт до конца сектора */
                 ; 0001 036C     sectorLen = 512 - ((WORD)fs_file.ptr % 512);
000518 d820      	RCALL SUBOPT_0x6F
000519 d833      	RCALL SUBOPT_0x73
                 ; 0001 036D     if(len < sectorLen) sectorLen = len;
00051a 81aa      	LDD  R26,Y+2
00051b 81bb      	LDD  R27,Y+2+1
00051c 17a0      	CP   R26,R16
00051d 07b1      	CPC  R27,R17
00051e f410      	BRSH _0x200BD
                +
00051f 810a     +LDD R16 , Y + 2
000520 811b     +LDD R17 , Y + 2 + 1
                 	__GETWRS 16,17,2
                 ; 0001 036E 
                 ; 0001 036F     /* Читаем данные */
                 ; 0001 0370     if(ptr) {
                 _0x200BD:
000521 d7f5      	RCALL SUBOPT_0x67
000522 9730      	SBIW R30,0
000523 f081      	BREQ _0x200BE
                 ; 0001 0371       if(sd_read(ptr, fs_file.sector, (WORD)fs_file.ptr % 512, sectorLen)) goto abort;
000524 d7f2      	RCALL SUBOPT_0x67
000525 d5c2      	RCALL SUBOPT_0x2
000526 d7c4      	RCALL SUBOPT_0x62
000527 d9b9      	RCALL __PUTPARD1
000528 d810      	RCALL SUBOPT_0x6F
000529 d5be      	RCALL SUBOPT_0x2
00052a d7ab      	RCALL SUBOPT_0x5D
00052b d270      	RCALL _sd_read
00052c 30e0      	CPI  R30,0
00052d f4c9      	BRNE _0x200B8
                 ; 0001 0372       ptr += sectorLen;
00052e 01f8      	MOVW R30,R16
00052f 81ac      	LDD  R26,Y+4
000530 81bd      	LDD  R27,Y+4+1
000531 d74c      	RCALL SUBOPT_0x48
000532 83ec      	STD  Y+4,R30
000533 83fd      	STD  Y+4+1,R31
                 ; 0001 0373     }
                 ; 0001 0374 
                 ; 0001 0375     /* Увеличиваем смещение */
                 ; 0001 0376     fs_file.ptr += sectorLen;
                 _0x200BE:
000534 d81e      	RCALL SUBOPT_0x74
000535 01f8      	MOVW R30,R16
000536 d5f6      	RCALL SUBOPT_0x13
000537 d824      	RCALL SUBOPT_0x75
                 ; 0001 0377     len -= sectorLen;
000538 d811      	RCALL SUBOPT_0x72
000539 1be0      	SUB  R30,R16
00053a 0bf1      	SBC  R31,R17
00053b 83ea      	STD  Y+2,R30
00053c 83fb      	STD  Y+2+1,R31
                 ; 0001 0378   }
00053d cfd4      	RJMP _0x200B9
                 _0x200BB:
                 ; 0001 0379 
                 ; 0001 037A   /* Увеличение размера файла */
                 ; 0001 037B   if(fs_file.ptr > fs_file.size) fs_file.size = fs_file.ptr, fs_file.changed = 1;
00053e d814      	RCALL SUBOPT_0x74
00053f d825      	RCALL SUBOPT_0x76
000540 d9c0      	RCALL __CPD12
000541 f410      	BRSH _0x200C0
000542 d82b      	RCALL SUBOPT_0x77
000543 d833      	RCALL SUBOPT_0x78
                 ; 0001 037C 
                 ; 0001 037D   return 0;
                 _0x200C0:
000544 e0e0      	LDI  R30,LOW(0)
000545 d9d0      	RCALL __LOADLOCR2
000546 c579      	RJMP _0x2020002
                 ; 0001 037E abort:
                 _0x200B8:
                 ; 0001 037F #ifndef FS_DISABLE_CHECK
                 ; 0001 0380   fs_file.opened = OPENED_NONE;
000547 d5ae      	RCALL SUBOPT_0x5
                 ; 0001 0381 #endif
                 ; 0001 0382   return 1;
000548 d752      	RCALL SUBOPT_0x4F
000549 c576      	RJMP _0x2020002
                 ; 0001 0383 }
                 ;
                 ;/**************************************************************************
                 ;*  Прочитать из файла несколько байт в buf                                *
                 ;*                                                                         *
                 ;*  Аргументы:                                                             *
                 ;*    ptr      - буфер для чтения, может быть buf                          *
                 ;*    len      - кол-во байт, которые необходимо прочитать                 *
                 ;*    readed   - указатель, для сохранения кол-ва реально прочитанных байт *
                 ;**************************************************************************/
                 ;
                 ;BYTE fs_read(BYTE* ptr, WORD len, WORD* readed) {
                 ; 0001 038E BYTE fs_read(BYTE* ptr, WORD len, WORD* readed) {
                 ; 0001 038F   /* Ограничиваем кол-во байт для чтения */
                 ; 0001 0390   if(len > fs_file.size - fs_file.ptr) len = (WORD)(fs_file.size - fs_file.ptr);
                 ;	*ptr -> Y+4
                 ;	len -> Y+2
                 ;	*readed -> Y+0
                 ; 0001 0391   *readed = len;
                 ; 0001 0392 
                 ; 0001 0393   /* Проверка на ошибки происходит там */
                 ; 0001 0394   return fs_read0(ptr, len);
                 ; 0001 0395 }
                 ;
                 ;/**************************************************************************
                 ;*  Сохранить длину файла и превый кластер в опистаель                     *
                 ;*  Вызывается из fs_lseek, fs_write_start, fs_write_end, fs_write_eof     *
                 ;**************************************************************************/
                 ;
                 ;static char fs_saveFileLength() {
                 ; 0001 039C static char fs_saveFileLength() {
                 _fs_saveFileLength_G001:
                 ; 0001 039D   BYTE* entry;
                 ; 0001 039E 
                 ; 0001 039F   if(fs_file.changed == 0) return 0;
00054a d9c4      	RCALL __SAVELOCR2
                 ;	*entry -> R16,R17
                +
00054b 91e0 03bf+LDS R30 , _fs_file + ( 32 )
                 	__GETB1MN _fs_file,32
00054d 30e0      	CPI  R30,0
00054e f411      	BRNE _0x200C2
00054f e0e0      	LDI  R30,LOW(0)
000550 c097      	RJMP _0x2020016
                 ; 0001 03A0   fs_file.changed = 0;
                 _0x200C2:
000551 e0e0      	LDI  R30,LOW(0)
                +
000552 93e0 03bf+STS _fs_file + ( 32 ) , R30
                 	__PUTB1MN _fs_file,32
                 ; 0001 03A1 
                 ; 0001 03A2   /* Изменение описателя файла */
                 ; 0001 03A3   if(sd_readBuf(fs_file.entry_sector)) return 1;
000554 d6ed      	RCALL SUBOPT_0x3C
000555 d5ad      	RCALL SUBOPT_0x8
000556 f009      	BREQ _0x200C3
000557 c08f      	RJMP _0x2020017
                 ; 0001 03A4 
                 ; 0001 03A5   entry = buf + (fs_file.entry_index % 16) * 32;
                 _0x200C3:
000558 d6ae      	RCALL SUBOPT_0x35
000559 d6f1      	RCALL SUBOPT_0x3D
00055a d828      	RCALL SUBOPT_0x79
                 ; 0001 03A6   LD_DWORD(entry + DIR_FileSize) = fs_file.size;
00055b d809      	RCALL SUBOPT_0x76
                +
00055c 01d8     +MOVW R26 , R16
00055d 965c     +ADIW R26 , 28
00055e d964     +RCALL __PUTDP1
                 	__PUTD1RNS 16,28
                 ; 0001 03A7   fs_setEntryCluster(entry, fs_file.entry_start_cluster);
00055f d776      	RCALL SUBOPT_0x5D
000560 d6cc      	RCALL SUBOPT_0x39
000561 d7c2      	RCALL SUBOPT_0x6A
                 ; 0001 03A8 
                 ; 0001 03A9   return sd_writeBuf(fs_file.entry_sector);
000562 d6df      	RCALL SUBOPT_0x3C
000563 d97d      	RCALL __PUTPARD1
000564 db0f      	RCALL _sd_writeBuf_G001
000565 c082      	RJMP _0x2020016
                 ; 0001 03AA }
                 ;
                 ;/**************************************************************************
                 ;*  Установить смещение чтения/записи файла                                *
                 ;**************************************************************************/
                 ;
                 ;#define LSEEK_STEP 32768
                 ;
                 ;BYTE fs_lseek(DWORD off, BYTE mode) {
                 ; 0001 03B2 BYTE fs_lseek(DWORD off, BYTE mode) {
                 _fs_lseek:
                 ; 0001 03B3   DWORD l;
                 ; 0001 03B4 
                 ; 0001 03B5   /* Режим */
                 ; 0001 03B6   if(mode==1) off += fs_file.ptr; else
000566 9724      	SBIW R28,4
                 ;	off -> Y+5
                 ;	mode -> Y+4
                 ;	l -> Y+0
000567 81ac      	LDD  R26,Y+4
000568 30a1      	CPI  R26,LOW(0x1)
000569 f411      	BRNE _0x200C4
00056a d803      	RCALL SUBOPT_0x77
00056b c004      	RJMP _0x2010C
                 _0x200C4:
                 ; 0001 03B7   if(mode==2) off += fs_file.size;
00056c 81ac      	LDD  R26,Y+4
00056d 30a2      	CPI  R26,LOW(0x2)
00056e f439      	BRNE _0x200C6
00056f d7f5      	RCALL SUBOPT_0x76
                 _0x2010C:
                +
000570 81ad     +LDD R26 , Y + 5
000571 81be     +LDD R27 , Y + 5 + 1
000572 818f     +LDD R24 , Y + 5 + 2
000573 8598     +LDD R25 , Y + 5 + 3
                 	__GETD2S 5
000574 d877      	RCALL __ADDD12
000575 d810      	RCALL SUBOPT_0x7A
                 ; 0001 03B8 
                 ; 0001 03B9   /* Можно заменить на fs_file.ptr = 0 для уменьшения кода*/
                 ; 0001 03BA   if(off >= fs_file.ptr) off -= fs_file.ptr; else fs_file.ptr = 0;
                 _0x200C6:
000576 d7f7      	RCALL SUBOPT_0x77
000577 d813      	RCALL SUBOPT_0x7B
000578 d98d      	RCALL __CPD21
000579 f040      	BRLO _0x200C7
00057a d7f3      	RCALL SUBOPT_0x77
00057b d80f      	RCALL SUBOPT_0x7B
00057c d87e      	RCALL __SUBD21
                +
00057d 83ad     +STD Y + 5 , R26
00057e 83be     +STD Y + 5 + 1 , R27
00057f 838f     +STD Y + 5 + 2 , R24
000580 8798     +STD Y + 5 + 3 , R25
                 	__PUTD2S 5
000581 c002      	RJMP _0x200C8
                 _0x200C7:
000582 d74e      	RCALL SUBOPT_0x5C
000583 d7d8      	RCALL SUBOPT_0x75
                 ; 0001 03BB 
                 ; 0001 03BC   do { /* Выполняем один цикл даже для off=0, так как внутри происходит проверка на ошибки */
                 _0x200C8:
                 _0x200CA:
                 ; 0001 03BD     l = off;
000584 d80b      	RCALL SUBOPT_0x7C
000585 d5a0      	RCALL SUBOPT_0x11
                 ; 0001 03BE     if(l > LSEEK_STEP) l = LSEEK_STEP;
000586 d5bc      	RCALL SUBOPT_0x18
                +
000587 30a1     +CPI R26 , LOW ( 0x8001 )
000588 e8e0     +LDI R30 , HIGH ( 0x8001 )
000589 07be     +CPC R27 , R30
00058a e0e0     +LDI R30 , BYTE3 ( 0x8001 )
00058b 078e     +CPC R24 , R30
00058c e0e0     +LDI R30 , BYTE4 ( 0x8001 )
00058d 079e     +CPC R25 , R30
                 	__CPD2N 0x8001
00058e f028      	BRLO _0x200CC
                +
00058f e0e0     +LDI R30 , LOW ( 0x8000 )
000590 e8f0     +LDI R31 , HIGH ( 0x8000 )
000591 e060     +LDI R22 , BYTE3 ( 0x8000 )
000592 e070     +LDI R23 , BYTE4 ( 0x8000 )
                 	__GETD1N 0x8000
000593 d592      	RCALL SUBOPT_0x11
                 ; 0001 03BF     if(fs_read0(0, (WORD)l)) return 1;
                 _0x200CC:
000594 d550      	RCALL SUBOPT_0x1
000595 d552      	RCALL SUBOPT_0x2
000596 d7b3      	RCALL SUBOPT_0x72
000597 d550      	RCALL SUBOPT_0x2
000598 df74      	RCALL _fs_read0
000599 30e0      	CPI  R30,0
00059a f011      	BREQ _0x200CD
00059b e0e1      	LDI  R30,LOW(1)
00059c c31a      	RJMP _0x202000A
                 ; 0001 03C0     off -= l;
                 _0x200CD:
00059d d5a5      	RCALL SUBOPT_0x18
00059e d7f1      	RCALL SUBOPT_0x7C
00059f d856      	RCALL __SUBD12
0005a0 d7e5      	RCALL SUBOPT_0x7A
                 ; 0001 03C1   } while(off);
0005a1 d7ee      	RCALL SUBOPT_0x7C
0005a2 d950      	RCALL __CPD10
0005a3 f701      	BRNE _0x200CA
                 ; 0001 03C2 
                 ; 0001 03C3   /* Размер файла мог изменится */
                 ; 0001 03C4   fs_saveFileLength();
0005a4 dfa5      	RCALL _fs_saveFileLength_G001
                 ; 0001 03C5 
                 ; 0001 03C6   /* Результат */
                 ; 0001 03C7   fs_tmp = fs_file.ptr;
0005a5 d7c8      	RCALL SUBOPT_0x77
0005a6 d63a      	RCALL SUBOPT_0x2F
                 ; 0001 03C8 
                 ; 0001 03C9   return 0;
0005a7 e0e0      	LDI  R30,LOW(0)
0005a8 c30e      	RJMP _0x202000A
                 ; 0001 03CA }
                 ;
                 ;/**************************************************************************
                 ;*  Записать в файл (шаг 1)                                                *
                 ;***************************************************************************/
                 ;
                 ;BYTE fs_write_start() {
                 ; 0001 03D0 BYTE fs_write_start() {
                 _fs_write_start:
                 ; 0001 03D1   WORD len;
                 ; 0001 03D2 
                 ; 0001 03D3   /* Проверка ошибок программиста */
                 ; 0001 03D4 #ifndef FS_DISABLE_CHECK
                 ; 0001 03D5   if(fs_file.opened != OPENED_FILE) { lastError = ERR_NOT_OPENED; goto abort; }
0005a9 d965      	RCALL __SAVELOCR2
                 ;	len -> R16,R17
0005aa d75e      	RCALL SUBOPT_0x64
0005ab f011      	BREQ _0x200CE
0005ac d79b      	RCALL SUBOPT_0x71
0005ad c037      	RJMP _0x200CF
                 ; 0001 03D6   if(fs_wtotal == 0) { lastError = ERR_NO_DATA; goto abort; }
                 _0x200CE:
0005ae d7e6      	RCALL SUBOPT_0x7D
0005af 9730      	SBIW R30,0
0005b0 f419      	BRNE _0x200D0
0005b1 e0e9      	LDI  R30,LOW(9)
0005b2 d55e      	RCALL SUBOPT_0xB
0005b3 c031      	RJMP _0x200CF
                 ; 0001 03D7 #endif
                 ; 0001 03D8 
                 ; 0001 03D9   /* Сколько можно еще дописать в этот сектор? */
                 ; 0001 03DA   len = 512 - (WORD)fs_file.ptr % 512;
                 _0x200D0:
0005b4 d784      	RCALL SUBOPT_0x6F
0005b5 d797      	RCALL SUBOPT_0x73
                 ; 0001 03DB 
                 ; 0001 03DC   /* Ограничиваем остатком данных в файле */
                 ; 0001 03DD   if(len > fs_wtotal) len = (WORD)fs_wtotal;
0005b6 d7de      	RCALL SUBOPT_0x7D
0005b7 17e0      	CP   R30,R16
0005b8 07f1      	CPC  R31,R17
0005b9 f420      	BRSH _0x200D1
                +
0005ba 9100 0385+LDS R16 , 0 + ( _fs_wtotal )
0005bc 9110 0386+LDS R17 , 0 + ( _fs_wtotal ) + 1
                 	__GETWRMN 16,17,0,_fs_wtotal
                 ; 0001 03DE 
                 ; 0001 03DF   /* Вычисление fs_file.sector, выделение кластеров */
                 ; 0001 03E0   if(fs_nextRWSector()) goto abort; /* Должно вылетать только по ошибкам ERR_NO_FREE_SPACE, ERR_DISK_ERR */
                 _0x200D1:
0005be df1b      	RCALL _fs_nextRWSector_G001
0005bf 30e0      	CPI  R30,0
0005c0 f521      	BRNE _0x200CF
                 ; 0001 03E1 
                 ; 0001 03E2   /* Корректируем длину файла */
                 ; 0001 03E3   if(fs_file.size < fs_file.ptr + len) {
0005c1 d791      	RCALL SUBOPT_0x74
0005c2 01f8      	MOVW R30,R16
0005c3 d569      	RCALL SUBOPT_0x13
                +
0005c4 91a0 03b3+LDS R26 , _fs_file + ( 20 )
0005c6 91b0 03b4+LDS R27 , _fs_file + ( 20 ) + 1
0005c8 9180 03b5+LDS R24 , _fs_file + ( 20 ) + 2
0005ca 9190 03b6+LDS R25 , _fs_file + ( 20 ) + 3
                 	__GETD2MN _fs_file,20
0005cc d939      	RCALL __CPD21
0005cd f420      	BRSH _0x200D3
                 ; 0001 03E4     fs_file.size = fs_file.ptr + len;
0005ce d784      	RCALL SUBOPT_0x74
0005cf 01f8      	MOVW R30,R16
0005d0 d55c      	RCALL SUBOPT_0x13
0005d1 d7a5      	RCALL SUBOPT_0x78
                 ; 0001 03E5     fs_file.changed = 1;
                 ; 0001 03E6   }
                 ; 0001 03E7 
                 ; 0001 03E8   /* Читаем данные сектора, если не весь сектор будет заполнен */
                 ; 0001 03E9   if(len != 512) {
                 _0x200D3:
0005d2 e0e0      	LDI  R30,LOW(512)
0005d3 e0f2      	LDI  R31,HIGH(512)
0005d4 17e0      	CP   R30,R16
0005d5 07f1      	CPC  R31,R17
0005d6 f019      	BREQ _0x200D4
                 ; 0001 03EA     if(sd_readBuf(fs_file.sector)) goto abort;
0005d7 d713      	RCALL SUBOPT_0x62
0005d8 d52a      	RCALL SUBOPT_0x8
0005d9 f459      	BRNE _0x200CF
                 ; 0001 03EB   }
                 ; 0001 03EC 
                 ; 0001 03ED   fs_file_wlen = len;
                 _0x200D4:
                +
0005da 9300 0380+STS _fs_tmp + ( 0 ) , R16
0005dc 9310 0381+STS _fs_tmp + ( 0 ) + 1 , R17
                 	__PUTWMRN _fs_tmp,0,16,17
                 ; 0001 03EE   fs_file_woff = (WORD)fs_file.ptr % 512;
0005de d75a      	RCALL SUBOPT_0x6F
                +
0005df 93e0 0382+STS _fs_tmp + ( 2 ) , R30
0005e1 93f0 0383+STS _fs_tmp + ( 2 ) + 1 , R31
                 	__PUTW1MN _fs_tmp,2
                 ; 0001 03EF   return 0;
0005e3 e0e0      	LDI  R30,LOW(0)
0005e4 c003      	RJMP _0x2020016
                 ; 0001 03F0 abort:
                 _0x200CF:
                 ; 0001 03F1   /* Скорее всего это ошибка ERR_NO_FREE_SPACE */
                 ; 0001 03F2   /* Если размер файла был изменен, то надо бы сохранить изменения в описатель файла. */
                 ; 0001 03F3   fs_saveFileLength();
0005e5 df64      	RCALL _fs_saveFileLength_G001
                 ; 0001 03F4   /* Закрываем файл */
                 ; 0001 03F5 #ifndef FS_DISABLE_CHECK
                 ; 0001 03F6   fs_file.opened = OPENED_NONE;
0005e6 d50f      	RCALL SUBOPT_0x5
                 ; 0001 03F7 #endif
                 ; 0001 03F8   return 1;
                 _0x2020017:
0005e7 e0e1      	LDI  R30,LOW(1)
                 _0x2020016:
0005e8 d930      	RCALL __LOADLOCR2P
0005e9 9508      	RET
                 ; 0001 03F9 }
                 ;
                 ;/**************************************************************************
                 ;*  Записать в файл (шаг 2)                                                *
                 ;***************************************************************************/
                 ;
                 ;BYTE fs_write_end() {
                 ; 0001 03FF BYTE fs_write_end() {
                 _fs_write_end:
                 ; 0001 0400 #ifndef FS_DISABLE_CHECK
                 ; 0001 0401   if(fs_file.opened != OPENED_FILE) { lastError = ERR_NOT_OPENED; goto abort; }
0005ea d71e      	RCALL SUBOPT_0x64
0005eb f011      	BREQ _0x200D6
0005ec d75b      	RCALL SUBOPT_0x71
0005ed c019      	RJMP _0x200D7
                 ; 0001 0402 #endif
                 ; 0001 0403 
                 ; 0001 0404   /* Записываем изменения на диск */
                 ; 0001 0405   if(sd_writeBuf(fs_file.sector)) goto abort;
                 _0x200D6:
0005ee d6fc      	RCALL SUBOPT_0x62
0005ef d730      	RCALL SUBOPT_0x69
0005f0 f4b1      	BRNE _0x200D7
                 ; 0001 0406 
                 ; 0001 0407   /* В случае ошибки файл может содержать больше кластеров, чем требуется по его размеру. */
                 ; 0001 0408   /* Но это не плохо, данные не повреждены. А эта ошибка проявится лишь в уменьшении */
                 ; 0001 0409   /* места на диске. */
                 ; 0001 040A 
                 ; 0001 040B   /* Счетчики */
                 ; 0001 040C   fs_file.ptr += fs_file_wlen;
0005f1 d761      	RCALL SUBOPT_0x74
0005f2 d6b0      	RCALL SUBOPT_0x51
0005f3 d539      	RCALL SUBOPT_0x13
0005f4 d767      	RCALL SUBOPT_0x75
                 ; 0001 040D   fs_wtotal   -= fs_file_wlen;
0005f5 91a0 0380 	LDS  R26,_fs_tmp
0005f7 91b0 0381 	LDS  R27,_fs_tmp+1
0005f9 d79b      	RCALL SUBOPT_0x7D
0005fa 1bea      	SUB  R30,R26
0005fb 0bfb      	SBC  R31,R27
0005fc 93e0 0385 	STS  _fs_wtotal,R30
0005fe 93f0 0386 	STS  _fs_wtotal+1,R31
                 ; 0001 040E 
                 ; 0001 040F   /* Если запись закончена, сохраняем размера файла и первый кластер */
                 ; 0001 0410   if(fs_wtotal == 0) {
000600 d794      	RCALL SUBOPT_0x7D
000601 9730      	SBIW R30,0
000602 f419      	BRNE _0x200D9
                 ; 0001 0411     if(fs_saveFileLength()) goto abort;
000603 df46      	RCALL _fs_saveFileLength_G001
000604 30e0      	CPI  R30,0
000605 f409      	BRNE _0x200D7
                 ; 0001 0412   }
                 ; 0001 0413 
                 ; 0001 0414   /* Ок */
                 ; 0001 0415   return 0;
                 _0x200D9:
000606 c0ea      	RJMP _0x2020011
                 ; 0001 0416 abort:
                 _0x200D7:
                 ; 0001 0417 #ifndef FS_DISABLE_CHECK
                 ; 0001 0418     fs_file.opened = OPENED_NONE;
000607 d4ee      	RCALL SUBOPT_0x5
                 ; 0001 0419 #endif
                 ; 0001 041A   return 1;
000608 c0dd      	RJMP _0x2020014
                 ; 0001 041B }
                 ;
                 ;/**************************************************************************
                 ;*  Освободить цепочку кластеров начиная с fs_tmp                          *
                 ;**************************************************************************/
                 ;
                 ;static BYTE fs_freeChain() {
                 ; 0001 0421 static BYTE fs_freeChain() {
                 _fs_freeChain_G001:
                 ; 0001 0422   DWORD c;
                 ; 0001 0423   while(1) {
000609 9724      	SBIW R28,4
                 ;	c -> Y+0
                 _0x200DB:
                 ; 0001 0424     if(fs_tmp < 2 || fs_tmp >= fs_n_fatent) return 0;
00060a d5a5      	RCALL SUBOPT_0x29
00060b d5ad      	RCALL SUBOPT_0x2A
00060c f010      	BRLO _0x200DF
00060d d5b3      	RCALL SUBOPT_0x2B
00060e f010      	BRLO _0x200DE
                 _0x200DF:
00060f e0e0      	LDI  R30,LOW(0)
000610 c3a4      	RJMP _0x2020004
                 ; 0001 0425     /* Освободить кластер fs_tmp и записть в fs_tmp следующий за ним кластер */
                 ; 0001 0426     c = fs_tmp, fs_tmp = FREE_CLUSTER;
                 _0x200DE:
000611 d586      	RCALL SUBOPT_0x25
000612 d513      	RCALL SUBOPT_0x11
000613 d5b8      	RCALL SUBOPT_0x2C
                 ; 0001 0427     if(fs_setNextCluster(c)) break; /* fs_tmp будет содержать следующий кластер, так как записывается FREE_CLUSTER */
000614 d50f      	RCALL SUBOPT_0x10
000615 d6a7      	RCALL SUBOPT_0x59
000616 30e0      	CPI  R30,0
000617 f391      	BREQ _0x200DB
                 ; 0001 0428   }
                 ; 0001 0429   return 1;
000618 e0e1      	LDI  R30,LOW(1)
000619 c39b      	RJMP _0x2020004
                 ; 0001 042A }
                 ;
                 ;/**************************************************************************
                 ;*  Переместить файл/папку                                                 *
                 ;**************************************************************************/
                 ;
                 ;BYTE fs_move0() {
                 ; 0001 0430 BYTE fs_move0() {
                 _fs_move0:
                 ; 0001 0431   BYTE* entry;
                 ; 0001 0432   BYTE tmp[21];
                 ; 0001 0433   WORD old_index;
                 ; 0001 0434   DWORD old_sector, old_start_cluster;
                 ; 0001 0435 
                 ; 0001 0436 #ifndef FS_DISABLE_CHECK
                 ; 0001 0437   if(fs_file.opened == OPENED_NONE) { lastError = ERR_NOT_OPENED; goto abort; }
00061a 976d      	SBIW R28,29
00061b d8f1      	RCALL __SAVELOCR4
                 ;	*entry -> R16,R17
                 ;	tmp -> Y+12
                 ;	old_index -> R18,R19
                 ;	old_sector -> Y+8
                 ;	old_start_cluster -> Y+4
00061c 91e0 039f 	LDS  R30,_fs_file
00061e 30e0      	CPI  R30,0
00061f f411      	BRNE _0x200E2
000620 d727      	RCALL SUBOPT_0x71
000621 c043      	RJMP _0x200E3
                 ; 0001 0438 #endif
                 ; 0001 0439 
                 ; 0001 043A   /* Запоминаем старый описатель */
                 ; 0001 043B   old_index         = fs_file.entry_index;
                 _0x200E2:
                +
000622 9120 03a1+LDS R18 , _fs_file + ( 2 )
000624 9130 03a2+LDS R19 , _fs_file + ( 2 ) + 1
                 	__GETWRMN 18,19,_fs_file,2
                 ; 0001 043C   old_sector        = fs_file.entry_sector;
000626 d61b      	RCALL SUBOPT_0x3C
                +
000627 87e8     +STD Y + 8 , R30
000628 87f9     +STD Y + 8 + 1 , R31
000629 876a     +STD Y + 8 + 2 , R22
00062a 877b     +STD Y + 8 + 3 , R23
                 	__PUTD1S 8
                 ; 0001 043D   old_start_cluster = fs_file.entry_start_cluster;
00062b d601      	RCALL SUBOPT_0x39
00062c d4ea      	RCALL SUBOPT_0xD
                 ; 0001 043E 
                 ; 0001 043F   /* Создаем новый файл. В папку он превратится позже. 0x80 - это предотвращаем рекурсию. */
                 ; 0001 0440   if(fs_open0(OPENED_FILE | 0x80)) goto abort;
00062d e8e1      	LDI  R30,LOW(129)
00062e 93ea      	ST   -Y,R30
00062f d6fc      	RCALL SUBOPT_0x6D
000630 f5a1      	BRNE _0x200E3
                 ; 0001 0441 
                 ; 0001 0442   /* Предотвращаем ошибки программиста */
                 ; 0001 0443 #ifndef FS_DISABLE_CHECK
                 ; 0001 0444   fs_file.opened = OPENED_NONE;
000631 d4c4      	RCALL SUBOPT_0x5
                 ; 0001 0445 #ifndef FS_DISABLE_SWAP
                 ; 0001 0446   fs_secondFile.opened = OPENED_NONE;
000632 d4c7      	RCALL SUBOPT_0x6
                 ; 0001 0447 #endif
                 ; 0001 0448 #endif
                 ; 0001 0449   /* fs_file.sector содежит первый кластер папки, в которой находится созданный файл. */
                 ; 0001 044A 
                 ; 0001 044B   /* Удаление старого файла/папки и перенос всех свойств */
                 ; 0001 044C   if(sd_readBuf(old_sector)) goto abort;
000633 d4ca      	RCALL SUBOPT_0x7
000634 d4ce      	RCALL SUBOPT_0x8
000635 f579      	BRNE _0x200E3
                 ; 0001 044D   entry = buf + (old_index % 16) * 32;
000636 01f9      	MOVW R30,R18
000637 d613      	RCALL SUBOPT_0x3D
000638 d74a      	RCALL SUBOPT_0x79
                 ; 0001 044E   memcpy(tmp, entry+11, 21);
000639 01fe      	MOVW R30,R28
00063a 963c      	ADIW R30,12
00063b d4ac      	RCALL SUBOPT_0x2
00063c 01f8      	MOVW R30,R16
00063d 963b      	ADIW R30,11
00063e d75b      	RCALL SUBOPT_0x7E
                 ; 0001 044F   entry[0] = 0xE5;
00063f 01d8      	MOVW R26,R16
000640 eee5      	LDI  R30,LOW(229)
000641 93ec      	ST   X,R30
                 ; 0001 0450   if(sd_writeBuf(old_sector)) goto abort;
000642 d52e      	RCALL SUBOPT_0x20
000643 f509      	BRNE _0x200E3
                 ; 0001 0451 
                 ; 0001 0452   /* Копируем все свойства новому файлу, тем самым превращая его в папку */
                 ; 0001 0453   if(sd_readBuf(fs_file.entry_sector)) goto abort;
000644 d5fd      	RCALL SUBOPT_0x3C
000645 d4bd      	RCALL SUBOPT_0x8
000646 f4f1      	BRNE _0x200E3
                 ; 0001 0454   entry = buf + (fs_file.entry_index % 16) * 32;
000647 d5bf      	RCALL SUBOPT_0x35
000648 d602      	RCALL SUBOPT_0x3D
000649 d739      	RCALL SUBOPT_0x79
                 ; 0001 0455   memcpy(entry+11, tmp, 21);
00064a 01f8      	MOVW R30,R16
00064b 963b      	ADIW R30,11
00064c d49b      	RCALL SUBOPT_0x2
00064d 01fe      	MOVW R30,R28
00064e 963e      	ADIW R30,14
00064f d74a      	RCALL SUBOPT_0x7E
                 ; 0001 0456   if(sd_writeBuf(fs_file.entry_sector)) goto abort;
000650 d5f1      	RCALL SUBOPT_0x3C
000651 d6ce      	RCALL SUBOPT_0x69
000652 f491      	BRNE _0x200E3
                 ; 0001 0457 
                 ; 0001 0458   /* В папке надо еще скорретировать описатель .. */
                 ; 0001 0459   if(entry[DIR_Attr] & AM_DIR) {
000653 01f8      	MOVW R30,R16
000654 85e3      	LDD  R30,Z+11
000655 71e0      	ANDI R30,LOW(0x10)
000656 f061      	BREQ _0x200E9
                 ; 0001 045A     fs_tmp = old_start_cluster; /* Первый кластер нашей папки */
000657 d4c4      	RCALL SUBOPT_0xE
000658 d588      	RCALL SUBOPT_0x2F
                 ; 0001 045B     fs_clust2sect();
000659 db90      	RCALL _fs_clust2sect_G001
                 ; 0001 045C     if(sd_readBuf(fs_tmp)) goto abort;
00065a d53d      	RCALL SUBOPT_0x25
00065b d4a7      	RCALL SUBOPT_0x8
00065c f441      	BRNE _0x200E3
                 ; 0001 045D     fs_setEntryCluster(buf+32, fs_parent_dir_cluster); /* Первый кластер папки предка.*/
00065d d6cb      	RCALL SUBOPT_0x6C
00065e d68c      	RCALL SUBOPT_0x62
00065f d6c4      	RCALL SUBOPT_0x6A
                 ; 0001 045E     if(sd_writeBuf(fs_tmp)) goto abort;
000660 d537      	RCALL SUBOPT_0x25
000661 d6be      	RCALL SUBOPT_0x69
000662 f411      	BRNE _0x200E3
                 ; 0001 045F   }
                 ; 0001 0460 
                 ; 0001 0461   return 0;
                 _0x200E9:
000663 e0e0      	LDI  R30,LOW(0)
000664 c001      	RJMP _0x2020015
                 ; 0001 0462 abort:
                 _0x200E3:
                 ; 0001 0463   return 1;
000665 e0e1      	LDI  R30,LOW(1)
                 _0x2020015:
000666 d8ad      	RCALL __LOADLOCR4
000667 96a1      	ADIW R28,33
000668 9508      	RET
                 ; 0001 0464 }
                 ;
                 ;BYTE fs_move(const char* from, const char* to) {
                 ; 0001 0466 BYTE fs_move(const char* from, const char* to) {
                 ; 0001 0467   strcpy((char*)buf, from);
                 ;	*from -> Y+2
                 ;	*to -> Y+0
                 ; 0001 0468   if(fs_openany()) return 1;
                 ; 0001 0469   strcpy((char*)buf, to);
                 ; 0001 046A   return fs_move0();
                 ; 0001 046B }
                 ;
                 ;/**************************************************************************
                 ;*  Удалить файл или пустую папку                                          *
                 ;*  Имя файла должно содержаться в buf и не превышать FS_MAXFILE симолов   *
                 ;*  включая терминатор                                                     *
                 ;**************************************************************************/
                 ;
                 ;BYTE fs_delete() {
                 ; 0001 0473 BYTE fs_delete() {
                 _fs_delete:
                 ; 0001 0474   DWORD entrySector;
                 ; 0001 0475   BYTE* entry;
                 ; 0001 0476 
                 ; 0001 0477   /* Там будет проверен fs_type == FS_ERROR */
                 ; 0001 0478   if(fs_openany()) goto abort;
000669 9724      	SBIW R28,4
00066a d8a4      	RCALL __SAVELOCR2
                 ;	entrySector -> Y+2
                 ;	*entry -> R16,R17
00066b d646      	RCALL SUBOPT_0x55
00066c d6bf      	RCALL SUBOPT_0x6D
00066d f531      	BRNE _0x200EE
                 ; 0001 0479 
                 ; 0001 047A   /* Предотвращаем ошибки программиста */
                 ; 0001 047B   fs_file.opened = OPENED_NONE;
00066e d487      	RCALL SUBOPT_0x5
                 ; 0001 047C #ifndef FS_DISABLE_SWAP
                 ; 0001 047D   fs_secondFile.opened = OPENED_NONE;
00066f d48a      	RCALL SUBOPT_0x6
                 ; 0001 047E #endif
                 ; 0001 047F 
                 ; 0001 0480   /* Корневую папку удалять нельзя */
                 ; 0001 0481   if(FS_DIRENTRY[0] == 0) { lastError = ERR_NO_PATH; goto abort; }
000670 d5df      	RCALL SUBOPT_0x3E
000671 f419      	BRNE _0x200EF
000672 e0e4      	LDI  R30,LOW(4)
000673 d49d      	RCALL SUBOPT_0xB
000674 c01f      	RJMP _0x200EE
                 ; 0001 0482 
                 ; 0001 0483   /* Сохраняем интерформацию о найденном файле, так как fs_readdir ниже их прибьет */
                 ; 0001 0484   entrySector = fs_file.entry_sector;
                 _0x200EF:
000675 d5cc      	RCALL SUBOPT_0x3C
000676 d627      	RCALL SUBOPT_0x50
                 ; 0001 0485   entry = buf + (fs_file.entry_index % 16) * 32;
000677 d58f      	RCALL SUBOPT_0x35
000678 d5d2      	RCALL SUBOPT_0x3D
000679 d709      	RCALL SUBOPT_0x79
                 ; 0001 0486 
                 ; 0001 0487   /* В папке не должно быть файлов */
                 ; 0001 0488   if(FS_DIRENTRY[DIR_Attr] & AM_DIR) {
00067a d5dc      	RCALL SUBOPT_0x40
00067b 71e0      	ANDI R30,LOW(0x10)
00067c f049      	BREQ _0x200F0
                 ; 0001 0489     /* Перематывем папку на начало */
                 ; 0001 048A     fs_file.entry_able = 0;
00067d d585      	RCALL SUBOPT_0x34
                 ; 0001 048B     /* Ищем первый файл или папку */
                 ; 0001 048C     /* fs_file.entry_start_cluster сохряняется (содержит первый кластер файла или папки) */
                 ; 0001 048D     if(fs_readdir_nocheck()) goto abort;
00067e dbc8      	RCALL _fs_readdir_nocheck
00067f 30e0      	CPI  R30,0
000680 f499      	BRNE _0x200EE
                 ; 0001 048E     /* Если нашли, то ошибка */
                 ; 0001 048F     if(fs_file.entry_able) { lastError = ERR_DIR_NOT_EMPTY; goto abort; }
000681 d568      	RCALL SUBOPT_0x30
000682 f019      	BREQ _0x200F2
000683 e0e7      	LDI  R30,LOW(7)
000684 d48c      	RCALL SUBOPT_0xB
000685 c00e      	RJMP _0x200EE
                 ; 0001 0490   }
                 _0x200F2:
                 ; 0001 0491 
                 ; 0001 0492   /* Удаляем описатель */
                 ; 0001 0493   if(sd_readBuf(entrySector)) goto abort;
                 _0x200F0:
000686 d621      	RCALL SUBOPT_0x52
000687 d47b      	RCALL SUBOPT_0x8
000688 f459      	BRNE _0x200EE
                 ; 0001 0494   entry[0] = 0xE5;
000689 01d8      	MOVW R26,R16
00068a eee5      	LDI  R30,LOW(229)
00068b 93ec      	ST   X,R30
                 ; 0001 0495   if(sd_writeBuf(entrySector)) goto abort;
00068c d61b      	RCALL SUBOPT_0x52
00068d d692      	RCALL SUBOPT_0x69
00068e f429      	BRNE _0x200EE
                 ; 0001 0496 
                 ; 0001 0497   /* Освобождаем цепочку кластеров */
                 ; 0001 0498   fs_tmp = fs_file.entry_start_cluster;
00068f d59d      	RCALL SUBOPT_0x39
000690 d550      	RCALL SUBOPT_0x2F
                 ; 0001 0499   return fs_freeChain();
000691 df77      	RCALL _fs_freeChain_G001
000692 d883      	RCALL __LOADLOCR2
000693 c42c      	RJMP _0x2020002
                 ; 0001 049A abort:
                 _0x200EE:
                 ; 0001 049B   return 1;
000694 d606      	RCALL SUBOPT_0x4F
000695 c42a      	RJMP _0x2020002
                 ; 0001 049C }
                 ;
                 ;/**************************************************************************
                 ;*  Установить конец файла                                                 *
                 ;**************************************************************************/
                 ;
                 ;BYTE fs_write_eof() {
                 ; 0001 04A2 BYTE fs_write_eof() {
                 _fs_write_eof:
                 ; 0001 04A3   /* Проверка ошибок программиста */
                 ; 0001 04A4 #ifndef FS_DISABLE_CHECK
                 ; 0001 04A5   if(fs_file.opened != OPENED_FILE) { lastError = ERR_NOT_OPENED; goto abort; }
000696 d672      	RCALL SUBOPT_0x64
000697 f011      	BREQ _0x200F5
000698 d6af      	RCALL SUBOPT_0x71
000699 c016      	RJMP _0x200F6
                 ; 0001 04A6 #endif
                 ; 0001 04A7 
                 ; 0001 04A8   /* Корректируем либо FAT, либо описатель файла. */
                 ; 0001 04A9   if(fs_file.ptr == 0) {
                 _0x200F5:
00069a d694      	RCALL SUBOPT_0x6E
00069b f429      	BRNE _0x200F7
                 ; 0001 04AA     /* Удалем все кластеры файла */
                 ; 0001 04AB     fs_tmp = fs_file.entry_start_cluster;
00069c d590      	RCALL SUBOPT_0x39
00069d d543      	RCALL SUBOPT_0x2F
                 ; 0001 04AC     fs_file.entry_start_cluster = 0;
00069e d632      	RCALL SUBOPT_0x5C
00069f d628      	RCALL SUBOPT_0x5B
                 ; 0001 04AD   } else {
0006a0 c006      	RJMP _0x200F8
                 _0x200F7:
                 ; 0001 04AE     /* Этот кластер файла последний. */
                 ; 0001 04AF     fs_tmp = LAST_CLUSTER;
0006a1 d5e5      	RCALL SUBOPT_0x4B
0006a2 d53e      	RCALL SUBOPT_0x2F
                 ; 0001 04B0     if(fs_setNextCluster(fs_file.cluster)) goto abort; /* fs_tmp будет содержать следующий кластер, так как записывается LAST_CLUSTER */
0006a3 d69b      	RCALL SUBOPT_0x70
0006a4 d618      	RCALL SUBOPT_0x59
0006a5 30e0      	CPI  R30,0
0006a6 f449      	BRNE _0x200F6
                 ; 0001 04B1   }
                 _0x200F8:
                 ; 0001 04B2 
                 ; 0001 04B3   /* Удалем все кластеры файла после этого. (они содержатся в fs_tmp); */
                 ; 0001 04B4   if(fs_freeChain()) goto abort;
0006a7 df61      	RCALL _fs_freeChain_G001
0006a8 30e0      	CPI  R30,0
0006a9 f431      	BRNE _0x200F6
                 ; 0001 04B5 
                 ; 0001 04B6   /* Сохраняем длну и первый кластер */
                 ; 0001 04B7   fs_file.size    = fs_file.ptr;
0006aa d6c3      	RCALL SUBOPT_0x77
0006ab d6cb      	RCALL SUBOPT_0x78
                 ; 0001 04B8   fs_file.changed = 1;
                 ; 0001 04B9   if(!fs_saveFileLength()) return 0;
0006ac de9d      	RCALL _fs_saveFileLength_G001
0006ad 30e0      	CPI  R30,0
0006ae f409      	BRNE _0x200FB
0006af c041      	RJMP _0x2020011
                 ; 0001 04BA 
                 ; 0001 04BB abort:
                 _0x200FB:
                 _0x200F6:
                 ; 0001 04BC #ifndef FS_DISABLE_CHECK
                 ; 0001 04BD   fs_file.opened = OPENED_NONE;
0006b0 d445      	RCALL SUBOPT_0x5
                 ; 0001 04BE #endif
                 ; 0001 04BF   return 1;
0006b1 c034      	RJMP _0x2020014
                 ; 0001 04C0 }
                 ;
                 ;/**************************************************************************
                 ;*  Записать в файл                                                        *
                 ;**************************************************************************/
                 ;
                 ;BYTE fs_write(CONST BYTE* ptr, WORD len) {
                 ; 0001 04C6 BYTE fs_write( BYTE* ptr, WORD len) {
                 ; 0001 04C7   /* Проверка на ошибки происходит в вызываемых функциях */
                 ; 0001 04C8 
                 ; 0001 04C9   /* Конец файла */
                 ; 0001 04CA   if(len == 0) return fs_write_eof();
                 ;	*ptr -> Y+2
                 ;	len -> Y+0
                 ; 0001 04CB 
                 ; 0001 04CC   fs_wtotal = len;
                 ; 0001 04CD   do {
                 ; 0001 04CE     if(fs_write_start()) goto abort;
                 ; 0001 04CF     memcpy(fs_file_wbuf, ptr, fs_file_wlen);
                 ; 0001 04D0     ptr += fs_file_wlen;
                 ; 0001 04D1     if(fs_write_end()) goto abort;
                 ; 0001 04D2   } while(fs_wtotal);
                 ; 0001 04D3 
                 ; 0001 04D4   return 0;
                 ; 0001 04D5 abort:
                 ; 0001 04D6   return 1;
                 ; 0001 04D7 }
                 ;
                 ;/**************************************************************************
                 ;*  Переключить файлы                                                      *
                 ;**************************************************************************/
                 ;
                 ;#ifndef FS_DISABLE_SWAP
                 ;void fs_swap() {
                 ; 0001 04DE void fs_swap() {
                 _fs_swap:
                 ; 0001 04DF   /* Это занимает меньше ПЗУ, чем три функции memcpy */
                 ; 0001 04E0   BYTE t, *a = (BYTE*)&fs_file, *b = (BYTE*)&fs_secondFile, n = sizeof(File);
                 ; 0001 04E1   do {
0006b2 d858      	RCALL __SAVELOCR6
                 ;	t -> R17
                 ;	*a -> R18,R19
                 ;	*b -> R20,R21
                 ;	n -> R16
                +
0006b3 e92f     +LDI R18 , LOW ( _fs_file )
0006b4 e033     +LDI R19 , HIGH ( _fs_file )
                 	__POINTWRM 18,19,_fs_file
                +
0006b5 ec40     +LDI R20 , LOW ( _fs_secondFile )
0006b6 e053     +LDI R21 , HIGH ( _fs_secondFile )
                 	__POINTWRM 20,21,_fs_secondFile
0006b7 e201      	LDI  R16,33
                 _0x20104:
                 ; 0001 04E2     t=*a, *a=*b, *b=t; ++a; ++b;
0006b8 01d9      	MOVW R26,R18
0006b9 911c      	LD   R17,X
0006ba 01da      	MOVW R26,R20
0006bb 91ec      	LD   R30,X
0006bc 01d9      	MOVW R26,R18
0006bd 93ec      	ST   X,R30
0006be 2fe1      	MOV  R30,R17
0006bf 01da      	MOVW R26,R20
0006c0 93ec      	ST   X,R30
                +
0006c1 5f2f     +SUBI R18 , LOW ( - 1 )
0006c2 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
                +
0006c3 5f4f     +SUBI R20 , LOW ( - 1 )
0006c4 4f5f     +SBCI R21 , HIGH ( - 1 )
                 	__ADDWRN 20,21,1
                 ; 0001 04E3   } while(--n);
0006c5 5001      	SUBI R16,LOW(1)
0006c6 3000      	CPI  R16,0
0006c7 f781      	BRNE _0x20104
                 ; 0001 04E4 }
0006c8 d849      	RCALL __LOADLOCR6
0006c9 c3f6      	RJMP _0x2020002
                 ;#endif
                 ;
                 ;/**************************************************************************
                 ;*  Расчет свободного места                                                *
                 ;*                                                                         *
                 ;*  Результат в переменной fs_tmp в мегабайтах                             *
                 ;*  Функция закрывает файл                                                 *
                 ;**************************************************************************/
                 ;
                 ;#ifndef FS_DISABLE_GETFREESPACE
                 ;BYTE fs_getfree() {
                 ; 0001 04EF BYTE fs_getfree() {
                 _fs_getfree:
                 ; 0001 04F0   /* Мы испортим переменную fs_file.sector, поэтому закрываем файл */
                 ; 0001 04F1   fs_file.opened = OPENED_NONE;
0006ca d42b      	RCALL SUBOPT_0x5
                 ; 0001 04F2 
                 ; 0001 04F3   /* Кол-во свободных кластеров будет в fs_file.sector */
                 ; 0001 04F4   fs_file.sector = 0;
0006cb d605      	RCALL SUBOPT_0x5C
0006cc d5f2      	RCALL SUBOPT_0x5A
                 ; 0001 04F5   if(fs_allocCluster(1)) return 1;
0006cd d658      	RCALL SUBOPT_0x6B
0006ce d5eb      	RCALL SUBOPT_0x58
0006cf f4b1      	BRNE _0x2020014
                 ; 0001 04F6 
                 ; 0001 04F7   /* Пересчет в мегабайты */
                 ; 0001 04F8   fs_tmp = ((fs_file.sector >> 10) + 1) / 2 * fs_csize;
0006d0 d60e      	RCALL SUBOPT_0x60
0006d1 d6cd      	RCALL SUBOPT_0x7F
0006d2 d774      	RCALL __MULD12U
0006d3 c015      	RJMP _0x2020010
                 ; 0001 04F9 
                 ; 0001 04FA   return 0;
                 ; 0001 04FB }
                 ;#endif
                 ;
                 ;/**************************************************************************
                 ;*  Размер накопителя в мегабайтах                                         *
                 ;**************************************************************************/
                 ;
                 ;BYTE fs_gettotal() {
                 ; 0001 0502 BYTE fs_gettotal() {
                 _fs_gettotal:
                 ; 0001 0503   /* Проверка ошибок программиста */
                 ; 0001 0504 #ifndef FS_DISABLE_CHECK
                 ; 0001 0505   if(fs_type == FS_ERROR) { lastError = ERR_NO_FILESYSTEM; return 1; }
0006d4 e0e2      	LDI  R30,LOW(2)
0006d5 15e5      	CP   R30,R5
0006d6 f411      	BRNE _0x20107
0006d7 e0e1      	LDI  R30,LOW(1)
0006d8 c00b      	RJMP _0x2020013
                 ; 0001 0506 #endif
                 ; 0001 0507 
                 ; 0001 0508   fs_tmp = ((fs_n_fatent >> 10) + 1) / 2 * fs_csize;
                 _0x20107:
0006d9 d471      	RCALL SUBOPT_0x1B
0006da d6c4      	RCALL SUBOPT_0x7F
0006db d76b      	RCALL __MULD12U
0006dc c00c      	RJMP _0x2020010
                 ; 0001 0509   return 0;
                 ; 0001 050A }
                 ;
                 ;/**************************************************************************
                 ;*  Размер файла                                                           *
                 ;**************************************************************************/
                 ;
                 ;BYTE fs_getfilesize() {
                 ; 0001 0510 BYTE fs_getfilesize() {
                 _fs_getfilesize:
                 ; 0001 0511 #ifndef FS_DISABLE_CHECK
                 ; 0001 0512   if(fs_file.opened != OPENED_FILE) {
0006dd d62b      	RCALL SUBOPT_0x64
0006de f421      	BRNE _0x2020012
                 ; 0001 0513     lastError = ERR_NOT_OPENED;
                 ; 0001 0514     return 1;
                 ; 0001 0515   }
                 ; 0001 0516 #endif
                 ; 0001 0517   fs_tmp = fs_file.size;
0006df d685      	RCALL SUBOPT_0x76
0006e0 c008      	RJMP _0x2020010
                 ; 0001 0518   return 0;
                 ; 0001 0519 }
                 ;
                 ;/**************************************************************************
                 ;*  Указатель чтения записи файла                                          *
                 ;**************************************************************************/
                 ;
                 ;BYTE fs_tell() {
                 ; 0001 051F BYTE fs_tell() {
                 _fs_tell:
                 ; 0001 0520 #ifndef FS_DISABLE_CHECK
                 ; 0001 0521   if(fs_file.opened != OPENED_FILE) {
0006e1 d627      	RCALL SUBOPT_0x64
0006e2 f029      	BREQ _0x20109
                 ; 0001 0522     lastError = ERR_NOT_OPENED;
                 _0x2020012:
0006e3 e0e3      	LDI  R30,LOW(3)
                 _0x2020013:
0006e4 93e0 0384 	STS  _lastError,R30
                 ; 0001 0523     return 1;
                 _0x2020014:
0006e6 e0e1      	LDI  R30,LOW(1)
0006e7 9508      	RET
                 ; 0001 0524   }
                 ; 0001 0525 #endif
                 ; 0001 0526   fs_tmp = fs_file.ptr;
                 _0x20109:
0006e8 d685      	RCALL SUBOPT_0x77
                 _0x2020010:
0006e9 93e0 0380 	STS  _fs_tmp,R30
0006eb 93f0 0381 	STS  _fs_tmp+1,R31
0006ed 9360 0382 	STS  _fs_tmp+2,R22
0006ef 9370 0383 	STS  _fs_tmp+3,R23
                 ; 0001 0527   return 0;
                 _0x2020011:
0006f1 e0e0      	LDI  R30,LOW(0)
0006f2 9508      	RET
                 ; 0001 0528 }
                 ;/*
                 ;It is an open source software to implement SD routines to
                 ;small embedded systems. This is a free software and is opened for education,
                 ;research and commercial developments under license policy of following trems.
                 ;
                 ;(C) 2013 vinxru (aleksey.f.morozov@gmail.com)
                 ;
                 ;It is a free software and there is NO WARRANTY.
                 ;No restriction on use. You can use, modify and redistribute it for
                 ;personal, non-profit or commercial use UNDER YOUR RESPONSIBILITY.
                 ;Redistributions of source code must retain the above copyright notice.
                 ;
                 ;Version 0.99 5-05-2013
                 ;*/
                 ;
                 ;#include "common.h"
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include <delay.h>
                 ;#include "sd.h"
                 ;#include "fs.h"
                 ;
                 ;BYTE sd_sdhc; /* Используется SDHC карта */
                 ;
                 ;/**************************************************************************
                 ;*  Протокол SPI для ATMega8                                               *
                 ;*  Может отличаться для разных МК.                                        *
                 ;**************************************************************************/
                 ;
                 ;/* Куда подключена линия CS карты */
                 ;#define SD_CS_ENABLE    PORTB &= ~0x04;
                 ;#define SD_CS_DISABLE   PORTB |= 0x04;
                 ;
                 ;/* Совместимость с разными версиями CodeVisionAVR */
                 ;#ifndef SPI2X
                 ;#define SPI2X 0
                 ;#endif
                 ;
                 ;#define SPI_INIT      { SPCR = 0x52; SPSR = 0x00; }
                 ;#define SPI_HIGHSPEED { SPCR = 0x50; SPSR |= (1<<SPI2X); delay_ms(1); }
                 ;
                 ;static void spi_transmit(BYTE data) {
                 ; 0002 0028 static void spi_transmit(BYTE data) {
                 
                 	.CSEG
                 _spi_transmit_G002:
                 ; 0002 0029   SPDR = data;
                 ;	data -> Y+0
0006f3 81e8      	LD   R30,Y
0006f4 b9ef      	OUT  0xF,R30
                 ; 0002 002A   while((SPSR & 0x80) == 0);
                 _0x40003:
0006f5 9b77      	SBIS 0xE,7
0006f6 cffe      	RJMP _0x40003
                 ; 0002 002B }
                 _0x202000F:
0006f7 9621      	ADIW R28,1
0006f8 9508      	RET
                 ;
                 ;static BYTE spi_receive() {
                 ; 0002 002D static BYTE spi_receive() {
                 _spi_receive_G002:
                 ; 0002 002E   SPDR = 0xFF;
0006f9 efef      	LDI  R30,LOW(255)
0006fa b9ef      	OUT  0xF,R30
                 ; 0002 002F   while((SPSR & 0x80) == 0);
                 _0x40006:
0006fb 9b77      	SBIS 0xE,7
0006fc cffe      	RJMP _0x40006
                 ; 0002 0030   return SPDR;
0006fd b1ef      	IN   R30,0xF
0006fe 9508      	RET
                 ; 0002 0031 }
                 ;
                 ;/**************************************************************************
                 ;*  Отправка команды                                                       *
                 ;**************************************************************************/
                 ;
                 ;/* Используемые каманды SD карты */
                 ;
                 ;#define GO_IDLE_STATE      (0x40 | 0 )
                 ;#define SEND_IF_COND       (0x40 | 8 )
                 ;#define READ_SINGLE_BLOCK  (0x40 | 17)
                 ;#define WRITE_SINGLE_BLOCK (0x40 | 24)
                 ;#define SD_SEND_OP_COND    (0x40 | 41)
                 ;#define APP_CMD            (0x40 | 55)
                 ;#define READ_OCR           (0x40 | 58)
                 ;
                 ;static BYTE sd_sendCommand(BYTE cmd, DWORD arg) {
                 ; 0002 0041 static BYTE sd_sendCommand(BYTE cmd, DWORD arg) {
                 _sd_sendCommand_G002:
                 ; 0002 0042   BYTE response, retry;
                 ; 0002 0043 
                 ; 0002 0044   /* Размещение этого кода тут -4 команды, хотя вроде лишине проверки */
                 ; 0002 0045   if(sd_sdhc == 0 && (cmd==READ_SINGLE_BLOCK || cmd==WRITE_SINGLE_BLOCK))
0006ff d80f      	RCALL __SAVELOCR2
                 ;	cmd -> Y+6
                 ;	arg -> Y+2
                 ;	response -> R17
                 ;	retry -> R16
000700 e0e0      	LDI  R30,LOW(0)
000701 15e9      	CP   R30,R9
000702 f431      	BRNE _0x4000A
000703 81ae      	LDD  R26,Y+6
000704 35a1      	CPI  R26,LOW(0x51)
000705 f011      	BREQ _0x4000B
000706 35a8      	CPI  R26,LOW(0x58)
000707 f409      	BRNE _0x4000A
                 _0x4000B:
000708 c001      	RJMP _0x4000D
                 _0x4000A:
000709 c007      	RJMP _0x40009
                 _0x4000D:
                 ; 0002 0046     arg <<= 9;
                +
00070a 81aa     +LDD R26 , Y + 2
00070b 81bb     +LDD R27 , Y + 2 + 1
00070c 818c     +LDD R24 , Y + 2 + 2
00070d 819d     +LDD R25 , Y + 2 + 3
                 	__GETD2S 2
00070e e0e9      	LDI  R30,LOW(9)
00070f d6f9      	RCALL __LSLD12
000710 d58d      	RCALL SUBOPT_0x50
                 ; 0002 0047 
                 ; 0002 0048   /* Выбираем карту */
                 ; 0002 0049   SD_CS_ENABLE
                 _0x40009:
000711 98c2      	CBI  0x18,2
                 ; 0002 004A 
                 ; 0002 004B   /* Заголовок команды */
                 ; 0002 004C   spi_transmit(cmd);
000712 81ee      	LDD  R30,Y+6
000713 d693      	RCALL SUBOPT_0x80
                 ; 0002 004D   spi_transmit(((BYTE*)&arg)[3]);
000714 81ed      	LDD  R30,Y+5
000715 d691      	RCALL SUBOPT_0x80
                 ; 0002 004E   spi_transmit(((BYTE*)&arg)[2]);
000716 81ec      	LDD  R30,Y+4
000717 d68f      	RCALL SUBOPT_0x80
                 ; 0002 004F   spi_transmit(((BYTE*)&arg)[1]);
000718 81eb      	LDD  R30,Y+3
000719 d68d      	RCALL SUBOPT_0x80
                 ; 0002 0050   spi_transmit(((BYTE*)&arg)[0]);
00071a 81ea      	LDD  R30,Y+2
00071b d68b      	RCALL SUBOPT_0x80
                 ; 0002 0051 
                 ; 0002 0052   /* Пару каоманд требуют CRC. Остальные же команды игнорируют его, поэтому упрощаем код */
                 ; 0002 0053   spi_transmit(cmd == SEND_IF_COND ? 0x87 : 0x95);
00071c 81ae      	LDD  R26,Y+6
00071d 34a8      	CPI  R26,LOW(0x48)
00071e f411      	BRNE _0x4000E
00071f e8e7      	LDI  R30,LOW(135)
000720 c001      	RJMP _0x4000F
                 _0x4000E:
000721 e9e5      	LDI  R30,LOW(149)
                 _0x4000F:
000722 d684      	RCALL SUBOPT_0x80
                 ; 0002 0054 
                 ; 0002 0055   /* Ждем подтвреждение (256 тактов) */
                 ; 0002 0056   retry = 0;
000723 e000      	LDI  R16,LOW(0)
                 ; 0002 0057   while((response = spi_receive()) == 0xFF)
                 _0x40011:
000724 dfd4      	RCALL _spi_receive_G002
000725 2f1e      	MOV  R17,R30
000726 3fef      	CPI  R30,LOW(0xFF)
000727 f419      	BRNE _0x40013
                 ; 0002 0058     if(++retry == 0) break;
000728 5f0f      	SUBI R16,-LOW(1)
000729 3000      	CPI  R16,0
00072a f7c9      	BRNE _0x40011
                 ; 0002 0059 
                 ; 0002 005A   /* Результат команды READ_OCR обрабатываем тут, так как в конце этой функции мы снимем CS и пропускаем 1 байт */
                 ; 0002 005B   if(response == 0 && cmd == READ_OCR) {
                 _0x40013:
00072b 3010      	CPI  R17,0
00072c f419      	BRNE _0x40016
00072d 81ae      	LDD  R26,Y+6
00072e 37aa      	CPI  R26,LOW(0x7A)
00072f f009      	BREQ _0x40017
                 _0x40016:
000730 c006      	RJMP _0x40015
                 _0x40017:
                 ; 0002 005C     /* 32 бита из которых нас интересует один бит */
                 ; 0002 005D     sd_sdhc = spi_receive() & 0x40;
000731 dfc7      	RCALL _spi_receive_G002
000732 74e0      	ANDI R30,LOW(0x40)
000733 2e9e      	MOV  R9,R30
                 ; 0002 005E     spi_receive();
000734 dfc4      	RCALL _spi_receive_G002
                 ; 0002 005F     spi_receive();
000735 dfc3      	RCALL _spi_receive_G002
                 ; 0002 0060     spi_receive();
000736 dfc2      	RCALL _spi_receive_G002
                 ; 0002 0061   }
                 ; 0002 0062 
                 ; 0002 0063   /* отпускаем CS и пауза в 1 байт*/
                 ; 0002 0064   SD_CS_DISABLE
                 _0x40015:
000737 9ac2      	SBI  0x18,2
                 ; 0002 0065   spi_receive();
000738 dfc0      	RCALL _spi_receive_G002
                 ; 0002 0066 
                 ; 0002 0067   return response;
000739 2fe1      	MOV  R30,R17
00073a d7db      	RCALL __LOADLOCR2
00073b 9627      	ADIW R28,7
00073c 9508      	RET
                 ; 0002 0068 }
                 ;
                 ;/**************************************************************************
                 ;*  Проверка готовности/наличия карты                                      *
                 ;**************************************************************************/
                 ;
                 ;BYTE sd_check() {
                 ; 0002 006E BYTE sd_check() {
                 _sd_check:
                 ; 0002 006F   BYTE i = 0;
                 ; 0002 0070   do {
00073d 931a      	ST   -Y,R17
                 ;	i -> R17
00073e e010      	LDI  R17,0
                 _0x40019:
                 ; 0002 0071     sd_sendCommand(APP_CMD, 0);
00073f e7e7      	LDI  R30,LOW(119)
000740 d668      	RCALL SUBOPT_0x81
                 ; 0002 0072     if(sd_sendCommand(SD_SEND_OP_COND, 0x40000000) == 0) return 0;
000741 e6e9      	LDI  R30,LOW(105)
000742 93ea      	ST   -Y,R30
                +
000743 e0e0     +LDI R30 , LOW ( 0x40000000 )
000744 e0f0     +LDI R31 , HIGH ( 0x40000000 )
000745 e060     +LDI R22 , BYTE3 ( 0x40000000 )
000746 e470     +LDI R23 , BYTE4 ( 0x40000000 )
                 	__GETD1N 0x40000000
000747 d665      	RCALL SUBOPT_0x82
000748 f411      	BRNE _0x4001B
000749 e0e0      	LDI  R30,LOW(0)
00074a c20a      	RJMP _0x2020005
                 ; 0002 0073   } while(--i);
                 _0x4001B:
00074b 5011      	SUBI R17,LOW(1)
00074c 3010      	CPI  R17,0
00074d f789      	BRNE _0x40019
                 ; 0002 0074   return 1;
00074e e0e1      	LDI  R30,LOW(1)
00074f c205      	RJMP _0x2020005
                 ; 0002 0075 }
                 ;
                 ;/**************************************************************************
                 ;*  Инициализация карты (эта функция вызывается функцией sd_init)          *
                 ;**************************************************************************/
                 ;
                 ;static BYTE sd_init_int() {
                 ; 0002 007B static BYTE sd_init_int() {
                 _sd_init_int_G002:
                 ; 0002 007C   BYTE i;
                 ; 0002 007D 
                 ; 0002 007E   /* Сбрасываем SDHC флаг */
                 ; 0002 007F   sd_sdhc = 0;
000750 931a      	ST   -Y,R17
                 ;	i -> R17
000751 2499      	CLR  R9
                 ; 0002 0080 
                 ; 0002 0081   /* Минимум 80 пустых тактов */
                 ; 0002 0082   for(i=10; i; --i)
000752 e01a      	LDI  R17,LOW(10)
                 _0x4001D:
000753 3010      	CPI  R17,0
000754 f019      	BREQ _0x4001E
                 ; 0002 0083     spi_receive();
000755 dfa3      	RCALL _spi_receive_G002
000756 5011      	SUBI R17,LOW(1)
000757 cffb      	RJMP _0x4001D
                 _0x4001E:
                 ; 0002 0086 if(sd_sendCommand((0x40 | 0 ), 0) != 1) goto abort;
000758 e4e0      	LDI  R30,LOW(64)
000759 d64f      	RCALL SUBOPT_0x81
00075a 30e1      	CPI  R30,LOW(0x1)
00075b f4a9      	BRNE _0x40020
                 ; 0002 0087 
                 ; 0002 0088   /* CMD8 Узнаем версию карты */
                 ; 0002 0089   i = 0;
00075c e010      	LDI  R17,LOW(0)
                 ; 0002 008A   if(sd_sendCommand(SEND_IF_COND, 0x000001AA))
00075d e4e8      	LDI  R30,LOW(72)
00075e 93ea      	ST   -Y,R30
                +
00075f eaea     +LDI R30 , LOW ( 0x1AA )
000760 e0f1     +LDI R31 , HIGH ( 0x1AA )
000761 e060     +LDI R22 , BYTE3 ( 0x1AA )
000762 e070     +LDI R23 , BYTE4 ( 0x1AA )
                 	__GETD1N 0x1AA
000763 d649      	RCALL SUBOPT_0x82
000764 f009      	BREQ _0x40021
                 ; 0002 008B     i = 1;
000765 e011      	LDI  R17,LOW(1)
                 ; 0002 008C 
                 ; 0002 008D   /* CMD41 Ожидание окончания инициализации */
                 ; 0002 008E   if(sd_check()) goto abort;
                 _0x40021:
000766 dfd6      	RCALL _sd_check
000767 30e0      	CPI  R30,0
000768 f441      	BRNE _0x40020
                 ; 0002 008F 
                 ; 0002 0090   /* Только для второй версии карты */
                 ; 0002 0091   if(i) {
000769 3010      	CPI  R17,0
00076a f021      	BREQ _0x40023
                 ; 0002 0092     /* CMD58 определение SDHC карты. Ответ обрабатывается в функции sd_sendCommand */
                 ; 0002 0093     if(sd_sendCommand(READ_OCR, 0) != 0) goto abort;
00076b e7ea      	LDI  R30,LOW(122)
00076c d63c      	RCALL SUBOPT_0x81
00076d 30e0      	CPI  R30,0
00076e f411      	BRNE _0x40020
                 ; 0002 0094   }
                 ; 0002 0095 
                 ; 0002 0096   return 0;
                 _0x40023:
00076f e0e0      	LDI  R30,LOW(0)
000770 c1e4      	RJMP _0x2020005
                 ; 0002 0097 abort:
                 _0x40020:
                 ; 0002 0098   return 1;
000771 e0e1      	LDI  R30,LOW(1)
000772 c1e2      	RJMP _0x2020005
                 ; 0002 0099 }
                 ;
                 ;/**************************************************************************
                 ;*  Инициализация карты                                                    *
                 ;**************************************************************************/
                 ;
                 ;BYTE sd_init() {
                 ; 0002 009F BYTE sd_init() {
                 _sd_init:
                 ; 0002 00A0   BYTE tries;
                 ; 0002 00A1 
                 ; 0002 00A2   /* Освобождаем CS на всякий случай */
                 ; 0002 00A3   SD_CS_DISABLE
000773 931a      	ST   -Y,R17
                 ;	tries -> R17
000774 9ac2      	SBI  0x18,2
                 ; 0002 00A4 
                 ; 0002 00A5   /* Включаем SPI */
                 ; 0002 00A6   SPI_INIT
000775 e5e2      	LDI  R30,LOW(82)
000776 b9ed      	OUT  0xD,R30
000777 e0e0      	LDI  R30,LOW(0)
000778 b9ee      	OUT  0xE,R30
                 ; 0002 00A7 
                 ; 0002 00A8   /* Делаем несколько попыток инициализации */
                 ; 0002 00A9   tries = 10;
000779 e01a      	LDI  R17,LOW(10)
                 ; 0002 00AA   while(sd_init_int())
                 _0x40025:
00077a dfd5      	RCALL _sd_init_int_G002
00077b 30e0      	CPI  R30,0
00077c f031      	BREQ _0x40027
                 ; 0002 00AB     if(--tries == 0) {
00077d 5011      	SUBI R17,LOW(1)
00077e 3010      	CPI  R17,0
00077f f411      	BRNE _0x40028
                 ; 0002 00AC       lastError = ERR_DISK_ERR;
000780 d630      	RCALL SUBOPT_0x83
                 ; 0002 00AD       return 1;
000781 c1d3      	RJMP _0x2020005
                 ; 0002 00AE     }
                 ; 0002 00AF 
                 ; 0002 00B0   /* Вклчюаем максимальную скорость */
                 ; 0002 00B1   SPI_HIGHSPEED
                 _0x40028:
000782 cff7      	RJMP _0x40025
                 _0x40027:
000783 e5e0      	LDI  R30,LOW(80)
000784 b9ed      	OUT  0xD,R30
000785 9a70      	SBI  0xE,0
000786 e0e1      	LDI  R30,LOW(1)
000787 e0f0      	LDI  R31,HIGH(1)
000788 d62c      	RCALL SUBOPT_0x84
                 ; 0002 00B2 
                 ; 0002 00B3   return 0;
000789 e0e0      	LDI  R30,LOW(0)
00078a c1ca      	RJMP _0x2020005
                 ; 0002 00B4 }
                 ;
                 ;/**************************************************************************
                 ;*  Ожидание определенного байта на шине                                   *
                 ;**************************************************************************/
                 ;
                 ;static BYTE sd_waitBus(BYTE byte) {
                 ; 0002 00BA static BYTE sd_waitBus(BYTE byte) {
                 _sd_waitBus_G002:
                 ; 0002 00BB   WORD retry = 0;
                 ; 0002 00BC   do {
00078b d783      	RCALL __SAVELOCR2
                 ;	byte -> Y+2
                 ;	retry -> R16,R17
                +
00078c e000     +LDI R16 , LOW ( 0 )
00078d e010     +LDI R17 , HIGH ( 0 )
                 	__GETWRN 16,17,0
                 _0x4002A:
                 ; 0002 00BD     if(spi_receive() == byte) return 0;
00078e df6a      	RCALL _spi_receive_G002
00078f 2fae      	MOV  R26,R30
000790 81ea      	LDD  R30,Y+2
000791 17ea      	CP   R30,R26
000792 f419      	BRNE _0x4002C
000793 e0e0      	LDI  R30,LOW(0)
000794 d781      	RCALL __LOADLOCR2
000795 c0ae      	RJMP _0x202000B
                 ; 0002 00BE   } while(++retry);
                 _0x4002C:
000796 01f8      	MOVW R30,R16
000797 9631      	ADIW R30,1
000798 018f      	MOVW R16,R30
000799 f7a1      	BRNE _0x4002A
                 ; 0002 00BF   return 1;
00079a d500      	RCALL SUBOPT_0x4F
00079b c0a8      	RJMP _0x202000B
                 ; 0002 00C0 }
                 ;
                 ;/**************************************************************************
                 ;*  Чтение произвольного участка сектора                                   *
                 ;**************************************************************************/
                 ;
                 ;BYTE sd_read(BYTE* buffer, DWORD sector, WORD offsetInSector, WORD length) {
                 ; 0002 00C6 BYTE sd_read(BYTE* buffer, DWORD sector, WORD offsetInSector, WORD length) {
                 _sd_read:
                 ; 0002 00C7   BYTE b;
                 ; 0002 00C8   WORD i;
                 ; 0002 00C9 
                 ; 0002 00CA   /* Посылаем команду */
                 ; 0002 00CB   if(sd_sendCommand(READ_SINGLE_BLOCK, sector)) goto abort;
00079c d770      	RCALL __SAVELOCR4
                 ;	*buffer -> Y+12
                 ;	sector -> Y+8
                 ;	offsetInSector -> Y+6
                 ;	length -> Y+4
                 ;	b -> R17
                 ;	i -> R18,R19
00079d e5e1      	LDI  R30,LOW(81)
00079e 93ea      	ST   -Y,R30
                +
00079f 85e9     +LDD R30 , Y + 9
0007a0 85fa     +LDD R31 , Y + 9 + 1
0007a1 856b     +LDD R22 , Y + 9 + 2
0007a2 857c     +LDD R23 , Y + 9 + 3
                 	__GETD1S 9
0007a3 d609      	RCALL SUBOPT_0x82
0007a4 f561      	BRNE _0x4002E
                 ; 0002 00CC 
                 ; 0002 00CD   /* Сразу же возращаем CS, что бы принять ответ команды */
                 ; 0002 00CE   SD_CS_ENABLE
0007a5 98c2      	CBI  0x18,2
                 ; 0002 00CF 
                 ; 0002 00D0   /* Ждем стартовый байт */
                 ; 0002 00D1   if(sd_waitBus(0xFE)) goto abort;
0007a6 efee      	LDI  R30,LOW(254)
0007a7 93ea      	ST   -Y,R30
0007a8 dfe2      	RCALL _sd_waitBus_G002
0007a9 30e0      	CPI  R30,0
0007aa f531      	BRNE _0x4002E
                 ; 0002 00D2 
                 ; 0002 00D3   /* Принимаем 512 байт */
                 ; 0002 00D4   for(i=512; i; --i) {
                +
0007ab e020     +LDI R18 , LOW ( 512 )
0007ac e032     +LDI R19 , HIGH ( 512 )
                 	__GETWRN 18,19,512
                 _0x40031:
0007ad 2e02      	MOV  R0,R18
0007ae 2a03      	OR   R0,R19
0007af f0d9      	BREQ _0x40032
                 ; 0002 00D5     b = spi_receive();
0007b0 df48      	RCALL _spi_receive_G002
0007b1 2f1e      	MOV  R17,R30
                 ; 0002 00D6     if(offsetInSector) { offsetInSector--; continue; }
0007b2 d604      	RCALL SUBOPT_0x85
0007b3 9730      	SBIW R30,0
0007b4 f029      	BREQ _0x40033
0007b5 d601      	RCALL SUBOPT_0x85
0007b6 9731      	SBIW R30,1
0007b7 83ee      	STD  Y+6,R30
0007b8 83ff      	STD  Y+6+1,R31
0007b9 c00e      	RJMP _0x40030
                 ; 0002 00D7     if(length == 0) continue;
                 _0x40033:
0007ba d55c      	RCALL SUBOPT_0x67
0007bb 9730      	SBIW R30,0
0007bc f059      	BREQ _0x40030
                 ; 0002 00D8     length--;
0007bd d559      	RCALL SUBOPT_0x67
0007be 9731      	SBIW R30,1
0007bf 83ec      	STD  Y+4,R30
0007c0 83fd      	STD  Y+4+1,R31
                 ; 0002 00D9     *buffer++ = b;
0007c1 85ec      	LDD  R30,Y+12
0007c2 85fd      	LDD  R31,Y+12+1
0007c3 9631      	ADIW R30,1
0007c4 87ec      	STD  Y+12,R30
0007c5 87fd      	STD  Y+12+1,R31
0007c6 9731      	SBIW R30,1
0007c7 8310      	ST   Z,R17
                 ; 0002 00DA   }
                 _0x40030:
                +
0007c8 5021     +SUBI R18 , LOW ( 1 )
0007c9 4030     +SBCI R19 , HIGH ( 1 )
                 	__SUBWRN 18,19,1
0007ca cfe2      	RJMP _0x40031
                 _0x40032:
                 ; 0002 00DB 
                 ; 0002 00DC   /* CRC игнорируем */
                 ; 0002 00DD   spi_receive();
0007cb df2d      	RCALL _spi_receive_G002
                 ; 0002 00DE   spi_receive();
0007cc df2c      	RCALL _spi_receive_G002
                 ; 0002 00DF 
                 ; 0002 00E0   /* отпускаем CS и пауза в 1 байт*/
                 ; 0002 00E1   SD_CS_DISABLE
0007cd 9ac2      	SBI  0x18,2
                 ; 0002 00E2   spi_receive();
0007ce df2a      	RCALL _spi_receive_G002
                 ; 0002 00E3 
                 ; 0002 00E4   /* Ок */
                 ; 0002 00E5   return 0;
0007cf e0e0      	LDI  R30,LOW(0)
0007d0 c002      	RJMP _0x202000D
                 ; 0002 00E6 
                 ; 0002 00E7   /* Ошибка и отпускаем CS.*/
                 ; 0002 00E8 abort:
                 _0x4002E:
                 ; 0002 00E9   SD_CS_DISABLE
0007d1 9ac2      	SBI  0x18,2
                 ; 0002 00EA   lastError = ERR_DISK_ERR;
0007d2 d5de      	RCALL SUBOPT_0x83
                 ; 0002 00EB   return 1;
                 _0x202000D:
0007d3 d740      	RCALL __LOADLOCR4
                 _0x202000E:
0007d4 962e      	ADIW R28,14
0007d5 9508      	RET
                 ; 0002 00EC }
                 ;
                 ;/**************************************************************************
                 ;*  Запись сектора (512 байт)                                              *
                 ;**************************************************************************/
                 ;
                 ;BYTE sd_write512(BYTE* buffer, DWORD sector) {
                 ; 0002 00F2 BYTE sd_write512(BYTE* buffer, DWORD sector) {
                 _sd_write512:
                 ; 0002 00F3   WORD n;
                 ; 0002 00F4 
                 ; 0002 00F5   /* Посылаем команду */
                 ; 0002 00F6   if(sd_sendCommand(WRITE_SINGLE_BLOCK, sector)) goto abort;
0007d6 d738      	RCALL __SAVELOCR2
                 ;	*buffer -> Y+6
                 ;	sector -> Y+2
                 ;	n -> R16,R17
0007d7 e5e8      	LDI  R30,LOW(88)
0007d8 93ea      	ST   -Y,R30
                +
0007d9 81eb     +LDD R30 , Y + 3
0007da 81fc     +LDD R31 , Y + 3 + 1
0007db 816d     +LDD R22 , Y + 3 + 2
0007dc 817e     +LDD R23 , Y + 3 + 3
                 	__GETD1S 3
0007dd d5cf      	RCALL SUBOPT_0x82
0007de f509      	BRNE _0x40036
                 ; 0002 00F7 
                 ; 0002 00F8   /* Сразу же возращаем CS, что бы отправить блок данных */
                 ; 0002 00F9   SD_CS_ENABLE
0007df 98c2      	CBI  0x18,2
                 ; 0002 00FA 
                 ; 0002 00FB   /* Посылаем стартовый байт */
                 ; 0002 00FC   spi_transmit(0xFE);
0007e0 efee      	LDI  R30,LOW(254)
0007e1 d5c5      	RCALL SUBOPT_0x80
                 ; 0002 00FD 
                 ; 0002 00FE   /* Данные */
                 ; 0002 00FF   for(n=512; n; --n)
                +
0007e2 e000     +LDI R16 , LOW ( 512 )
0007e3 e012     +LDI R17 , HIGH ( 512 )
                 	__GETWRN 16,17,512
                 _0x40038:
0007e4 d503      	RCALL SUBOPT_0x61
0007e5 f049      	BREQ _0x40039
                 ; 0002 0100     spi_transmit(*buffer++);
0007e6 81ae      	LDD  R26,Y+6
0007e7 81bf      	LDD  R27,Y+6+1
0007e8 91ed      	LD   R30,X+
0007e9 83ae      	STD  Y+6,R26
0007ea 83bf      	STD  Y+6+1,R27
0007eb d5bb      	RCALL SUBOPT_0x80
                +
0007ec 5001     +SUBI R16 , LOW ( 1 )
0007ed 4010     +SBCI R17 , HIGH ( 1 )
                 	__SUBWRN 16,17,1
0007ee cff5      	RJMP _0x40038
                 _0x40039:
                 ; 0002 0103 spi_transmit(0xFF);
0007ef efef      	LDI  R30,LOW(255)
0007f0 d5b6      	RCALL SUBOPT_0x80
                 ; 0002 0104   spi_transmit(0xFF);
0007f1 efef      	LDI  R30,LOW(255)
0007f2 d5b4      	RCALL SUBOPT_0x80
                 ; 0002 0105 
                 ; 0002 0106   /* Ответ МК */
                 ; 0002 0107   if((spi_receive() & 0x1F) != 0x05) goto abort;
0007f3 df05      	RCALL _spi_receive_G002
0007f4 71ef      	ANDI R30,LOW(0x1F)
0007f5 30e5      	CPI  R30,LOW(0x5)
0007f6 f449      	BRNE _0x40036
                 ; 0002 0108 
                 ; 0002 0109   /* Ждем окончания записи, т.е. пока не освободится шина */
                 ; 0002 010A   if(sd_waitBus(0xFF)) goto abort;
0007f7 efef      	LDI  R30,LOW(255)
0007f8 93ea      	ST   -Y,R30
0007f9 df91      	RCALL _sd_waitBus_G002
0007fa 30e0      	CPI  R30,0
0007fb f421      	BRNE _0x40036
                 ; 0002 010B 
                 ; 0002 010C   /* отпускаем CS и пауза в 1 байт*/
                 ; 0002 010D   SD_CS_DISABLE
0007fc 9ac2      	SBI  0x18,2
                 ; 0002 010E   spi_receive();
0007fd defb      	RCALL _spi_receive_G002
                 ; 0002 010F 
                 ; 0002 0110   /* Ок */
                 ; 0002 0111   return 0;
0007fe e0e0      	LDI  R30,LOW(0)
0007ff c002      	RJMP _0x202000C
                 ; 0002 0112 
                 ; 0002 0113   /* Ошибка.*/
                 ; 0002 0114 abort:
                 _0x40036:
                 ; 0002 0115   SD_CS_DISABLE
000800 9ac2      	SBI  0x18,2
                 ; 0002 0116   lastError = ERR_DISK_ERR;
000801 d5af      	RCALL SUBOPT_0x83
                 ; 0002 0117   return 1;
                 _0x202000C:
000802 d713      	RCALL __LOADLOCR2
000803 9628      	ADIW R28,8
000804 9508      	RET
                 ; 0002 0118 }
                 ;// SD Controller for Computer "Radio 86RK" / "Apogee BK01"
                 ;// (c) 10-05-2014 vinxru (aleksey.f.morozov@gmail.com)
                 ;
                 ;//#include <stdafx.h>
                 ;
                 ;#define F_CPU 8000000UL        //freq 8 MHz
                 ;
                 ;#include "common.h"
                 	#ifndef __SLEEP_DEFINED__
                 	#endif
                 ;#include <string.h>
                 ;#include "sd.h"
                 ;#include "fs.h"
                 ;#include "proto.h"
                 ;
                 ;#ifndef X86_DEBUG
                 ;#include <delay.h>
                 ;#endif
                 ;
                 ;#define O_OPEN   0
                 ;#define O_CREATE 1
                 ;#define O_MKDIR  2
                 ;#define O_DELETE 100
                 ;#define O_SWAP   101
                 ;
                 ;#define ERR_START       0x40
                 ;#define ERR_WAIT        0x41
                 ;#define ERR_OK_DISK         0x42
                 ;#define ERR_OK_CMD          0x43
                 ;#define ERR_OK_READ         0x44
                 ;#define ERR_OK_ENTRY        0x45
                 ;#define ERR_OK_WRITE        0x46
                 ;#define ERR_OK_RKS          0x47
                 ;#define ERR_READ_BLOCK      0x4F
                 ;
                 ;BYTE buf[512];
                 ;BYTE rom[128];
                 ;
                 ;/*******************************************************************************
                 ;* Для удобства                                                                 *
                 ;*******************************************************************************/
                 ;
                 ;void recvBin(BYTE* d, WORD l) {
                 ; 0003 0029 void recvBin(BYTE* d, WORD l) {
                 
                 	.CSEG
                 _recvBin:
                 ; 0003 002A   for(; l; --l) {
                 ;	*d -> Y+2
                 ;	l -> Y+0
                 _0x60004:
000805 d4a7      	RCALL SUBOPT_0x53
000806 9730      	SBIW R30,0
000807 f069      	BREQ _0x60005
                 ; 0003 002B     *d++ = wrecv();
000808 d541      	RCALL SUBOPT_0x72
000809 9631      	ADIW R30,1
00080a 83ea      	STD  Y+2,R30
00080b 83fb      	STD  Y+2+1,R31
00080c 9731      	SBIW R30,1
00080d 93ff      	PUSH R31
00080e 93ef      	PUSH R30
00080f d856      	RCALL _wrecv
000810 91af      	POP  R26
000811 91bf      	POP  R27
000812 93ec      	ST   X,R30
                 ; 0003 002C   }
000813 d5a6      	RCALL SUBOPT_0x86
000814 cff0      	RJMP _0x60004
                 _0x60005:
                 ; 0003 002D }
000815 c19f      	RJMP _0x2020004
                 ;
                 ;void recvString() {
                 ; 0003 002F void recvString() {
                 _recvString:
                 ; 0003 0030   BYTE c;
                 ; 0003 0031   BYTE* p = buf;
                 ; 0003 0032   do {
000816 d6f6      	RCALL __SAVELOCR4
                 ;	c -> R17
                 ;	*p -> R18,R19
                +
000817 e820     +LDI R18 , LOW ( _buf )
000818 e031     +LDI R19 , HIGH ( _buf )
                 	__POINTWRM 18,19,_buf
                 _0x60007:
                 ; 0003 0033     c = wrecv();
000819 d5a5      	RCALL SUBOPT_0x87
                 ; 0003 0034     if(p != buf + FS_MAXFILE) *p++ = c; else lastError = ERR_RECV_STRING;
                +
00081a e5e5     +LDI R30 , LOW ( _buf + ( 469 ) )
00081b e0f3     +LDI R31 , HIGH ( _buf + ( 469 ) )
                 	__POINTW1MN _buf,469
00081c 17e2      	CP   R30,R18
00081d 07f3      	CPC  R31,R19
00081e f049      	BREQ _0x60009
00081f 933f      	PUSH R19
000820 932f      	PUSH R18
                +
000821 5f2f     +SUBI R18 , LOW ( - 1 )
000822 4f3f     +SBCI R19 , HIGH ( - 1 )
                 	__ADDWRN 18,19,1
000823 2fe1      	MOV  R30,R17
000824 91af      	POP  R26
000825 91bf      	POP  R27
000826 93ec      	ST   X,R30
000827 c002      	RJMP _0x6000A
                 _0x60009:
000828 e0eb      	LDI  R30,LOW(11)
000829 d2e7      	RCALL SUBOPT_0xB
                 ; 0003 0035   } while(c);
                 _0x6000A:
00082a 3010      	CPI  R17,0
00082b f769      	BRNE _0x60007
                 ; 0003 0036 }
00082c d6e7      	RCALL __LOADLOCR4
00082d c187      	RJMP _0x2020004
                 ;
                 ;void sendBin(BYTE* p, WORD l) {
                 ; 0003 0038 void sendBin(BYTE* p, WORD l) {
                 _sendBin:
                 ; 0003 0039   for(; l; l--)
                 ;	*p -> Y+2
                 ;	l -> Y+0
                 _0x6000C:
00082e d47e      	RCALL SUBOPT_0x53
00082f 9730      	SBIW R30,0
000830 f041      	BREQ _0x6000D
                 ; 0003 003A     send(*p++);
000831 81aa      	LDD  R26,Y+2
000832 81bb      	LDD  R27,Y+2+1
000833 91ed      	LD   R30,X+
000834 83aa      	STD  Y+2,R26
000835 83bb      	STD  Y+2+1,R27
000836 d58b      	RCALL SUBOPT_0x88
000837 d582      	RCALL SUBOPT_0x86
000838 cff5      	RJMP _0x6000C
                 _0x6000D:
                 ; 0003 003B }
000839 c17b      	RJMP _0x2020004
                 ;
                 ;void sendBinf(flash BYTE* d, BYTE l) {
                 ; 0003 003D void sendBinf(flash BYTE* d, BYTE l) {
                 _sendBinf:
                 ; 0003 003E   for(; l; --l)
                 ;	*d -> Y+1
                 ;	l -> Y+0
                 _0x6000F:
00083a 81e8      	LD   R30,Y
00083b 30e0      	CPI  R30,0
00083c f039      	BREQ _0x60010
                 ; 0003 003F     send(*d++);
00083d d4ce      	RCALL SUBOPT_0x65
00083e 91e4      	LPM  R30,Z
00083f d582      	RCALL SUBOPT_0x88
000840 81e8      	LD   R30,Y
000841 50e1      	SUBI R30,LOW(1)
000842 83e8      	ST   Y,R30
000843 cff6      	RJMP _0x6000F
                 _0x60010:
                 ; 0003 0040 }
                 _0x202000B:
000844 9623      	ADIW R28,3
000845 9508      	RET
                 ;
                 ;/*******************************************************************************
                 ;* Отправка всех блоков файла                                                   *
                 ;*******************************************************************************/
                 ;
                 ;WORD readLength;
                 ;
                 ;void readInt(char rks) {
                 ; 0003 0048 void readInt(char rks) {
                 _readInt:
                 ; 0003 0049   WORD readedLength, lengthFromFile;
                 ; 0003 004A   BYTE tmp;
                 ; 0003 004B   BYTE* wptr;
                 ; 0003 004C 
                 ; 0003 004D   while(readLength) {
000846 9722      	SBIW R28,2
000847 d6c3      	RCALL __SAVELOCR6
                 ;	rks -> Y+8
                 ;	readedLength -> R16,R17
                 ;	lengthFromFile -> R18,R19
                 ;	tmp -> R21
                 ;	*wptr -> Y+6
                 _0x60011:
000848 2c0a      	MOV  R0,R10
000849 280b      	OR   R0,R11
00084a f409      	BRNE PC+2
00084b c066      	RJMP _0x60013
                 ; 0003 004E     // Расчет длины блока (выравниваем чтение на сектор)
                 ; 0003 004F     if(fs_tell()) return;
00084c de94      	RCALL _fs_tell
00084d 30e0      	CPI  R30,0
00084e f009      	BREQ _0x60014
00084f c066      	RJMP _0x2020009
                 ; 0003 0050     readedLength = 512 - (fs_tmp % 512);
                 _0x60014:
000850 d347      	RCALL SUBOPT_0x25
                +
000851 7fef     +ANDI R30 , LOW ( 0x1FF )
000852 70f1     +ANDI R31 , HIGH ( 0x1FF )
000853 7060     +ANDI R22 , BYTE3 ( 0x1FF )
000854 7070     +ANDI R23 , BYTE4 ( 0x1FF )
                 	__ANDD1N 0x1FF
                +
000855 e0a0     +LDI R26 , LOW ( 0x200 )
000856 e0b2     +LDI R27 , HIGH ( 0x200 )
000857 e080     +LDI R24 , BYTE3 ( 0x200 )
000858 e090     +LDI R25 , BYTE4 ( 0x200 )
                 	__GETD2N 0x200
000859 d68c      	RCALL __SWAPD12
00085a d59b      	RCALL __SUBD12
00085b 018f      	MOVW R16,R30
                 ; 0003 0051     if(readedLength > readLength) readedLength = readLength;
                +
00085c 16a0     +CP R10 , R16
00085d 06b1     +CPC R11 , R17
                 	__CPWRR 10,11,16,17
00085e f408      	BRSH _0x60015
00085f 0185      	MOVW R16,R10
                 ; 0003 0052 
                 ; 0003 0053     // Уменьшаем счетчик
                 ; 0003 0054     readLength -= readedLength;
                 _0x60015:
                +
000860 1aa0     +SUB R10 , R16
000861 0ab1     +SBC R11 , R17
                 	__SUBWRR 10,11,16,17
                 ; 0003 0055 
                 ; 0003 0056     // Читаем блок
                 ; 0003 0057     if(fs_read0(buf, readedLength)) return;
000862 d44d      	RCALL SUBOPT_0x54
000863 d472      	RCALL SUBOPT_0x5D
000864 dca8      	RCALL _fs_read0
000865 30e0      	CPI  R30,0
000866 f009      	BREQ _0x60016
000867 c04e      	RJMP _0x2020009
                 ; 0003 0058 
                 ; 0003 0059     // Заголовок RKS файла
                 ; 0003 005A     wptr = buf;
                 _0x60016:
000868 d412      	RCALL SUBOPT_0x47
000869 83ee      	STD  Y+6,R30
00086a 83ff      	STD  Y+6+1,R31
                 ; 0003 005B     if(rks) { // Если rks=1, перед вызовом надо проверить, что бы readLength>4 и fs_file.ptr=0, иначе может быть злостный сбой
00086b d415      	RCALL SUBOPT_0x49
00086c f1a1      	BREQ _0x60017
                 ; 0003 005C       rks = 0;
00086d e0e0      	LDI  R30,LOW(0)
00086e 87e8      	STD  Y+8,R30
                 ; 0003 005D 
                 ; 0003 005E       // У апогея числа перепутаны
                 ; 0003 005F       tmp=buf[0], buf[0]=buf[1]; buf[1]=tmp;
00086f 9150 0180 	LDS  R21,_buf
                +
000871 91e0 0181+LDS R30 , _buf + ( 1 )
                 	__GETB1MN _buf,1
000873 93e0 0180 	STS  _buf,R30
                +
000875 9350 0181+STS _buf + ( 1 ) , R21
                 	__PUTBMRN _buf,1,21
                 ; 0003 0060       tmp=buf[2], buf[2]=buf[3]; buf[3]=tmp;
                +
000877 9150 0182+LDS R21 , _buf + ( 2 )
                 	__GETBRMN 21,_buf,2
                +
000879 91e0 0183+LDS R30 , _buf + ( 3 )
                 	__GETB1MN _buf,3
                +
00087b 93e0 0182+STS _buf + ( 2 ) , R30
                 	__PUTB1MN _buf,2
                +
00087d 9350 0183+STS _buf + ( 3 ) , R21
                 	__PUTBMRN _buf,3,21
                 ; 0003 0061 
                 ; 0003 0062       // Посылаем адрес загрузки
                 ; 0003 0063       send(ERR_OK_RKS);
00087f e4e7      	LDI  R30,LOW(71)
000880 d541      	RCALL SUBOPT_0x88
                 ; 0003 0064       sendBin(buf, 2);
000881 d42e      	RCALL SUBOPT_0x54
000882 d541      	RCALL SUBOPT_0x89
                 ; 0003 0065       send(ERR_WAIT);
000883 d543      	RCALL SUBOPT_0x8A
                 ; 0003 0066 
                 ; 0003 0067       // Корректируем указатели
                 ; 0003 0068       wptr += 4;
000884 d532      	RCALL SUBOPT_0x85
000885 9634      	ADIW R30,4
000886 83ee      	STD  Y+6,R30
000887 83ff      	STD  Y+6+1,R31
                 ; 0003 0069       readedLength -= 4;
                +
000888 5004     +SUBI R16 , LOW ( 4 )
000889 4010     +SBCI R17 , HIGH ( 4 )
                 	__SUBWRN 16,17,4
                 ; 0003 006A 
                 ; 0003 006B       // Длина из файла
                 ; 0003 006C       lengthFromFile = *(WORD*)(buf+2) - *(WORD*)(buf) + 1;
                +
00088a 91e0 0182+LDS R30 , _buf + ( 2 )
00088c 91f0 0183+LDS R31 , _buf + ( 2 ) + 1
                 	__GETW1MN _buf,2
00088e 91a0 0180 	LDS  R26,_buf
000890 91b0 0181 	LDS  R27,_buf+1
000892 1bea      	SUB  R30,R26
000893 0bfb      	SBC  R31,R27
000894 9631      	ADIW R30,1
000895 019f      	MOVW R18,R30
                 ; 0003 006D 
                 ; 0003 006E       // Корректируем длину
                 ; 0003 006F       if(readedLength > lengthFromFile) {
                +
000896 1720     +CP R18 , R16
000897 0731     +CPC R19 , R17
                 	__CPWRR 18,19,16,17
000898 f410      	BRSH _0x60018
                 ; 0003 0070         readedLength = lengthFromFile;
000899 0189      	MOVW R16,R18
                 ; 0003 0071       } else {
00089a c006      	RJMP _0x60019
                 _0x60018:
                 ; 0003 0072         lengthFromFile -= readedLength;
                +
00089b 1b20     +SUB R18 , R16
00089c 0b31     +SBC R19 , R17
                 	__SUBWRR 18,19,16,17
                 ; 0003 0073         if(readLength > lengthFromFile) lengthFromFile = readedLength;
                +
00089d 152a     +CP R18 , R10
00089e 053b     +CPC R19 , R11
                 	__CPWRR 18,19,10,11
00089f f408      	BRSH _0x6001A
0008a0 0198      	MOVW R18,R16
                 ; 0003 0074       }
                 _0x6001A:
                 _0x60019:
                 ; 0003 0075     }
                 ; 0003 0076 
                 ; 0003 0077     // Отправляем блок
                 ; 0003 0078     send(ERR_READ_BLOCK);
                 _0x60017:
0008a1 e4ef      	LDI  R30,LOW(79)
0008a2 d51f      	RCALL SUBOPT_0x88
                 ; 0003 0079     sendBin((BYTE*)&readedLength, 2);
0008a3 b7ed      	IN   R30,SPL
0008a4 b7fe      	IN   R31,SPH
0008a5 9731      	SBIW R30,1
0008a6 d241      	RCALL SUBOPT_0x2
0008a7 931f      	PUSH R17
0008a8 930f      	PUSH R16
0008a9 d51a      	RCALL SUBOPT_0x89
0008aa 910f      	POP  R16
0008ab 911f      	POP  R17
                 ; 0003 007A     sendBin(wptr, readedLength);
0008ac d50a      	RCALL SUBOPT_0x85
0008ad d23a      	RCALL SUBOPT_0x2
0008ae d427      	RCALL SUBOPT_0x5D
0008af df7e      	RCALL _sendBin
                 ; 0003 007B     send(ERR_WAIT);
0008b0 d516      	RCALL SUBOPT_0x8A
                 ; 0003 007C   }
0008b1 cf96      	RJMP _0x60011
                 _0x60013:
                 ; 0003 007D 
                 ; 0003 007E   // Если все ОК
                 ; 0003 007F   if(!lastError) lastError = ERR_OK_READ;
0008b2 d516      	RCALL SUBOPT_0x8B
0008b3 f411      	BRNE _0x6001B
0008b4 e4e4      	LDI  R30,LOW(68)
0008b5 d25b      	RCALL SUBOPT_0xB
                 ; 0003 0080 }
                 _0x6001B:
                 _0x2020009:
0008b6 d65b      	RCALL __LOADLOCR6
                 _0x202000A:
0008b7 9629      	ADIW R28,9
0008b8 9508      	RET
                 ;
                 ;/*******************************************************************************
                 ;* Версия команд контроллера                                                    *
                 ;*******************************************************************************/
                 ;
                 ;void cmd_ver() {
                 ; 0003 0086 void cmd_ver() {
                 _cmd_ver:
                 ; 0003 0087   sendStart(1);
0008b9 d46c      	RCALL SUBOPT_0x6B
0008ba d79e      	RCALL _sendStart
                 ; 0003 0088 
                 ; 0003 0089   // Версия + Производитель
                 ; 0003 008A   sendBinf("V1.0 10-05-2014 ", 16);
                +
0008bb e3e6     +LDI R30 , LOW ( 2 * _0x60000 + ( 0 ) )
0008bc e0f0     +LDI R31 , HIGH ( 2 * _0x60000 + ( 0 ) )
                 	__POINTW1FN _0x60000,0
0008bd d22a      	RCALL SUBOPT_0x2
0008be e1e0      	LDI  R30,LOW(16)
0008bf 93ea      	ST   -Y,R30
0008c0 df79      	RCALL _sendBinf
                 ; 0003 008B               //0123456789ABCDEF
                 ; 0003 008C }
0008c1 9508      	RET
                 ;
                 ;/*******************************************************************************
                 ;* BOOT / EXEC                                                                  *
                 ;*******************************************************************************/
                 ;
                 ;void cmd_boot_exec() {
                 ; 0003 0092 void cmd_boot_exec() {
                 _cmd_boot_exec:
                 ; 0003 0093   // Файл по умолчанию
                 ; 0003 0094   if(buf[0]==0) strcpyf(buf, "boot/sdbios.rk");
0008c2 91e0 0180 	LDS  R30,_buf
0008c4 30e0      	CPI  R30,0
0008c5 f429      	BRNE _0x6001C
0008c6 d3e9      	RCALL SUBOPT_0x54
                +
0008c7 e4e7     +LDI R30 , LOW ( 2 * _0x60000 + ( 17 ) )
0008c8 e0f0     +LDI R31 , HIGH ( 2 * _0x60000 + ( 17 ) )
                 	__POINTW1FN _0x60000,17
0008c9 d21e      	RCALL SUBOPT_0x2
0008ca d205      	RCALL _strcpyf
                 ; 0003 0095 
                 ; 0003 0096   // Открываем файл
                 ; 0003 0097   if(fs_open()) return;
                 _0x6001C:
0008cb dbf9      	RCALL _fs_open
0008cc 30e0      	CPI  R30,0
0008cd f009      	BREQ _0x6001D
0008ce 9508      	RET
                 ; 0003 0098 
                 ; 0003 0099   // Максимальный размер файла
                 ; 0003 009A   readLength = 0xFFFF;
                 _0x6001D:
0008cf efef      	LDI  R30,LOW(65535)
0008d0 efff      	LDI  R31,HIGH(65535)
0008d1 015f      	MOVW R10,R30
                 ; 0003 009B   if(fs_getfilesize()) return;
0008d2 d4fa      	RCALL SUBOPT_0x8C
0008d3 f009      	BREQ _0x6001E
0008d4 9508      	RET
                 ; 0003 009C   if(readLength > fs_tmp) readLength = (WORD)fs_tmp;
                 _0x6001E:
0008d5 d2c2      	RCALL SUBOPT_0x25
0008d6 d4f9      	RCALL SUBOPT_0x8D
0008d7 f420      	BRSH _0x6001F
                +
0008d8 90a0 0380+LDS R10 , 0 + ( _fs_tmp )
0008da 90b0 0381+LDS R11 , 0 + ( _fs_tmp ) + 1
                 	__GETWRMN 10,11,0,_fs_tmp
                 ; 0003 009D 
                 ; 0003 009E   // Файлы RK должны быть длиной >4 байт. Мы заносим в readLength = 0 и программа
                 ; 0003 009F   // получает ERR_OK. Но так как она ждем ERR_OK_RKS, это будет ошибкой
                 ; 0003 00A0   if(readLength < 4) readLength = 0;
                 _0x6001F:
0008dc e0e4      	LDI  R30,LOW(4)
0008dd e0f0      	LDI  R31,HIGH(4)
0008de 16ae      	CP   R10,R30
0008df 06bf      	CPC  R11,R31
0008e0 f410      	BRSH _0x60020
0008e1 24aa      	CLR  R10
0008e2 24bb      	CLR  R11
                 ; 0003 00A1 
                 ; 0003 00A2   readInt(/*rks*/1);
                 _0x60020:
0008e3 d442      	RCALL SUBOPT_0x6B
0008e4 df61      	RCALL _readInt
                 ; 0003 00A3 }
0008e5 9508      	RET
                 ;
                 ;void cmd_boot() {
                 ; 0003 00A5 void cmd_boot() {
                 _cmd_boot:
                 ; 0003 00A6   sendStart(ERR_WAIT);
0008e6 d4ee      	RCALL SUBOPT_0x8E
                 ; 0003 00A7   buf[0] = 0;
0008e7 e0e0      	LDI  R30,LOW(0)
0008e8 93e0 0180 	STS  _buf,R30
                 ; 0003 00A8   cmd_boot_exec();
0008ea c004      	RJMP _0x2020008
                 ; 0003 00A9 }
                 ;
                 ;void cmd_exec() {
                 ; 0003 00AB void cmd_exec() {
                 _cmd_exec:
                 ; 0003 00AC   // Прием имени файла
                 ; 0003 00AD   recvString();
0008eb d4ec      	RCALL SUBOPT_0x8F
                 ; 0003 00AE 
                 ; 0003 00AF   // Режим передачи и подтверждение
                 ; 0003 00B0   sendStart(ERR_WAIT);
                 ; 0003 00B1   if(lastError) return; // Переполнение строки
0008ec d4dc      	RCALL SUBOPT_0x8B
0008ed f009      	BREQ _0x60021
0008ee 9508      	RET
                 ; 0003 00B2 
                 ; 0003 00B3   cmd_boot_exec();
                 _0x60021:
                 _0x2020008:
0008ef dfd2      	RCALL _cmd_boot_exec
                 ; 0003 00B4 }
0008f0 9508      	RET
                 ;
                 ;/*******************************************************************************
                 ;* Начать/продолжить посик файлов в папке                                       *
                 ;*******************************************************************************/
                 ;
                 ;typedef struct {
                 ;    char    fname[11];    // File name
                 ;    BYTE    fattrib;    // Attribute
                 ;    DWORD   fsize;        // File size
                 ;    union {
                 ;      struct {
                 ;        WORD    ftime;        // Last modified time
                 ;        WORD    fdate;        // Last modified date
                 ;      };
                 ;      DWORD ftimedate;
                 ;    };
                 ;} FILINFO2;
                 ;
                 ;void cmd_find() {
                 ; 0003 00C7 void cmd_find() {
                 _cmd_find:
                 ; 0003 00C8   WORD n;
                 ; 0003 00C9   FILINFO2 info;
                 ; 0003 00CA 
                 ; 0003 00CB   // Принимаем путь
                 ; 0003 00CC   recvString();
0008f1 9764      	SBIW R28,20
0008f2 d61c      	RCALL __SAVELOCR2
                 ;	n -> R16,R17
                 ;	info -> Y+2
0008f3 df22      	RCALL _recvString
                 ; 0003 00CD 
                 ; 0003 00CE   // Принимаем макс кол-во элементов
                 ; 0003 00CF   recvBin((BYTE*)&n, 2);
0008f4 b7ed      	IN   R30,SPL
0008f5 b7fe      	IN   R31,SPH
0008f6 9731      	SBIW R30,1
0008f7 d1f0      	RCALL SUBOPT_0x2
0008f8 931f      	PUSH R17
0008f9 930f      	PUSH R16
0008fa d4df      	RCALL SUBOPT_0x90
0008fb 910f      	POP  R16
0008fc 911f      	POP  R17
                 ; 0003 00D0 
                 ; 0003 00D1   // Режим передачи и подтверждение
                 ; 0003 00D2   sendStart(ERR_WAIT);
0008fd d4d7      	RCALL SUBOPT_0x8E
                 ; 0003 00D3   if(lastError) return;
0008fe d4ca      	RCALL SUBOPT_0x8B
0008ff f5c1      	BRNE _0x2020007
                 ; 0003 00D4 
                 ; 0003 00D5   // Открываем папку
                 ; 0003 00D6   if(buf[0] != ':') {
000900 91a0 0180 	LDS  R26,_buf
000902 33aa      	CPI  R26,LOW(0x3A)
000903 f019      	BREQ _0x60023
                 ; 0003 00D7     if(fs_opendir()) return;
000904 dbca      	RCALL _fs_opendir
000905 30e0      	CPI  R30,0
000906 f589      	BRNE _0x2020007
                 ; 0003 00D8   }
                 ; 0003 00D9 
                 ; 0003 00DA   for(; n; --n) {
                 _0x60023:
                 _0x60026:
000907 d3e0      	RCALL SUBOPT_0x61
000908 f161      	BREQ _0x60027
                 ; 0003 00DB     /* Читаем очереной описатель */
                 ; 0003 00DC     if(fs_readdir()) return;
000909 d952      	RCALL _fs_readdir
00090a 30e0      	CPI  R30,0
00090b f561      	BRNE _0x2020007
                 ; 0003 00DD 
                 ; 0003 00DE     /* Конец */
                 ; 0003 00DF     if(FS_DIRENTRY[0] == 0) {
00090c d343      	RCALL SUBOPT_0x3E
00090d f411      	BRNE _0x60029
                 ; 0003 00E0       lastError = ERR_OK_CMD;
00090e e4e3      	LDI  R30,LOW(67)
00090f c026      	RJMP _0x2020006
                 ; 0003 00E1       return;
                 ; 0003 00E2     }
                 ; 0003 00E3 
                 ; 0003 00E4     /* Сжимаем ответ для компьютера */
                 ; 0003 00E5     memcpy(info.fname, FS_DIRENTRY+DIR_Name, 12);
                 _0x60029:
000910 01fe      	MOVW R30,R28
000911 9632      	ADIW R30,2
000912 d1d5      	RCALL SUBOPT_0x2
000913 d32b      	RCALL SUBOPT_0x3B
000914 e0ec      	LDI  R30,LOW(12)
000915 e0f0      	LDI  R31,HIGH(12)
000916 d1d1      	RCALL SUBOPT_0x2
000917 d19a      	RCALL _memcpy
                 ; 0003 00E6     memcpy(&info.fsize, FS_DIRENTRY+DIR_FileSize, 4);
000918 01fe      	MOVW R30,R28
000919 963e      	ADIW R30,14
00091a d1cd      	RCALL SUBOPT_0x2
                +
00091b e7ec     +LDI R30 , LOW ( _buf + ( 508 ) )
00091c e0f3     +LDI R31 , HIGH ( _buf + ( 508 ) )
                 	__POINTW1MN _buf,508
00091d d28e      	RCALL SUBOPT_0x28
00091e d1c9      	RCALL SUBOPT_0x2
00091f d192      	RCALL _memcpy
                 ; 0003 00E7     memcpy(&info.ftimedate, FS_DIRENTRY+DIR_WrtTime, 4);
000920 01fe      	MOVW R30,R28
000921 9672      	ADIW R30,18
000922 d1c5      	RCALL SUBOPT_0x2
                +
000923 e7e6     +LDI R30 , LOW ( _buf + ( 502 ) )
000924 e0f3     +LDI R31 , HIGH ( _buf + ( 502 ) )
                 	__POINTW1MN _buf,502
000925 d286      	RCALL SUBOPT_0x28
000926 d1c1      	RCALL SUBOPT_0x2
000927 d18a      	RCALL _memcpy
                 ; 0003 00E8     //memcpy(memcpy(memcpy(info.fname, FS_DIRENTRY+DIR_Name, 12, FS_DIRENTRY+DIR_FileSize, 4), FS_DIRENTRY+DIR_WrtTime, 4);
                 ; 0003 00E9 
                 ; 0003 00EA     /* Отправляем */
                 ; 0003 00EB     send(ERR_OK_ENTRY);
000928 e4e5      	LDI  R30,LOW(69)
000929 d498      	RCALL SUBOPT_0x88
                 ; 0003 00EC     sendBin((BYTE*)&info, sizeof(info));
00092a 01fe      	MOVW R30,R28
00092b 9632      	ADIW R30,2
00092c d1bb      	RCALL SUBOPT_0x2
00092d e1e4      	LDI  R30,LOW(20)
00092e e0f0      	LDI  R31,HIGH(20)
00092f d1b8      	RCALL SUBOPT_0x2
000930 defd      	RCALL _sendBin
                 ; 0003 00ED     send(ERR_WAIT);
000931 d495      	RCALL SUBOPT_0x8A
                 ; 0003 00EE   }
                +
000932 5001     +SUBI R16 , LOW ( 1 )
000933 4010     +SBCI R17 , HIGH ( 1 )
                 	__SUBWRN 16,17,1
000934 cfd2      	RJMP _0x60026
                 _0x60027:
                 ; 0003 00EF 
                 ; 0003 00F0   /* Ограничение по размеру */
                 ; 0003 00F1   lastError = ERR_MAX_FILES; /*! Надо опеределать, что бы не было ложных ошибок */
000935 e0ea      	LDI  R30,LOW(10)
                 _0x2020006:
000936 93e0 0384 	STS  _lastError,R30
                 ; 0003 00F2 }
                 _0x2020007:
000938 d5dd      	RCALL __LOADLOCR2
000939 9666      	ADIW R28,22
00093a 9508      	RET
                 ;
                 ;/*******************************************************************************
                 ;* Открыть/создать файл/папку                                                   *
                 ;*******************************************************************************/
                 ;
                 ;void cmd_open() {
                 ; 0003 00F8 void cmd_open() {
                 _cmd_open:
                 ; 0003 00F9   BYTE mode;
                 ; 0003 00FA 
                 ; 0003 00FB   /* Принимаем режим */
                 ; 0003 00FC   mode = wrecv();
00093b 931a      	ST   -Y,R17
                 ;	mode -> R17
00093c d482      	RCALL SUBOPT_0x87
                 ; 0003 00FD 
                 ; 0003 00FE   // Принимаем имя файла
                 ; 0003 00FF   recvString();
00093d d49a      	RCALL SUBOPT_0x8F
                 ; 0003 0100 
                 ; 0003 0101   // Режим передачи и подтверждение
                 ; 0003 0102   sendStart(ERR_WAIT);
                 ; 0003 0103 
                 ; 0003 0104   // Открываем/создаем файл/папку
                 ; 0003 0105   if(mode == O_SWAP) {
00093e 3615      	CPI  R17,101
00093f f411      	BRNE _0x6002A
                 ; 0003 0106     fs_swap();
000940 dd71      	RCALL _fs_swap
                 ; 0003 0107   } else
000941 c00f      	RJMP _0x6002B
                 _0x6002A:
                 ; 0003 0108   if(mode == O_DELETE) {
000942 3614      	CPI  R17,100
000943 f411      	BRNE _0x6002C
                 ; 0003 0109     fs_delete();
000944 dd24      	RCALL _fs_delete
                 ; 0003 010A   } else
000945 c00b      	RJMP _0x6002D
                 _0x6002C:
                 ; 0003 010B   if(mode == O_OPEN) {
000946 3010      	CPI  R17,0
000947 f411      	BRNE _0x6002E
                 ; 0003 010C     fs_open();
000948 db7c      	RCALL _fs_open
                 ; 0003 010D   } else
000949 c007      	RJMP _0x6002F
                 _0x6002E:
                 ; 0003 010E   if(mode < 3) {
00094a 3013      	CPI  R17,3
00094b f418      	BRSH _0x60030
                 ; 0003 010F     fs_open0(mode);
00094c 931a      	ST   -Y,R17
00094d da21      	RCALL _fs_open0
                 ; 0003 0110   } else {
00094e c002      	RJMP _0x60031
                 _0x60030:
                 ; 0003 0111     lastError = ERR_INVALID_COMMAND;
00094f e0ec      	LDI  R30,LOW(12)
000950 d1c0      	RCALL SUBOPT_0xB
                 ; 0003 0112   }
                 _0x60031:
                 _0x6002F:
                 _0x6002D:
                 _0x6002B:
                 ; 0003 0113 
                 ; 0003 0114   // Ок
                 ; 0003 0115   if(!lastError) lastError = ERR_OK_CMD;
000951 d477      	RCALL SUBOPT_0x8B
000952 f411      	BRNE _0x60032
000953 e4e3      	LDI  R30,LOW(67)
000954 d1bc      	RCALL SUBOPT_0xB
                 ; 0003 0116 }
                 _0x60032:
                 _0x2020005:
000955 9119      	LD   R17,Y+
000956 9508      	RET
                 ;
                 ;/*******************************************************************************
                 ;* Переместить файл/папку                                                       *
                 ;*******************************************************************************/
                 ;
                 ;void cmd_move() {
                 ; 0003 011C void cmd_move() {
                 _cmd_move:
                 ; 0003 011D   recvString();
000957 d480      	RCALL SUBOPT_0x8F
                 ; 0003 011E   sendStart(ERR_WAIT);
                 ; 0003 011F   fs_openany();
000958 d359      	RCALL SUBOPT_0x55
000959 da15      	RCALL _fs_open0
                 ; 0003 0120   sendStart(ERR_OK_WRITE);
00095a e4e6      	LDI  R30,LOW(70)
00095b 93ea      	ST   -Y,R30
00095c d6fc      	RCALL _sendStart
                 ; 0003 0121   recvStart();
00095d d702      	RCALL _recvStart
                 ; 0003 0122   recvString();
00095e d479      	RCALL SUBOPT_0x8F
                 ; 0003 0123   sendStart(ERR_WAIT);
                 ; 0003 0124   if(!lastError) fs_move0();
00095f d469      	RCALL SUBOPT_0x8B
000960 f409      	BRNE _0x60033
000961 dcb8      	RCALL _fs_move0
                 ; 0003 0125   if(!lastError) lastError = ERR_OK_CMD;
                 _0x60033:
000962 d466      	RCALL SUBOPT_0x8B
000963 f411      	BRNE _0x60034
000964 e4e3      	LDI  R30,LOW(67)
000965 d1ab      	RCALL SUBOPT_0xB
                 ; 0003 0126 }
                 _0x60034:
000966 9508      	RET
                 ;
                 ;/*******************************************************************************
                 ;* Установить/прочитать указатель чтения                                        *
                 ;*******************************************************************************/
                 ;
                 ;void cmd_lseek() {
                 ; 0003 012C void cmd_lseek() {
                 _cmd_lseek:
                 ; 0003 012D   BYTE mode;
                 ; 0003 012E   DWORD off;
                 ; 0003 012F 
                 ; 0003 0130   // Принимаем режим и смещение
                 ; 0003 0131   mode = wrecv();
000967 9724      	SBIW R28,4
000968 931a      	ST   -Y,R17
                 ;	mode -> R17
                 ;	off -> Y+1
000969 d455      	RCALL SUBOPT_0x87
                 ; 0003 0132   recvBin((BYTE*)&off, 4);
00096a 01fe      	MOVW R30,R28
00096b 9631      	ADIW R30,1
00096c d23f      	RCALL SUBOPT_0x28
00096d d17a      	RCALL SUBOPT_0x2
00096e de96      	RCALL _recvBin
                 ; 0003 0133 
                 ; 0003 0134   // Режим передачи и подтверждение
                 ; 0003 0135   sendStart(ERR_WAIT);
00096f d465      	RCALL SUBOPT_0x8E
                 ; 0003 0136 
                 ; 0003 0137   // Размер файла
                 ; 0003 0138   if(mode==100) {
000970 3614      	CPI  R17,100
000971 f429      	BRNE _0x60035
                 ; 0003 0139     if(fs_getfilesize()) return;
000972 d45a      	RCALL SUBOPT_0x8C
000973 f011      	BREQ _0x60036
000974 8118      	LDD  R17,Y+0
000975 c158      	RJMP _0x2020001
                 ; 0003 013A   }
                 _0x60036:
                 ; 0003 013B 
                 ; 0003 013C   // Размер диска
                 ; 0003 013D   else if(mode==101) {
000976 c01b      	RJMP _0x60037
                 _0x60035:
000977 3615      	CPI  R17,101
000978 f431      	BRNE _0x60038
                 ; 0003 013E     if(fs_gettotal()) return;
000979 dd5a      	RCALL _fs_gettotal
00097a 30e0      	CPI  R30,0
00097b f011      	BREQ _0x60039
00097c 8118      	LDD  R17,Y+0
00097d c150      	RJMP _0x2020001
                 ; 0003 013F   }
                 _0x60039:
                 ; 0003 0140 
                 ; 0003 0141   // Свободное место на диске
                 ; 0003 0142   else if(mode==102) {
00097e c013      	RJMP _0x6003A
                 _0x60038:
00097f 3616      	CPI  R17,102
000980 f431      	BRNE _0x6003B
                 ; 0003 0143     if(fs_getfree()) return;
000981 dd48      	RCALL _fs_getfree
000982 30e0      	CPI  R30,0
000983 f011      	BREQ _0x6003C
000984 8118      	LDD  R17,Y+0
000985 c148      	RJMP _0x2020001
                 ; 0003 0144   }
                 _0x6003C:
                 ; 0003 0145 
                 ; 0003 0146   else {
000986 c00b      	RJMP _0x6003D
                 _0x6003B:
                 ; 0003 0147     /* Устаналиваем смещение. fs_tmp сохраняется */
                 ; 0003 0148     if(fs_lseek(off, mode)) return;
                +
000987 81e9     +LDD R30 , Y + 1
000988 81fa     +LDD R31 , Y + 1 + 1
000989 816b     +LDD R22 , Y + 1 + 2
00098a 817c     +LDD R23 , Y + 1 + 3
                 	__GETD1S 1
00098b d555      	RCALL __PUTPARD1
00098c 931a      	ST   -Y,R17
00098d dbd8      	RCALL _fs_lseek
00098e 30e0      	CPI  R30,0
00098f f011      	BREQ _0x6003E
000990 8118      	LDD  R17,Y+0
000991 c13c      	RJMP _0x2020001
                 ; 0003 0149   }
                 _0x6003E:
                 _0x6003D:
                 _0x6003A:
                 _0x60037:
                 ; 0003 014A 
                 ; 0003 014B   // Передаем результат
                 ; 0003 014C   send(ERR_OK_CMD);
000992 e4e3      	LDI  R30,LOW(67)
000993 d42e      	RCALL SUBOPT_0x88
                 ; 0003 014D   sendBin((BYTE*)&fs_tmp, 4);
000994 e8e0      	LDI  R30,LOW(_fs_tmp)
000995 e0f3      	LDI  R31,HIGH(_fs_tmp)
000996 d215      	RCALL SUBOPT_0x28
000997 d150      	RCALL SUBOPT_0x2
000998 de95      	RCALL _sendBin
                 ; 0003 014E   lastError = 0; // На всякий случай, результат уже передан
000999 e0e0      	LDI  R30,LOW(0)
00099a d176      	RCALL SUBOPT_0xB
                 ; 0003 014F }
00099b 8118      	LDD  R17,Y+0
00099c c131      	RJMP _0x2020001
                 ;
                 ;/*******************************************************************************
                 ;* Прочитать из файла                                                           *
                 ;*******************************************************************************/
                 ;
                 ;void cmd_read() {
                 ; 0003 0155 void cmd_read() {
                 _cmd_read:
                 ; 0003 0156   DWORD s;
                 ; 0003 0157 
                 ; 0003 0158   // Длина
                 ; 0003 0159   recvBin((BYTE*)&readLength, 2);
00099d 9724      	SBIW R28,4
                 ;	s -> Y+0
00099e e0ea      	LDI  R30,LOW(10)
00099f e0f0      	LDI  R31,HIGH(10)
0009a0 d147      	RCALL SUBOPT_0x2
0009a1 d438      	RCALL SUBOPT_0x90
                 ; 0003 015A 
                 ; 0003 015B   // Режим передачи и подтверждение
                 ; 0003 015C   sendStart(ERR_WAIT);
0009a2 d432      	RCALL SUBOPT_0x8E
                 ; 0003 015D 
                 ; 0003 015E   // Ограничиваем длину длиной файла
                 ; 0003 015F   if(fs_getfilesize()) return;
0009a3 d429      	RCALL SUBOPT_0x8C
0009a4 f481      	BRNE _0x2020004
                 ; 0003 0160   s = fs_tmp;
0009a5 d1f2      	RCALL SUBOPT_0x25
0009a6 d17f      	RCALL SUBOPT_0x11
                 ; 0003 0161   if(fs_tell()) return;
0009a7 dd39      	RCALL _fs_tell
0009a8 30e0      	CPI  R30,0
0009a9 f459      	BRNE _0x2020004
                 ; 0003 0162   s -= fs_tmp;
0009aa d205      	RCALL SUBOPT_0x29
0009ab d178      	RCALL SUBOPT_0x10
0009ac d449      	RCALL __SUBD12
0009ad d178      	RCALL SUBOPT_0x11
                 ; 0003 0163 
                 ; 0003 0164   if(readLength > s)
0009ae d175      	RCALL SUBOPT_0x10
0009af d420      	RCALL SUBOPT_0x8D
0009b0 f410      	BRSH _0x60041
                 ; 0003 0165     readLength = (WORD)s;
                +
0009b1 80a8     +LDD R10 , Y + 0
0009b2 80b9     +LDD R11 , Y + 0 + 1
                 	__GETWRS 10,11,0
                 ; 0003 0166 
                 ; 0003 0167   // Отправляем все блоки файла
                 ; 0003 0168   readInt(/*rks*/0);
                 _0x60041:
0009b3 d2fe      	RCALL SUBOPT_0x55
0009b4 de91      	RCALL _readInt
                 ; 0003 0169 }
                 _0x2020004:
0009b5 9624      	ADIW R28,4
0009b6 9508      	RET
                 ;
                 ;/*******************************************************************************
                 ;* Записать данные в файл                                                       *
                 ;*******************************************************************************/
                 ;
                 ;void cmd_write() {
                 ; 0003 016F void cmd_write() {
                 _cmd_write:
                 ; 0003 0170   // Аргументы
                 ; 0003 0171   recvBin((BYTE*)&fs_wtotal, 2);
0009b7 e8e5      	LDI  R30,LOW(_fs_wtotal)
0009b8 e0f3      	LDI  R31,HIGH(_fs_wtotal)
0009b9 d12e      	RCALL SUBOPT_0x2
0009ba d41f      	RCALL SUBOPT_0x90
                 ; 0003 0172 
                 ; 0003 0173   // Ответ
                 ; 0003 0174   sendStart(ERR_WAIT);
0009bb d419      	RCALL SUBOPT_0x8E
                 ; 0003 0175 
                 ; 0003 0176   // Конец файла
                 ; 0003 0177   if(fs_wtotal==0) {
0009bc d3d8      	RCALL SUBOPT_0x7D
0009bd 9730      	SBIW R30,0
0009be f411      	BRNE _0x60042
                 ; 0003 0178     fs_write_eof();
0009bf dcd6      	RCALL _fs_write_eof
                 ; 0003 0179     lastError = ERR_OK_CMD;
0009c0 c01c      	RJMP _0x2020003
                 ; 0003 017A     return;
                 ; 0003 017B   }
                 ; 0003 017C 
                 ; 0003 017D   // Запись данных
                 ; 0003 017E   do {
                 _0x60042:
                 _0x60044:
                 ; 0003 017F     if(fs_write_start()) return;
0009c1 dbe7      	RCALL _fs_write_start
0009c2 30e0      	CPI  R30,0
0009c3 f009      	BREQ _0x60046
0009c4 9508      	RET
                 ; 0003 0180 
                 ; 0003 0181     // Принимаем от компьюетра блок данных
                 ; 0003 0182     send(ERR_OK_WRITE);
                 _0x60046:
0009c5 e4e6      	LDI  R30,LOW(70)
0009c6 d3fb      	RCALL SUBOPT_0x88
                 ; 0003 0183     sendBin((BYTE*)&fs_file_wlen, 2);
0009c7 e8e0      	LDI  R30,LOW(_fs_tmp)
0009c8 e0f3      	LDI  R31,HIGH(_fs_tmp)
0009c9 d11e      	RCALL SUBOPT_0x2
0009ca d3f9      	RCALL SUBOPT_0x89
                 ; 0003 0184     recvStart();
0009cb d694      	RCALL _recvStart
                 ; 0003 0185     recvBin(fs_file_wbuf, fs_file_wlen);
                +
0009cc 91e0 0382+LDS R30 , _fs_tmp + ( 2 )
0009ce 91f0 0383+LDS R31 , _fs_tmp + ( 2 ) + 1
                 	__GETW1MN _fs_tmp,2
0009d0 d2e6      	RCALL SUBOPT_0x57
0009d1 d116      	RCALL SUBOPT_0x2
0009d2 d2d0      	RCALL SUBOPT_0x51
0009d3 d114      	RCALL SUBOPT_0x2
0009d4 de30      	RCALL _recvBin
                 ; 0003 0186     sendStart(ERR_WAIT);
0009d5 d3ff      	RCALL SUBOPT_0x8E
                 ; 0003 0187 
                 ; 0003 0188     if(fs_write_end()) return;
0009d6 dc13      	RCALL _fs_write_end
0009d7 30e0      	CPI  R30,0
0009d8 f009      	BREQ _0x60047
0009d9 9508      	RET
                 ; 0003 0189   } while(fs_wtotal);
                 _0x60047:
0009da d3ba      	RCALL SUBOPT_0x7D
0009db 9730      	SBIW R30,0
0009dc f721      	BRNE _0x60044
                 ; 0003 018A 
                 ; 0003 018B   lastError = ERR_OK_CMD;
                 _0x2020003:
0009dd e4e3      	LDI  R30,LOW(67)
0009de d132      	RCALL SUBOPT_0xB
                 ; 0003 018C }
0009df 9508      	RET
                 ;
                 ;/*******************************************************************************
                 ;* Главная процедура                                                            *
                 ;*******************************************************************************/
                 ;
                 ;void error() {
                 ; 0003 0192 void error() {
                 _error:
                 ; 0003 0193   for(;;) {
                 _0x60049:
                 ; 0003 0194     PORTB.0 = 1;
0009e0 9ac0      	SBI  0x18,0
                 ; 0003 0195     delay_ms(100);
0009e1 d3fb      	RCALL SUBOPT_0x91
                 ; 0003 0196     PORTB.0 = 0;
0009e2 98c0      	CBI  0x18,0
                 ; 0003 0197     delay_ms(100);
0009e3 d3f9      	RCALL SUBOPT_0x91
                 ; 0003 0198   }
0009e4 cffb      	RJMP _0x60049
                 ; 0003 0199 }
                 ;
                 ;void main() {
                 ; 0003 019B void main() {
                 _main:
                 ; 0003 019C   BYTE c, d;
                 ; 0003 019D 
                 ; 0003 019E   DATA_OUT            // Шина данных (DDRD)
                 ;	c -> R17
                 ;	d -> R16
0009e5 efef      	LDI  R30,LOW(255)
0009e6 bbe1      	OUT  0x11,R30
                 ; 0003 019F   DDRC  = 0b00000000; // Шина адреса
0009e7 e0e0      	LDI  R30,LOW(0)
0009e8 bbe4      	OUT  0x14,R30
                 ; 0003 01A0   DDRB  = 0b00101101; // Шина адреса, карта и светодиод
0009e9 e2ed      	LDI  R30,LOW(45)
0009ea bbe7      	OUT  0x17,R30
                 ; 0003 01A1   PORTB = 0b00010001; // Подтягивающий резистор на MISO и светодиод
0009eb e1e1      	LDI  R30,LOW(17)
0009ec bbe8      	OUT  0x18,R30
                 ; 0003 01A2 
                 ; 0003 01A3   // Пауза, пока не стабилизируется питание
                 ; 0003 01A4   delay_ms(100);
0009ed d3ef      	RCALL SUBOPT_0x91
                 ; 0003 01A5 
                 ; 0003 01A6   // Запуск файловой системы
                 ; 0003 01A7   if(fs_init()) error();
0009ee d688      	RCALL _fs_init
0009ef 30e0      	CPI  R30,0
0009f0 f009      	BREQ _0x6004F
0009f1 dfee      	RCALL _error
                 ; 0003 01A8   strcpyf(buf, "boot/boot.rk");
                 _0x6004F:
0009f2 d2bd      	RCALL SUBOPT_0x54
                +
0009f3 e5e6     +LDI R30 , LOW ( 2 * _0x60000 + ( 32 ) )
0009f4 e0f0     +LDI R31 , HIGH ( 2 * _0x60000 + ( 32 ) )
                 	__POINTW1FN _0x60000,32
0009f5 d0f2      	RCALL SUBOPT_0x2
0009f6 d0d9      	RCALL _strcpyf
                 ; 0003 01A9   if(fs_open()) error();
0009f7 dacd      	RCALL _fs_open
0009f8 30e0      	CPI  R30,0
0009f9 f009      	BREQ _0x60050
0009fa dfe5      	RCALL _error
                 ; 0003 01AA   if(fs_getfilesize()) error();
                 _0x60050:
0009fb d3d1      	RCALL SUBOPT_0x8C
0009fc f009      	BREQ _0x60051
0009fd dfe2      	RCALL _error
                 ; 0003 01AB   if(fs_tmp < 7) error();
                 _0x60051:
0009fe d1b1      	RCALL SUBOPT_0x29
                +
0009ff 30a7     +CPI R26 , LOW ( 0x7 )
000a00 e0e0     +LDI R30 , HIGH ( 0x7 )
000a01 07be     +CPC R27 , R30
000a02 e0e0     +LDI R30 , BYTE3 ( 0x7 )
000a03 078e     +CPC R24 , R30
000a04 e0e0     +LDI R30 , BYTE4 ( 0x7 )
000a05 079e     +CPC R25 , R30
                 	__CPD2N 0x7
000a06 f408      	BRSH _0x60052
000a07 dfd8      	RCALL _error
                 ; 0003 01AC   if(fs_tmp > 128) error();
                 _0x60052:
000a08 d1a7      	RCALL SUBOPT_0x29
                +
000a09 38a1     +CPI R26 , LOW ( 0x81 )
000a0a e0e0     +LDI R30 , HIGH ( 0x81 )
000a0b 07be     +CPC R27 , R30
000a0c e0e0     +LDI R30 , BYTE3 ( 0x81 )
000a0d 078e     +CPC R24 , R30
000a0e e0e0     +LDI R30 , BYTE4 ( 0x81 )
000a0f 079e     +CPC R25 , R30
                 	__CPD2N 0x81
000a10 f008      	BRLO _0x60053
000a11 dfce      	RCALL _error
                 ; 0003 01AD   if(fs_read0(rom, (WORD)fs_tmp)) error();
                 _0x60053:
000a12 e0e0      	LDI  R30,LOW(_rom)
000a13 e0f1      	LDI  R31,HIGH(_rom)
000a14 d0d3      	RCALL SUBOPT_0x2
000a15 d28d      	RCALL SUBOPT_0x51
000a16 d0d1      	RCALL SUBOPT_0x2
000a17 daf5      	RCALL _fs_read0
000a18 30e0      	CPI  R30,0
000a19 f009      	BREQ _0x60054
000a1a dfc5      	RCALL _error
                 ; 0003 01AE 
                 ; 0003 01AF   // Гасим светодиод
                 ; 0003 01B0   PORTB.0 = 0;
                 _0x60054:
000a1b 98c0      	CBI  0x18,0
                 ; 0003 01B1 
                 ; 0003 01B2   while(1) {
                 _0x60057:
                 ; 0003 01B3     // Эмуляция ПЗУ
                 ; 0003 01B4 #asm
                 ; 0003 01B5 .EQU PIND  = $10
                 .EQU PIND  = $10
                 ; 0003 01B6 .EQU DDRD  = $11
                 .EQU DDRD  = $11
                 ; 0003 01B7 .EQU PORTD = $12
                 .EQU PORTD = $12
                 ; 0003 01B8 .EQU PINC  = $13
                 .EQU PINC  = $13
                 ; 0003 01B9 .EQU DDRC  = $14
                 .EQU DDRC  = $14
                 ; 0003 01BA .EQU PORTC = $15
                 .EQU PORTC = $15
                 ; 0003 01BB .EQU PINB  = $16
                 .EQU PINB  = $16
                 ; 0003 01BC .EQU DDRB  = $17
                 .EQU DDRB  = $17
                 ; 0003 01BD .EQU PORTB = $18
                 .EQU PORTB = $18
                 ; 0003 01BE .EQU ROM   = 1
                 .EQU ROM   = 1
                 ; 0003 01BF 
                 
                 ; 0003 01C0 .macro GET_ADDR
                 .macro GET_ADDR
                 ; 0003 01C1         IN   R30, PINC         ; Младшие 6 бит
                         IN   R30, PINC         ; Младшие 6 бит
                 ; 0003 01C2         ANDI R30, 0x3F
                         ANDI R30, 0x3F
                 ; 0003 01C3         IN   R26, PINB         ; Старший бит
                         IN   R26, PINB         ; Старший бит
                 ; 0003 01C4         ANDI R26, 0x40
                         ANDI R26, 0x40
                 ; 0003 01C5         OR   R30, R26
                         OR   R30, R26
                 ; 0003 01C6 .endmacro
                 .endmacro
                 ; 0003 01C7 
                 
                 ; 0003 01C8 .macro ROM_EMU
                 .macro ROM_EMU
                 ; 0003 01C9         LD   R30, Z
                         LD   R30, Z
                 ; 0003 01CA         OUT  PORTD, R30
                         OUT  PORTD, R30
                 ; 0003 01CB .endmacro
                 .endmacro
                 ; 0003 01CC 
                 
                 ; 0003 01CD         ; Устаналвиается один раз для ROM_EMU
                         ; Устаналвиается один раз для ROM_EMU
                 ; 0003 01CE         PUSH R26
000a1c 93af              PUSH R26
                 ; 0003 01CF         PUSH R30
000a1d 93ef              PUSH R30
                 ; 0003 01D0         PUSH R31
000a1e 93ff              PUSH R31
                 ; 0003 01D1         LDI  R31, ROM
000a1f e0f1              LDI  R31, ROM
                 ; 0003 01D2 
                 
                 ; 0003 01D3         ; Получаем адрес
                         ; Получаем адрес
                 ; 0003 01D4         GET_ADDR
                +
                +
000a20 b3e3     +IN R30 , PINC
                +
000a21 73ef     +ANDI R30 , 0x3F
                +
000a22 b3a6     +IN R26 , PINB
                +
000a23 74a0     +ANDI R26 , 0x40
                +
000a24 2bea     +OR R30 , R26
                +
                         GET_ADDR
                 ; 0003 01D5 
                 
                 ; 0003 01D6         ; Эмулируем ПЗУ
                         ; Эмулируем ПЗУ
                 ; 0003 01D7 LOOP0:  ROM_EMU
                +
                +
000a25 81e0     +LD R30 , Z
                +
000a26 bbe2     +OUT PORTD , R30
                +
                 LOOP0:  ROM_EMU
                 ; 0003 01D8 
                 
                 ; 0003 01D9         ; Получаем адрес и если это не 0x44, то переходим в начало
                         ; Получаем адрес и если это не 0x44, то переходим в начало
                 ; 0003 01DA         GET_ADDR
                +
                +
000a27 b3e3     +IN R30 , PINC
                +
000a28 73ef     +ANDI R30 , 0x3F
                +
000a29 b3a6     +IN R26 , PINB
                +
000a2a 74a0     +ANDI R26 , 0x40
                +
000a2b 2bea     +OR R30 , R26
                +
                         GET_ADDR
                 ; 0003 01DB         CPI  R30, 0x44
000a2c 34e4              CPI  R30, 0x44
                 ; 0003 01DC         BRNE LOOP0
000a2d f7b9              BRNE LOOP0
                 ; 0003 01DD 
                 
                 ; 0003 01DE         ; Эмулируем ПЗУ (0x44-ый адрес)
                         ; Эмулируем ПЗУ (0x44-ый адрес)
                 ; 0003 01DF         ROM_EMU
                +
                +
000a2e 81e0     +LD R30 , Z
                +
000a2f bbe2     +OUT PORTD , R30
                +
                         ROM_EMU
                 ; 0003 01E0 
                 
                 ; 0003 01E1         ; Получаем адрес и если это все еще 0x44, то ждем.
                         ; Получаем адрес и если это все еще 0x44, то ждем.
                 ; 0003 01E2         ; Если это не 0x40, то переходим в начало
                         ; Если это не 0x40, то переходим в начало
                 ; 0003 01E3 LOOP1:  GET_ADDR
                +
                +
000a30 b3e3     +IN R30 , PINC
                +
000a31 73ef     +ANDI R30 , 0x3F
                +
000a32 b3a6     +IN R26 , PINB
                +
000a33 74a0     +ANDI R26 , 0x40
                +
000a34 2bea     +OR R30 , R26
                +
                 LOOP1:  GET_ADDR
                 ; 0003 01E4         CPI  R30, 0x44
000a35 34e4              CPI  R30, 0x44
                 ; 0003 01E5         BREQ LOOP1
000a36 f3c9              BREQ LOOP1
                 ; 0003 01E6         CPI  R30, 0x40
000a37 34e0              CPI  R30, 0x40
                 ; 0003 01E7         BRNE LOOP0
000a38 f761              BRNE LOOP0
                 ; 0003 01E8 
                 
                 ; 0003 01E9         ; Эмулируем ПЗУ (0x40-ый адрес)
                         ; Эмулируем ПЗУ (0x40-ый адрес)
                 ; 0003 01EA         ROM_EMU
                +
                +
000a39 81e0     +LD R30 , Z
                +
000a3a bbe2     +OUT PORTD , R30
                +
                         ROM_EMU
                 ; 0003 01EB 
                 
                 ; 0003 01EC         ; Получаем адрес и если это все еще 0x40, то ждем.
                         ; Получаем адрес и если это все еще 0x40, то ждем.
                 ; 0003 01ED         ; Если это не 0, то переходим в начало
                         ; Если это не 0, то переходим в начало
                 ; 0003 01EE LOOP2:  GET_ADDR
                +
                +
000a3b b3e3     +IN R30 , PINC
                +
000a3c 73ef     +ANDI R30 , 0x3F
                +
000a3d b3a6     +IN R26 , PINB
                +
000a3e 74a0     +ANDI R26 , 0x40
                +
000a3f 2bea     +OR R30 , R26
                +
                 LOOP2:  GET_ADDR
                 ; 0003 01EF         CPI  R30, 0x40
000a40 34e0              CPI  R30, 0x40
                 ; 0003 01F0         BREQ LOOP2
000a41 f3c9              BREQ LOOP2
                 ; 0003 01F1         CPI  R30, 0
000a42 30e0              CPI  R30, 0
                 ; 0003 01F2         BRNE LOOP0
000a43 f709              BRNE LOOP0
                 ; 0003 01F3 
                 
                 ; 0003 01F4         POP R31
000a44 91ff              POP R31
                 ; 0003 01F5         POP R30
000a45 91ef              POP R30
                 ; 0003 01F6         POP R26
000a46 91af              POP R26
                 ; 0003 01F7 #endasm
                 ; 0003 01F8 
                 ; 0003 01F9     // Зажигаем светодиод
                 ; 0003 01FA     PORTB.0 = 1;
000a47 9ac0      	SBI  0x18,0
                 ; 0003 01FB 
                 ; 0003 01FC     // Проверяем наличие карты
                 ; 0003 01FD     sendStart(ERR_START);
000a48 e4e0      	LDI  R30,LOW(64)
000a49 93ea      	ST   -Y,R30
000a4a d60e      	RCALL _sendStart
                 ; 0003 01FE     send(ERR_WAIT);
000a4b d37b      	RCALL SUBOPT_0x8A
                 ; 0003 01FF     if(fs_check()) {
000a4c d752      	RCALL _fs_check
000a4d 30e0      	CPI  R30,0
000a4e f019      	BREQ _0x6005C
                 ; 0003 0200       send(ERR_DISK_ERR);
000a4f e0e2      	LDI  R30,LOW(2)
000a50 d371      	RCALL SUBOPT_0x88
                 ; 0003 0201     } else {
000a51 c043      	RJMP _0x6005D
                 _0x6005C:
                 ; 0003 0202       send(ERR_OK_DISK);
000a52 e4e2      	LDI  R30,LOW(66)
000a53 d36e      	RCALL SUBOPT_0x88
                 ; 0003 0203       recvStart();
000a54 d60b      	RCALL _recvStart
                 ; 0003 0204       c = wrecv();
000a55 d369      	RCALL SUBOPT_0x87
                 ; 0003 0205 
                 ; 0003 0206       // Сбрасываем ошибку
                 ; 0003 0207       lastError = 0;
000a56 e0e0      	LDI  R30,LOW(0)
000a57 d0b9      	RCALL SUBOPT_0xB
                 ; 0003 0208 
                 ; 0003 0209       // Принимаем аргументы
                 ; 0003 020A       switch(c) {
000a58 d219      	RCALL SUBOPT_0x45
                 ; 0003 020B         case 0:  cmd_boot();         break;
000a59 9730      	SBIW R30,0
000a5a f411      	BRNE _0x60061
000a5b de8a      	RCALL _cmd_boot
000a5c c032      	RJMP _0x60060
                 ; 0003 020C         case 1:  cmd_ver();          break;
                 _0x60061:
000a5d 30e1      	CPI  R30,LOW(0x1)
000a5e e0a0      	LDI  R26,HIGH(0x1)
000a5f 07fa      	CPC  R31,R26
000a60 f411      	BRNE _0x60062
000a61 de57      	RCALL _cmd_ver
000a62 c02c      	RJMP _0x60060
                 ; 0003 020D         case 2:  cmd_exec();         break;
                 _0x60062:
000a63 30e2      	CPI  R30,LOW(0x2)
000a64 e0a0      	LDI  R26,HIGH(0x2)
000a65 07fa      	CPC  R31,R26
000a66 f411      	BRNE _0x60063
000a67 de83      	RCALL _cmd_exec
000a68 c026      	RJMP _0x60060
                 ; 0003 020E         case 3:  cmd_find();         break;
                 _0x60063:
000a69 30e3      	CPI  R30,LOW(0x3)
000a6a e0a0      	LDI  R26,HIGH(0x3)
000a6b 07fa      	CPC  R31,R26
000a6c f411      	BRNE _0x60064
000a6d de83      	RCALL _cmd_find
000a6e c020      	RJMP _0x60060
                 ; 0003 020F         case 4:  cmd_open();         break;
                 _0x60064:
000a6f 30e4      	CPI  R30,LOW(0x4)
000a70 e0a0      	LDI  R26,HIGH(0x4)
000a71 07fa      	CPC  R31,R26
000a72 f411      	BRNE _0x60065
000a73 dec7      	RCALL _cmd_open
000a74 c01a      	RJMP _0x60060
                 ; 0003 0210         case 5:  cmd_lseek();        break;
                 _0x60065:
000a75 30e5      	CPI  R30,LOW(0x5)
000a76 e0a0      	LDI  R26,HIGH(0x5)
000a77 07fa      	CPC  R31,R26
000a78 f411      	BRNE _0x60066
000a79 deed      	RCALL _cmd_lseek
000a7a c014      	RJMP _0x60060
                 ; 0003 0211         case 6:  cmd_read();         break;
                 _0x60066:
000a7b 30e6      	CPI  R30,LOW(0x6)
000a7c e0a0      	LDI  R26,HIGH(0x6)
000a7d 07fa      	CPC  R31,R26
000a7e f411      	BRNE _0x60067
000a7f df1d      	RCALL _cmd_read
000a80 c00e      	RJMP _0x60060
                 ; 0003 0212         case 7:  cmd_write();        break;
                 _0x60067:
000a81 30e7      	CPI  R30,LOW(0x7)
000a82 e0a0      	LDI  R26,HIGH(0x7)
000a83 07fa      	CPC  R31,R26
000a84 f411      	BRNE _0x60068
000a85 df31      	RCALL _cmd_write
000a86 c008      	RJMP _0x60060
                 ; 0003 0213         case 8:  cmd_move();         break;
                 _0x60068:
000a87 30e8      	CPI  R30,LOW(0x8)
000a88 e0a0      	LDI  R26,HIGH(0x8)
000a89 07fa      	CPC  R31,R26
000a8a f411      	BRNE _0x6006A
000a8b decb      	RCALL _cmd_move
000a8c c002      	RJMP _0x60060
                 ; 0003 0214         default: lastError = ERR_INVALID_COMMAND;
                 _0x6006A:
000a8d e0ec      	LDI  R30,LOW(12)
000a8e d082      	RCALL SUBOPT_0xB
                 ; 0003 0215       }
                 _0x60060:
                 ; 0003 0216 
                 ; 0003 0217       // Вывод ошибки
                 ; 0003 0218       if(lastError) sendStart(lastError);
000a8f d339      	RCALL SUBOPT_0x8B
000a90 f021      	BREQ _0x6006B
000a91 91e0 0384 	LDS  R30,_lastError
000a93 93ea      	ST   -Y,R30
000a94 d5c4      	RCALL _sendStart
                 ; 0003 0219     }
                 _0x6006B:
                 _0x6005D:
                 ; 0003 021A 
                 ; 0003 021B     // Порт рабоатет на выход
                 ; 0003 021C     wait();
000a95 d5b9      	RCALL _wait
                 ; 0003 021D     DATA_OUT
000a96 efef      	LDI  R30,LOW(255)
000a97 bbe1      	OUT  0x11,R30
                 ; 0003 021E 
                 ; 0003 021F     // Гасим светодиод
                 ; 0003 0220     PORTB.0 = 0;
000a98 98c0      	CBI  0x18,0
                 ; 0003 0221   }
000a99 cf82      	RJMP _0x60057
                 ; 0003 0222 }
                 _0x6006E:
000a9a cfff      	RJMP _0x6006E
                 
                 	.CSEG
                 _memcmp:
000a9b 2766          clr  r22
000a9c 2777          clr  r23
000a9d 9189          ld   r24,y+
000a9e 9199          ld   r25,y+
000a9f 91e9          ld   r30,y+
000aa0 91f9          ld   r31,y+
000aa1 91a9          ld   r26,y+
000aa2 91b9          ld   r27,y+
                 memcmp0:
000aa3 9600          adiw r24,0
000aa4 f029          breq memcmp1
000aa5 9701          sbiw r24,1
000aa6 916d          ld   r22,x+
000aa7 9171          ld   r23,z+
000aa8 1767          cp   r22,r23
000aa9 f3c9          breq memcmp0
                 memcmp1:
000aaa 1b67          sub  r22,r23
000aab f410          brcc memcmp2
000aac efef          ldi  r30,-1
000aad 9508          ret
                 memcmp2:
000aae e0e0          ldi  r30,0
000aaf f009          breq memcmp3
000ab0 95e3          inc  r30
                 memcmp3:
000ab1 9508          ret
                 _memcpy:
000ab2 8199          ldd  r25,y+1
000ab3 8188          ld   r24,y
000ab4 9600          adiw r24,0
000ab5 f041          breq memcpy1
000ab6 81bd          ldd  r27,y+5
000ab7 81ac          ldd  r26,y+4
000ab8 81fb          ldd  r31,y+3
000ab9 81ea          ldd  r30,y+2
                 memcpy0:
000aba 9161          ld   r22,z+
000abb 936d          st   x+,r22
000abc 9701          sbiw r24,1
000abd f7e1          brne memcpy0
                 memcpy1:
000abe 81fd          ldd  r31,y+5
000abf 81ec          ldd  r30,y+4
                 _0x2020002:
000ac0 9626      	ADIW R28,6
000ac1 9508      	RET
                 _memset:
000ac2 81b9          ldd  r27,y+1
000ac3 81a8          ld   r26,y
000ac4 9610          adiw r26,0
000ac5 f031          breq memset1
000ac6 81fc          ldd  r31,y+4
000ac7 81eb          ldd  r30,y+3
000ac8 816a          ldd  r22,y+2
                 memset0:
000ac9 9361          st   z+,r22
000aca 9711          sbiw r26,1
000acb f7e9          brne memset0
                 memset1:
000acc 81eb          ldd  r30,y+3
000acd 81fc          ldd  r31,y+4
                 _0x2020001:
000ace 9625      	ADIW R28,5
000acf 9508      	RET
                 _strcpyf:
000ad0 91e9          ld   r30,y+
000ad1 91f9          ld   r31,y+
000ad2 91a9          ld   r26,y+
000ad3 91b9          ld   r27,y+
000ad4 01cd          movw r24,r26
                 strcpyf0:
000ad5 9005      	lpm  r0,z+
000ad6 920d          st   x+,r0
000ad7 2000          tst  r0
000ad8 f7e1          brne strcpyf0
000ad9 01fc          movw r30,r24
000ada 9508          ret
                 
                 	.DSEG
                 _rom:
000100           	.BYTE 0x80
                 _buf:
000180           	.BYTE 0x200
                 _fs_tmp:
000380           	.BYTE 0x4
                 _lastError:
000384           	.BYTE 0x1
                 _fs_wtotal:
000385           	.BYTE 0x2
                 _fs_fatbase:
000387           	.BYTE 0x4
                 _fs_fatbase2:
00038b           	.BYTE 0x4
                 _fs_n_fatent:
00038f           	.BYTE 0x4
                 _fs_dirbase:
000393           	.BYTE 0x4
                 _fs_database:
000397           	.BYTE 0x4
                 _fs_fatoptim:
00039b           	.BYTE 0x4
                 _fs_file:
00039f           	.BYTE 0x21
                 _fs_secondFile:
0003c0           	.BYTE 0x21
                 
                 	.CSEG
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
                 SUBOPT_0x0:
000adb e8e0      	LDI  R30,LOW(_buf)
000adc e0f1      	LDI  R31,HIGH(_buf)
000add 93fa      	ST   -Y,R31
000ade 93ea      	ST   -Y,R30
                +
000adf 81ea     +LDD R30 , Y + 2
000ae0 81fb     +LDD R31 , Y + 2 + 1
000ae1 816c     +LDD R22 , Y + 2 + 2
000ae2 817d     +LDD R23 , Y + 2 + 3
                 	__GETD1S 2
000ae3 d3fd      	RCALL __PUTPARD1
000ae4 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x1:
000ae5 e0e0      	LDI  R30,LOW(0)
000ae6 e0f0      	LDI  R31,HIGH(0)
000ae7 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 83 TIMES, CODE SIZE REDUCTION:80 WORDS
                 SUBOPT_0x2:
000ae8 93fa      	ST   -Y,R31
000ae9 93ea      	ST   -Y,R30
000aea 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x3:
000aeb dffc      	RCALL SUBOPT_0x2
000aec ccaf      	RJMP _sd_read
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:12 WORDS
                 SUBOPT_0x4:
000aed 93e0 039b 	STS  _fs_fatoptim,R30
000aef 93f0 039c 	STS  _fs_fatoptim+1,R31
000af1 9360 039d 	STS  _fs_fatoptim+2,R22
000af3 9370 039e 	STS  _fs_fatoptim+3,R23
000af5 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 11 TIMES, CODE SIZE REDUCTION:18 WORDS
                 SUBOPT_0x5:
000af6 e0e0      	LDI  R30,LOW(0)
000af7 93e0 039f 	STS  _fs_file,R30
000af9 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:4 WORDS
                 SUBOPT_0x6:
000afa e0e0      	LDI  R30,LOW(0)
000afb 93e0 03c0 	STS  _fs_secondFile,R30
000afd 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:16 WORDS
                 SUBOPT_0x7:
                +
000afe 85e8     +LDD R30 , Y + 8
000aff 85f9     +LDD R31 , Y + 8 + 1
000b00 856a     +LDD R22 , Y + 8 + 2
000b01 857b     +LDD R23 , Y + 8 + 3
                 	__GETD1S 8
000b02 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 11 TIMES, CODE SIZE REDUCTION:18 WORDS
                 SUBOPT_0x8:
000b03 d3dd      	RCALL __PUTPARD1
000b04 d568      	RCALL _sd_readBuf_G001
000b05 30e0      	CPI  R30,0
000b06 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x9:
                +
000b07 85a8     +LDD R26 , Y + 8
000b08 85b9     +LDD R27 , Y + 8 + 1
000b09 858a     +LDD R24 , Y + 8 + 2
000b0a 859b     +LDD R25 , Y + 8 + 3
                 	__GETD2S 8
000b0b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0xA:
                +
000b0c 87e8     +STD Y + 8 , R30
000b0d 87f9     +STD Y + 8 + 1 , R31
000b0e 876a     +STD Y + 8 + 2 , R22
000b0f 877b     +STD Y + 8 + 3 , R23
                 	__PUTD1S 8
000b10 cfed      	RJMP SUBOPT_0x7
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 25 TIMES, CODE SIZE REDUCTION:22 WORDS
                 SUBOPT_0xB:
000b11 93e0 0384 	STS  _lastError,R30
000b13 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:10 WORDS
                 SUBOPT_0xC:
000b14 2766      	CLR  R22
000b15 2777      	CLR  R23
000b16 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:13 WORDS
                 SUBOPT_0xD:
                +
000b17 83ec     +STD Y + 4 , R30
000b18 83fd     +STD Y + 4 + 1 , R31
000b19 836e     +STD Y + 4 + 2 , R22
000b1a 837f     +STD Y + 4 + 3 , R23
                 	__PUTD1S 4
000b1b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:22 WORDS
                 SUBOPT_0xE:
                +
000b1c 81ec     +LDD R30 , Y + 4
000b1d 81fd     +LDD R31 , Y + 4 + 1
000b1e 816e     +LDD R22 , Y + 4 + 2
000b1f 817f     +LDD R23 , Y + 4 + 3
                 	__GETD1S 4
000b20 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0xF:
000b21 dff2      	RCALL SUBOPT_0xC
000b22 d3b4      	RCALL __PUTD1S0
000b23 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:19 WORDS
                 SUBOPT_0x10:
000b24 d3a8      	RCALL __GETD1S0
000b25 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:16 WORDS
                 SUBOPT_0x11:
000b26 d3b0      	RCALL __PUTD1S0
000b27 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x12:
                +
000b28 91e0 018e+LDS R30 , _buf + ( 14 )
000b2a 91f0 018f+LDS R31 , _buf + ( 14 ) + 1
                 	__GETW1MN _buf,14
000b2c 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x13:
000b2d dfe6      	RCALL SUBOPT_0xC
000b2e d2bd      	RCALL __ADDD12
000b2f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:22 WORDS
                 SUBOPT_0x14:
000b30 dfeb      	RCALL SUBOPT_0xE
000b31 91a0 0387 	LDS  R26,_fs_fatbase
000b33 91b0 0388 	LDS  R27,_fs_fatbase+1
000b35 9180 0389 	LDS  R24,_fs_fatbase+2
000b37 9190 038a 	LDS  R25,_fs_fatbase+3
000b39 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 15 TIMES, CODE SIZE REDUCTION:26 WORDS
                 SUBOPT_0x15:
000b3a e0f0      	LDI  R31,0
000b3b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x16:
                +
000b3c 81ac     +LDD R26 , Y + 4
000b3d 81bd     +LDD R27 , Y + 4 + 1
000b3e 818e     +LDD R24 , Y + 4 + 2
000b3f 819f     +LDD R25 , Y + 4 + 3
                 	__GETD2S 4
000b40 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:4 WORDS
                 SUBOPT_0x17:
000b41 d300      	RCALL __CWD1
000b42 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x18:
000b43 d38e      	RCALL __GETD2S0
000b44 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x19:
000b45 01df      	MOVW R26,R30
000b46 01cb      	MOVW R24,R22
000b47 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:6 WORDS
                 SUBOPT_0x1A:
000b48 2de4      	MOV  R30,R4
000b49 dff0      	RCALL SUBOPT_0x15
000b4a cff6      	RJMP SUBOPT_0x17
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:12 WORDS
                 SUBOPT_0x1B:
000b4b 91a0 038f 	LDS  R26,_fs_n_fatent
000b4d 91b0 0390 	LDS  R27,_fs_n_fatent+1
000b4f 9180 0391 	LDS  R24,_fs_n_fatent+2
000b51 9190 0392 	LDS  R25,_fs_n_fatent+3
000b53 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x1C:
000b54 93e0 0393 	STS  _fs_dirbase,R30
000b56 93f0 0394 	STS  _fs_dirbase+1,R31
000b58 9360 0395 	STS  _fs_dirbase+2,R22
000b5a 9370 0396 	STS  _fs_dirbase+3,R23
000b5c 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:13 WORDS
                 SUBOPT_0x1D:
                +
000b5d 5fef     +SUBI R30 , LOW ( - 1 )
000b5e 4fff     +SBCI R31 , HIGH ( - 1 )
000b5f 4f6f     +SBCI R22 , BYTE3 ( - 1 )
000b60 4f7f     +SBCI R23 , BYTE4 ( - 1 )
                 	__SUBD1N -1
000b61 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x1E:
                +
000b62 91e0 037c+LDS R30 , _buf + ( 508 )
000b64 91f0 037d+LDS R31 , _buf + ( 508 ) + 1
000b66 9160 037e+LDS R22 , _buf + ( 508 ) + 2
000b68 9170 037f+LDS R23 , _buf + ( 508 ) + 3
                 	__GETD1MN _buf,508
000b6a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x1F:
                +
000b6b efaf     +LDI R26 , LOW ( 0xFFFFFFFF )
000b6c efbf     +LDI R27 , HIGH ( 0xFFFFFFFF )
000b6d ef8f     +LDI R24 , BYTE3 ( 0xFFFFFFFF )
000b6e ef9f     +LDI R25 , BYTE4 ( 0xFFFFFFFF )
                 	__GETD2N 0xFFFFFFFF
000b6f d36c      	RCALL __PUTDZ20
000b70 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x20:
000b71 df8c      	RCALL SUBOPT_0x7
000b72 d36e      	RCALL __PUTPARD1
000b73 d500      	RCALL _sd_writeBuf_G001
000b74 30e0      	CPI  R30,0
000b75 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:8 WORDS
                 SUBOPT_0x21:
000b76 e8e0      	LDI  R30,LOW(_fs_tmp)
000b77 e0f3      	LDI  R31,HIGH(_fs_tmp)
000b78 df6f      	RCALL SUBOPT_0x2
000b79 91a0 0380 	LDS  R26,_fs_tmp
000b7b 91b0 0381 	LDS  R27,_fs_tmp+1
000b7d 9180 0382 	LDS  R24,_fs_tmp+2
000b7f 9190 0383 	LDS  R25,_fs_tmp+3
000b81 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:6 WORDS
                 SUBOPT_0x22:
                +
000b82 e0e0     +LDI R30 , LOW ( 0x100 )
000b83 e0f1     +LDI R31 , HIGH ( 0x100 )
000b84 e060     +LDI R22 , BYTE3 ( 0x100 )
000b85 e070     +LDI R23 , BYTE4 ( 0x100 )
                 	__GETD1N 0x100
000b86 d2f3      	RCALL __DIVD21U
000b87 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:9 WORDS
                 SUBOPT_0x23:
000b88 91a0 0387 	LDS  R26,_fs_fatbase
000b8a 91b0 0388 	LDS  R27,_fs_fatbase+1
000b8c 9180 0389 	LDS  R24,_fs_fatbase+2
000b8e 9190 038a 	LDS  R25,_fs_fatbase+3
000b90 d25b      	RCALL __ADDD12
000b91 d34f      	RCALL __PUTPARD1
000b92 91a0 0380 	LDS  R26,_fs_tmp
000b94 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:4 WORDS
                 SUBOPT_0x24:
000b95 e0e2      	LDI  R30,LOW(2)
000b96 e0f0      	LDI  R31,HIGH(2)
000b97 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 25 TIMES, CODE SIZE REDUCTION:166 WORDS
                 SUBOPT_0x25:
000b98 91e0 0380 	LDS  R30,_fs_tmp
000b9a 91f0 0381 	LDS  R31,_fs_tmp+1
000b9c 9160 0382 	LDS  R22,_fs_tmp+2
000b9e 9170 0383 	LDS  R23,_fs_tmp+3
000ba0 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:6 WORDS
                 SUBOPT_0x26:
                +
000ba1 e8e0     +LDI R30 , LOW ( 0x80 )
000ba2 e0f0     +LDI R31 , HIGH ( 0x80 )
000ba3 e060     +LDI R22 , BYTE3 ( 0x80 )
000ba4 e070     +LDI R23 , BYTE4 ( 0x80 )
                 	__GETD1N 0x80
000ba5 d2d4      	RCALL __DIVD21U
000ba6 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x27:
000ba7 27bb      	CLR  R27
000ba8 e8e0      	LDI  R30,LOW(128)
000ba9 e0f0      	LDI  R31,HIGH(128)
000baa d2f7      	RCALL __MODW21
000bab 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:6 WORDS
                 SUBOPT_0x28:
000bac df3b      	RCALL SUBOPT_0x2
000bad e0e4      	LDI  R30,LOW(4)
000bae e0f0      	LDI  R31,HIGH(4)
000baf 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:82 WORDS
                 SUBOPT_0x29:
000bb0 91a0 0380 	LDS  R26,_fs_tmp
000bb2 91b0 0381 	LDS  R27,_fs_tmp+1
000bb4 9180 0382 	LDS  R24,_fs_tmp+2
000bb6 9190 0383 	LDS  R25,_fs_tmp+3
000bb8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
                 SUBOPT_0x2A:
                +
000bb9 30a2     +CPI R26 , LOW ( 0x2 )
000bba e0e0     +LDI R30 , HIGH ( 0x2 )
000bbb 07be     +CPC R27 , R30
000bbc e0e0     +LDI R30 , BYTE3 ( 0x2 )
000bbd 078e     +CPC R24 , R30
000bbe e0e0     +LDI R30 , BYTE4 ( 0x2 )
000bbf 079e     +CPC R25 , R30
                 	__CPD2N 0x2
000bc0 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:16 WORDS
                 SUBOPT_0x2B:
000bc1 91e0 038f 	LDS  R30,_fs_n_fatent
000bc3 91f0 0390 	LDS  R31,_fs_n_fatent+1
000bc5 9160 0391 	LDS  R22,_fs_n_fatent+2
000bc7 9170 0392 	LDS  R23,_fs_n_fatent+3
000bc9 dfe6      	RCALL SUBOPT_0x29
000bca d33b      	RCALL __CPD21
000bcb 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:14 WORDS
                 SUBOPT_0x2C:
000bcc e0e0      	LDI  R30,LOW(0)
000bcd 93e0 0380 	STS  _fs_tmp,R30
000bcf 93e0 0381 	STS  _fs_tmp+1,R30
000bd1 93e0 0382 	STS  _fs_tmp+2,R30
000bd3 93e0 0383 	STS  _fs_tmp+3,R30
000bd5 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x2D:
000bd6 df6e      	RCALL SUBOPT_0x19
000bd7 cf70      	RJMP SUBOPT_0x1A
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x2E:
000bd8 91a0 0397 	LDS  R26,_fs_database
000bda 91b0 0398 	LDS  R27,_fs_database+1
000bdc 9180 0399 	LDS  R24,_fs_database+2
000bde 9190 039a 	LDS  R25,_fs_database+3
000be0 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:82 WORDS
                 SUBOPT_0x2F:
000be1 93e0 0380 	STS  _fs_tmp,R30
000be3 93f0 0381 	STS  _fs_tmp+1,R31
000be5 9360 0382 	STS  _fs_tmp+2,R22
000be7 9370 0383 	STS  _fs_tmp+3,R23
000be9 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:10 WORDS
                 SUBOPT_0x30:
                +
000bea 91e0 03a0+LDS R30 , _fs_file + ( 1 )
                 	__GETB1MN _fs_file,1
000bec 30e0      	CPI  R30,0
000bed 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x31:
                +
000bee 91a0 03a1+LDS R26 , _fs_file + ( 2 )
000bf0 91b0 03a2+LDS R27 , _fs_file + ( 2 ) + 1
                 	__GETW2MN _fs_file,2
000bf2 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
                 SUBOPT_0x32:
                +
000bf3 91a0 03a3+LDS R26 , _fs_file + ( 4 )
000bf5 91b0 03a4+LDS R27 , _fs_file + ( 4 ) + 1
000bf7 9180 03a5+LDS R24 , _fs_file + ( 4 ) + 2
000bf9 9190 03a6+LDS R25 , _fs_file + ( 4 ) + 3
                 	__GETD2MN _fs_file,4
000bfb d2ff      	RCALL __CPD02
000bfc 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x33:
000bfd dee7      	RCALL SUBOPT_0x1
                +
000bfe 93e0 03a1+STS _fs_file + ( 2 ) , R30
000c00 93f0 03a2+STS _fs_file + ( 2 ) + 1 , R31
                 	__PUTW1MN _fs_file,2
000c02 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:6 WORDS
                 SUBOPT_0x34:
000c03 e0e0      	LDI  R30,LOW(0)
                +
000c04 93e0 03a0+STS _fs_file + ( 1 ) , R30
                 	__PUTB1MN _fs_file,1
000c06 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:22 WORDS
                 SUBOPT_0x35:
                +
000c07 91e0 03a1+LDS R30 , _fs_file + ( 2 )
000c09 91f0 03a2+LDS R31 , _fs_file + ( 2 ) + 1
                 	__GETW1MN _fs_file,2
000c0b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:6 WORDS
                 SUBOPT_0x36:
000c0c d2b1      	RCALL __GETD1P_INC
000c0d df4f      	RCALL SUBOPT_0x1D
000c0e d2b9      	RCALL __PUTDP1_DEC
000c0f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:12 WORDS
                 SUBOPT_0x37:
                +
000c10 91e0 03a3+LDS R30 , _fs_file + ( 4 )
000c12 91f0 03a4+LDS R31 , _fs_file + ( 4 ) + 1
000c14 9160 03a5+LDS R22 , _fs_file + ( 4 ) + 2
000c16 9170 03a6+LDS R23 , _fs_file + ( 4 ) + 3
                 	__GETD1MN _fs_file,4
000c18 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:34 WORDS
                 SUBOPT_0x38:
000c19 df7e      	RCALL SUBOPT_0x25
                +
000c1a 93e0 03a3+STS _fs_file + ( 4 ) , R30
000c1c 93f0 03a4+STS _fs_file + ( 4 ) + 1 , R31
000c1e 9360 03a5+STS _fs_file + ( 4 ) + 2 , R22
000c20 9370 03a6+STS _fs_file + ( 4 ) + 3 , R23
                 	__PUTD1MN _fs_file,4
000c22 d5c7      	RCALL _fs_clust2sect_G001
000c23 df74      	RCALL SUBOPT_0x25
                +
000c24 93e0 03a7+STS _fs_file + ( 8 ) , R30
000c26 93f0 03a8+STS _fs_file + ( 8 ) + 1 , R31
000c28 9360 03a9+STS _fs_file + ( 8 ) + 2 , R22
000c2a 9370 03aa+STS _fs_file + ( 8 ) + 3 , R23
                 	__PUTD1MN _fs_file,8
000c2c 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:54 WORDS
                 SUBOPT_0x39:
                +
000c2d 91e0 03ab+LDS R30 , _fs_file + ( 12 )
000c2f 91f0 03ac+LDS R31 , _fs_file + ( 12 ) + 1
000c31 9160 03ad+LDS R22 , _fs_file + ( 12 ) + 2
000c33 9170 03ae+LDS R23 , _fs_file + ( 12 ) + 3
                 	__GETD1MN _fs_file,12
000c35 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:12 WORDS
                 SUBOPT_0x3A:
000c36 91e0 0393 	LDS  R30,_fs_dirbase
000c38 91f0 0394 	LDS  R31,_fs_dirbase+1
000c3a 9160 0395 	LDS  R22,_fs_dirbase+2
000c3c 9170 0396 	LDS  R23,_fs_dirbase+3
000c3e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x3B:
                +
000c3f e6e0     +LDI R30 , LOW ( _buf + ( 480 ) )
000c40 e0f3     +LDI R31 , HIGH ( _buf + ( 480 ) )
                 	__POINTW1MN _buf,480
000c41 cea6      	RJMP SUBOPT_0x2
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 11 TIMES, CODE SIZE REDUCTION:68 WORDS
                 SUBOPT_0x3C:
                +
000c42 91e0 03a7+LDS R30 , _fs_file + ( 8 )
000c44 91f0 03a8+LDS R31 , _fs_file + ( 8 ) + 1
000c46 9160 03a9+LDS R22 , _fs_file + ( 8 ) + 2
000c48 9170 03aa+LDS R23 , _fs_file + ( 8 ) + 3
                 	__GETD1MN _fs_file,8
000c4a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:13 WORDS
                 SUBOPT_0x3D:
000c4b 70ef      	ANDI R30,LOW(0xF)
000c4c 70f0      	ANDI R31,HIGH(0xF)
000c4d 0fee      	LSL  R30
000c4e d1d2      	RCALL __LSLW4
000c4f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x3E:
                +
000c50 91e0 0360+LDS R30 , _buf + ( 480 )
                 	__GETB1MN _buf,480
000c52 30e0      	CPI  R30,0
000c53 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x3F:
                +
000c54 91a0 0360+LDS R26 , _buf + ( 480 )
                 	__GETB2MN _buf,480
000c56 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x40:
                +
000c57 91e0 036b+LDS R30 , _buf + ( 491 )
                 	__GETB1MN _buf,491
000c59 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x41:
000c5a 91a0 039f 	LDS  R26,_fs_file
000c5c 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x42:
000c5d d18e      	RCALL __ADDD12
000c5e d282      	RCALL __PUTPARD1
000c5f c414      	RJMP _sd_writeBuf_G001
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x43:
000c60 91a0 0387 	LDS  R26,_fs_fatbase
000c62 91b0 0388 	LDS  R27,_fs_fatbase+1
000c64 9180 0389 	LDS  R24,_fs_fatbase+2
000c66 9190 038a 	LDS  R25,_fs_fatbase+3
000c68 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x44:
000c69 91e0 039b 	LDS  R30,_fs_fatoptim
000c6b 91f0 039c 	LDS  R31,_fs_fatoptim+1
000c6d 9160 039d 	LDS  R22,_fs_fatoptim+2
000c6f 9170 039e 	LDS  R23,_fs_fatoptim+3
000c71 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x45:
000c72 2fe1      	MOV  R30,R17
000c73 cec6      	RJMP SUBOPT_0x15
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x46:
000c74 e8a0      	LDI  R26,LOW(_buf)
000c75 e0b1      	LDI  R27,HIGH(_buf)
000c76 0fee      	LSL  R30
000c77 1fff      	ROL  R31
000c78 0fea      	ADD  R30,R26
000c79 1ffb      	ADC  R31,R27
000c7a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x47:
000c7b e8e0      	LDI  R30,LOW(_buf)
000c7c e0f1      	LDI  R31,HIGH(_buf)
000c7d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x48:
000c7e 0fea      	ADD  R30,R26
000c7f 1ffb      	ADC  R31,R27
000c80 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x49:
000c81 85e8      	LDD  R30,Y+8
000c82 30e0      	CPI  R30,0
000c83 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x4A:
                +
000c84 ebab     +LDI R26 , LOW ( _fs_file + ( 28 ) )
000c85 e0b3     +LDI R27 , HIGH ( _fs_file + ( 28 ) )
                 	__POINTW2MN _fs_file,28
000c86 cf85      	RJMP SUBOPT_0x36
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x4B:
                +
000c87 efef     +LDI R30 , LOW ( 0xFFFFFFF )
000c88 efff     +LDI R31 , HIGH ( 0xFFFFFFF )
000c89 ef6f     +LDI R22 , BYTE3 ( 0xFFFFFFF )
000c8a e07f     +LDI R23 , BYTE4 ( 0xFFFFFFF )
                 	__GETD1N 0xFFFFFFF
000c8b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:4 WORDS
                 SUBOPT_0x4C:
                +
000c8c 85aa     +LDD R26 , Y + 10
000c8d 85bb     +LDD R27 , Y + 10 + 1
000c8e 858c     +LDD R24 , Y + 10 + 2
000c8f 859d     +LDD R25 , Y + 10 + 3
                 	__GETD2S 10
000c90 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x4D:
                +
000c91 83ee     +STD Y + 6 , R30
000c92 83ff     +STD Y + 6 + 1 , R31
000c93 8768     +STD Y + 6 + 2 , R22
000c94 8779     +STD Y + 6 + 3 , R23
                 	__PUTD1S 6
000c95 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x4E:
                +
000c96 81ee     +LDD R30 , Y + 6
000c97 81ff     +LDD R31 , Y + 6 + 1
000c98 8568     +LDD R22 , Y + 6 + 2
000c99 8579     +LDD R23 , Y + 6 + 3
                 	__GETD1S 6
000c9a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x4F:
000c9b e0e1      	LDI  R30,LOW(1)
000c9c d279      	RCALL __LOADLOCR2
000c9d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:10 WORDS
                 SUBOPT_0x50:
                +
000c9e 83ea     +STD Y + 2 , R30
000c9f 83fb     +STD Y + 2 + 1 , R31
000ca0 836c     +STD Y + 2 + 2 , R22
000ca1 837d     +STD Y + 2 + 3 , R23
                 	__PUTD1S 2
000ca2 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x51:
000ca3 91e0 0380 	LDS  R30,_fs_tmp
000ca5 91f0 0381 	LDS  R31,_fs_tmp+1
000ca7 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:10 WORDS
                 SUBOPT_0x52:
                +
000ca8 81ea     +LDD R30 , Y + 2
000ca9 81fb     +LDD R31 , Y + 2 + 1
000caa 816c     +LDD R22 , Y + 2 + 2
000cab 817d     +LDD R23 , Y + 2 + 3
                 	__GETD1S 2
000cac 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x53:
000cad 81e8      	LD   R30,Y
000cae 81f9      	LDD  R31,Y+1
000caf 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:4 WORDS
                 SUBOPT_0x54:
000cb0 dfca      	RCALL SUBOPT_0x47
000cb1 ce36      	RJMP SUBOPT_0x2
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 11 TIMES, CODE SIZE REDUCTION:8 WORDS
                 SUBOPT_0x55:
000cb2 e0e0      	LDI  R30,LOW(0)
000cb3 93ea      	ST   -Y,R30
000cb4 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x56:
000cb5 de32      	RCALL SUBOPT_0x2
000cb6 ce0b      	RJMP _memset
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x57:
000cb7 58e0      	SUBI R30,LOW(-_buf)
000cb8 4ffe      	SBCI R31,HIGH(-_buf)
000cb9 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x58:
000cba d5c3      	RCALL _fs_allocCluster_G001
000cbb 30e0      	CPI  R30,0
000cbc 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x59:
000cbd d223      	RCALL __PUTPARD1
000cbe c617      	RJMP _fs_setNextCluster_G001
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:26 WORDS
                 SUBOPT_0x5A:
                +
000cbf 93e0 03bb+STS _fs_file + ( 28 ) , R30
000cc1 93f0 03bc+STS _fs_file + ( 28 ) + 1 , R31
000cc3 9360 03bd+STS _fs_file + ( 28 ) + 2 , R22
000cc5 9370 03be+STS _fs_file + ( 28 ) + 3 , R23
                 	__PUTD1MN _fs_file,28
000cc7 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:33 WORDS
                 SUBOPT_0x5B:
                +
000cc8 93e0 03ab+STS _fs_file + ( 12 ) , R30
000cca 93f0 03ac+STS _fs_file + ( 12 ) + 1 , R31
000ccc 9360 03ad+STS _fs_file + ( 12 ) + 2 , R22
000cce 9370 03ae+STS _fs_file + ( 12 ) + 3 , R23
                 	__PUTD1MN _fs_file,12
000cd0 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 12 TIMES, CODE SIZE REDUCTION:31 WORDS
                 SUBOPT_0x5C:
                +
000cd1 e0e0     +LDI R30 , LOW ( 0x0 )
000cd2 e0f0     +LDI R31 , HIGH ( 0x0 )
000cd3 e060     +LDI R22 , BYTE3 ( 0x0 )
000cd4 e070     +LDI R23 , BYTE4 ( 0x0 )
                 	__GETD1N 0x0
000cd5 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x5D:
000cd6 931a      	ST   -Y,R17
000cd7 930a      	ST   -Y,R16
000cd8 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x5E:
                +
000cd9 e5e5     +LDI R30 , LOW ( _buf + ( 469 ) )
000cda e0f3     +LDI R31 , HIGH ( _buf + ( 469 ) )
                 	__POINTW1MN _buf,469
000cdb ce0c      	RJMP SUBOPT_0x2
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x5F:
000cdc e0eb      	LDI  R30,LOW(11)
000cdd e0f0      	LDI  R31,HIGH(11)
000cde 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x60:
                +
000cdf 91a0 03bb+LDS R26 , _fs_file + ( 28 )
000ce1 91b0 03bc+LDS R27 , _fs_file + ( 28 ) + 1
000ce3 9180 03bd+LDS R24 , _fs_file + ( 28 ) + 2
000ce5 9190 03be+LDS R25 , _fs_file + ( 28 ) + 3
                 	__GETD2MN _fs_file,28
000ce7 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x61:
000ce8 2e00      	MOV  R0,R16
000ce9 2a01      	OR   R0,R17
000cea 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:33 WORDS
                 SUBOPT_0x62:
                +
000ceb 91e0 03bb+LDS R30 , _fs_file + ( 28 )
000ced 91f0 03bc+LDS R31 , _fs_file + ( 28 ) + 1
000cef 9160 03bd+LDS R22 , _fs_file + ( 28 ) + 2
000cf1 9170 03be+LDS R23 , _fs_file + ( 28 ) + 3
                 	__GETD1MN _fs_file,28
000cf3 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:17 WORDS
                 SUBOPT_0x63:
                +
000cf4 93e0 03b3+STS _fs_file + ( 20 ) , R30
000cf6 93f0 03b4+STS _fs_file + ( 20 ) + 1 , R31
000cf8 9360 03b5+STS _fs_file + ( 20 ) + 2 , R22
000cfa 9370 03b6+STS _fs_file + ( 20 ) + 3 , R23
                 	__PUTD1MN _fs_file,20
000cfc dfd4      	RCALL SUBOPT_0x5C
                +
000cfd 93e0 03af+STS _fs_file + ( 16 ) , R30
000cff 93f0 03b0+STS _fs_file + ( 16 ) + 1 , R31
000d01 9360 03b1+STS _fs_file + ( 16 ) + 2 , R22
000d03 9370 03b2+STS _fs_file + ( 16 ) + 3 , R23
                 	__PUTD1MN _fs_file,16
000d05 e0e1      	LDI  R30,LOW(1)
000d06 93e0 039f 	STS  _fs_file,R30
000d08 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x64:
000d09 df50      	RCALL SUBOPT_0x41
000d0a 30a1      	CPI  R26,LOW(0x1)
000d0b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
                 SUBOPT_0x65:
000d0c 81e9      	LDD  R30,Y+1
000d0d 81fa      	LDD  R31,Y+1+1
000d0e 9631      	ADIW R30,1
000d0f 83e9      	STD  Y+1,R30
000d10 83fa      	STD  Y+1+1,R31
000d11 9731      	SBIW R30,1
000d12 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:4 WORDS
                 SUBOPT_0x66:
000d13 e2e0      	LDI  R30,LOW(32)
000d14 93ea      	ST   -Y,R30
000d15 dfc6      	RCALL SUBOPT_0x5F
000d16 cf9e      	RJMP SUBOPT_0x56
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x67:
000d17 81ec      	LDD  R30,Y+4
000d18 81fd      	LDD  R31,Y+4+1
000d19 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x68:
000d1a dfc1      	RCALL SUBOPT_0x5F
000d1b ddcc      	RCALL SUBOPT_0x2
000d1c dd95      	RCALL _memcpy
000d1d 89e9      	LDD  R30,Y+17
000d1e 30e0      	CPI  R30,0
000d1f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:8 WORDS
                 SUBOPT_0x69:
000d20 d1c0      	RCALL __PUTPARD1
000d21 d352      	RCALL _sd_writeBuf_G001
000d22 30e0      	CPI  R30,0
000d23 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x6A:
000d24 d1bc      	RCALL __PUTPARD1
000d25 c5fc      	RJMP _fs_setEntryCluster_G001
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x6B:
000d26 e0e1      	LDI  R30,LOW(1)
000d27 93ea      	ST   -Y,R30
000d28 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x6C:
                +
000d29 eae0     +LDI R30 , LOW ( _buf + ( 32 ) )
000d2a e0f1     +LDI R31 , HIGH ( _buf + ( 32 ) )
                 	__POINTW1MN _buf,32
000d2b cdbc      	RJMP SUBOPT_0x2
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x6D:
000d2c d642      	RCALL _fs_open0
000d2d 30e0      	CPI  R30,0
000d2e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:14 WORDS
                 SUBOPT_0x6E:
                +
000d2f 91e0 03af+LDS R30 , _fs_file + ( 16 )
000d31 91f0 03b0+LDS R31 , _fs_file + ( 16 ) + 1
000d33 9160 03b1+LDS R22 , _fs_file + ( 16 ) + 2
000d35 9170 03b2+LDS R23 , _fs_file + ( 16 ) + 3
                 	__GETD1MN _fs_file,16
000d37 d1bb      	RCALL __CPD10
000d38 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:14 WORDS
                 SUBOPT_0x6F:
                +
000d39 91e0 03af+LDS R30 , _fs_file + ( 16 )
000d3b 91f0 03b0+LDS R31 , _fs_file + ( 16 ) + 1
                 	__GETW1MN _fs_file,16
000d3d 70f1      	ANDI R31,HIGH(0x1FF)
000d3e 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:12 WORDS
                 SUBOPT_0x70:
                +
000d3f 91e0 03b7+LDS R30 , _fs_file + ( 24 )
000d41 91f0 03b8+LDS R31 , _fs_file + ( 24 ) + 1
000d43 9160 03b9+LDS R22 , _fs_file + ( 24 ) + 2
000d45 9170 03ba+LDS R23 , _fs_file + ( 24 ) + 3
                 	__GETD1MN _fs_file,24
000d47 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x71:
000d48 e0e3      	LDI  R30,LOW(3)
000d49 cdc7      	RJMP SUBOPT_0xB
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x72:
000d4a 81ea      	LDD  R30,Y+2
000d4b 81fb      	LDD  R31,Y+2+1
000d4c 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x73:
000d4d e0a0      	LDI  R26,LOW(512)
000d4e e0b2      	LDI  R27,HIGH(512)
000d4f 1bae      	SUB  R26,R30
000d50 0bbf      	SBC  R27,R31
000d51 018d      	MOVW R16,R26
000d52 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:26 WORDS
                 SUBOPT_0x74:
                +
000d53 91a0 03af+LDS R26 , _fs_file + ( 16 )
000d55 91b0 03b0+LDS R27 , _fs_file + ( 16 ) + 1
000d57 9180 03b1+LDS R24 , _fs_file + ( 16 ) + 2
000d59 9190 03b2+LDS R25 , _fs_file + ( 16 ) + 3
                 	__GETD2MN _fs_file,16
000d5b 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:12 WORDS
                 SUBOPT_0x75:
                +
000d5c 93e0 03af+STS _fs_file + ( 16 ) , R30
000d5e 93f0 03b0+STS _fs_file + ( 16 ) + 1 , R31
000d60 9360 03b1+STS _fs_file + ( 16 ) + 2 , R22
000d62 9370 03b2+STS _fs_file + ( 16 ) + 3 , R23
                 	__PUTD1MN _fs_file,16
000d64 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:19 WORDS
                 SUBOPT_0x76:
                +
000d65 91e0 03b3+LDS R30 , _fs_file + ( 20 )
000d67 91f0 03b4+LDS R31 , _fs_file + ( 20 ) + 1
000d69 9160 03b5+LDS R22 , _fs_file + ( 20 ) + 2
000d6b 9170 03b6+LDS R23 , _fs_file + ( 20 ) + 3
                 	__GETD1MN _fs_file,20
000d6d 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:40 WORDS
                 SUBOPT_0x77:
                +
000d6e 91e0 03af+LDS R30 , _fs_file + ( 16 )
000d70 91f0 03b0+LDS R31 , _fs_file + ( 16 ) + 1
000d72 9160 03b1+LDS R22 , _fs_file + ( 16 ) + 2
000d74 9170 03b2+LDS R23 , _fs_file + ( 16 ) + 3
                 	__GETD1MN _fs_file,16
000d76 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:18 WORDS
                 SUBOPT_0x78:
                +
000d77 93e0 03b3+STS _fs_file + ( 20 ) , R30
000d79 93f0 03b4+STS _fs_file + ( 20 ) + 1 , R31
000d7b 9360 03b5+STS _fs_file + ( 20 ) + 2 , R22
000d7d 9370 03b6+STS _fs_file + ( 20 ) + 3 , R23
                 	__PUTD1MN _fs_file,20
000d7f e0e1      	LDI  R30,LOW(1)
                +
000d80 93e0 03bf+STS _fs_file + ( 32 ) , R30
                 	__PUTB1MN _fs_file,32
000d82 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x79:
000d83 df33      	RCALL SUBOPT_0x57
000d84 018f      	MOVW R16,R30
000d85 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x7A:
                +
000d86 83ed     +STD Y + 5 , R30
000d87 83fe     +STD Y + 5 + 1 , R31
000d88 836f     +STD Y + 5 + 2 , R22
000d89 8778     +STD Y + 5 + 3 , R23
                 	__PUTD1S 5
000d8a 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x7B:
                +
000d8b 81ad     +LDD R26 , Y + 5
000d8c 81be     +LDD R27 , Y + 5 + 1
000d8d 818f     +LDD R24 , Y + 5 + 2
000d8e 8598     +LDD R25 , Y + 5 + 3
                 	__GETD2S 5
000d8f 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:4 WORDS
                 SUBOPT_0x7C:
                +
000d90 81ed     +LDD R30 , Y + 5
000d91 81fe     +LDD R31 , Y + 5 + 1
000d92 816f     +LDD R22 , Y + 5 + 2
000d93 8578     +LDD R23 , Y + 5 + 3
                 	__GETD1S 5
000d94 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:13 WORDS
                 SUBOPT_0x7D:
000d95 91e0 0385 	LDS  R30,_fs_wtotal
000d97 91f0 0386 	LDS  R31,_fs_wtotal+1
000d99 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x7E:
000d9a dd4d      	RCALL SUBOPT_0x2
000d9b e1e5      	LDI  R30,LOW(21)
000d9c e0f0      	LDI  R31,HIGH(21)
000d9d dd4a      	RCALL SUBOPT_0x2
000d9e cd13      	RJMP _memcpy
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
                 SUBOPT_0x7F:
000d9f e0ea      	LDI  R30,LOW(10)
000da0 d074      	RCALL __LSRD12
                +
000da1 5fef     +SUBI R30 , LOW ( - 1 )
000da2 4fff     +SBCI R31 , HIGH ( - 1 )
000da3 4f6f     +SBCI R22 , BYTE3 ( - 1 )
000da4 4f7f     +SBCI R23 , BYTE4 ( - 1 )
                 	__ADDD1N 1
000da5 d08d      	RCALL __LSRD1
000da6 ce2f      	RJMP SUBOPT_0x2D
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:7 WORDS
                 SUBOPT_0x80:
000da7 93ea      	ST   -Y,R30
000da8 c94a      	RJMP _spi_transmit_G002
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:4 WORDS
                 SUBOPT_0x81:
000da9 93ea      	ST   -Y,R30
000daa df26      	RCALL SUBOPT_0x5C
000dab d135      	RCALL __PUTPARD1
000dac c952      	RJMP _sd_sendCommand_G002
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:4 WORDS
                 SUBOPT_0x82:
000dad d133      	RCALL __PUTPARD1
000dae d950      	RCALL _sd_sendCommand_G002
000daf 30e0      	CPI  R30,0
000db0 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x83:
000db1 e0e2      	LDI  R30,LOW(2)
000db2 dd5e      	RCALL SUBOPT_0xB
000db3 e0e1      	LDI  R30,LOW(1)
000db4 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x84:
000db5 dd32      	RCALL SUBOPT_0x2
000db6 c029      	RJMP _delay_ms
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x85:
000db7 81ee      	LDD  R30,Y+6
000db8 81ff      	LDD  R31,Y+6+1
000db9 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x86:
000dba def2      	RCALL SUBOPT_0x53
000dbb 9731      	SBIW R30,1
000dbc 83e8      	ST   Y,R30
000dbd 83f9      	STD  Y+1,R31
000dbe 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x87:
000dbf d2a6      	RCALL _wrecv
000dc0 2f1e      	MOV  R17,R30
000dc1 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:10 WORDS
                 SUBOPT_0x88:
000dc2 93ea      	ST   -Y,R30
000dc3 c2a5      	RJMP _send
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x89:
000dc4 ddd0      	RCALL SUBOPT_0x24
000dc5 dd22      	RCALL SUBOPT_0x2
000dc6 ca67      	RJMP _sendBin
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x8A:
000dc7 e4e1      	LDI  R30,LOW(65)
000dc8 cff9      	RJMP SUBOPT_0x88
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:10 WORDS
                 SUBOPT_0x8B:
000dc9 91e0 0384 	LDS  R30,_lastError
000dcb 30e0      	CPI  R30,0
000dcc 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x8C:
000dcd d90f      	RCALL _fs_getfilesize
000dce 30e0      	CPI  R30,0
000dcf 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x8D:
000dd0 01d5      	MOVW R26,R10
000dd1 2788      	CLR  R24
000dd2 2799      	CLR  R25
000dd3 d12d      	RCALL __CPD12
000dd4 9508      	RET
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:16 WORDS
                 SUBOPT_0x8E:
000dd5 e4e1      	LDI  R30,LOW(65)
000dd6 93ea      	ST   -Y,R30
000dd7 c281      	RJMP _sendStart
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:1 WORDS
                 SUBOPT_0x8F:
000dd8 da3d      	RCALL _recvString
000dd9 cffb      	RJMP SUBOPT_0x8E
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x90:
000dda ddba      	RCALL SUBOPT_0x24
000ddb dd0c      	RCALL SUBOPT_0x2
000ddc ca28      	RJMP _recvBin
                 
                 ;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:2 WORDS
                 SUBOPT_0x91:
000ddd e6e4      	LDI  R30,LOW(100)
000dde e0f0      	LDI  R31,HIGH(100)
000ddf cfd5      	RJMP SUBOPT_0x84
                 
                 
                 	.CSEG
                 _delay_ms:
000de0 91e9      	ld   r30,y+
000de1 91f9      	ld   r31,y+
000de2 9630      	adiw r30,0
000de3 f039      	breq __delay_ms1
                 __delay_ms0:
                +
000de4 ed80     +LDI R24 , LOW ( 0x7D0 )
000de5 e097     +LDI R25 , HIGH ( 0x7D0 )
                +__DELAY_USW_LOOP :
000de6 9701     +SBIW R24 , 1
000de7 f7f1     +BRNE __DELAY_USW_LOOP
                 	__DELAY_USW 0x7D0
000de8 95a8      	wdr
000de9 9731      	sbiw r30,1
000dea f7c9      	brne __delay_ms0
                 __delay_ms1:
000deb 9508      	ret
                 
                 __ADDD12:
000dec 0fea      	ADD  R30,R26
000ded 1ffb      	ADC  R31,R27
000dee 1f68      	ADC  R22,R24
000def 1f79      	ADC  R23,R25
000df0 9508      	RET
                 
                 __ADDD21:
000df1 0fae      	ADD  R26,R30
000df2 1fbf      	ADC  R27,R31
000df3 1f86      	ADC  R24,R22
000df4 1f97      	ADC  R25,R23
000df5 9508      	RET
                 
                 __SUBD12:
000df6 1bea      	SUB  R30,R26
000df7 0bfb      	SBC  R31,R27
000df8 0b68      	SBC  R22,R24
000df9 0b79      	SBC  R23,R25
000dfa 9508      	RET
                 
                 __SUBD21:
000dfb 1bae      	SUB  R26,R30
000dfc 0bbf      	SBC  R27,R31
000dfd 0b86      	SBC  R24,R22
000dfe 0b97      	SBC  R25,R23
000dff 9508      	RET
                 
                 __ORD12:
000e00 2bea      	OR   R30,R26
000e01 2bfb      	OR   R31,R27
000e02 2b68      	OR   R22,R24
000e03 2b79      	OR   R23,R25
000e04 9508      	RET
                 
                 __ANEGW1:
000e05 95f1      	NEG  R31
000e06 95e1      	NEG  R30
000e07 40f0      	SBCI R31,0
000e08 9508      	RET
                 
                 __LSLD12:
000e09 23ee      	TST  R30
000e0a 2e0e      	MOV  R0,R30
000e0b 01fd      	MOVW R30,R26
000e0c 01bc      	MOVW R22,R24
000e0d f031      	BREQ __LSLD12R
                 __LSLD12L:
000e0e 0fee      	LSL  R30
000e0f 1fff      	ROL  R31
000e10 1f66      	ROL  R22
000e11 1f77      	ROL  R23
000e12 940a      	DEC  R0
000e13 f7d1      	BRNE __LSLD12L
                 __LSLD12R:
000e14 9508      	RET
                 
                 __LSRD12:
000e15 23ee      	TST  R30
000e16 2e0e      	MOV  R0,R30
000e17 01fd      	MOVW R30,R26
000e18 01bc      	MOVW R22,R24
000e19 f031      	BREQ __LSRD12R
                 __LSRD12L:
000e1a 9576      	LSR  R23
000e1b 9567      	ROR  R22
000e1c 95f7      	ROR  R31
000e1d 95e7      	ROR  R30
000e1e 940a      	DEC  R0
000e1f f7d1      	BRNE __LSRD12L
                 __LSRD12R:
000e20 9508      	RET
                 
                 __LSLW4:
000e21 0fee      	LSL  R30
000e22 1fff      	ROL  R31
                 __LSLW3:
000e23 0fee      	LSL  R30
000e24 1fff      	ROL  R31
                 __LSLW2:
000e25 0fee      	LSL  R30
000e26 1fff      	ROL  R31
000e27 0fee      	LSL  R30
000e28 1fff      	ROL  R31
000e29 9508      	RET
                 
                 __LSRW4:
000e2a 95f6      	LSR  R31
000e2b 95e7      	ROR  R30
                 __LSRW3:
000e2c 95f6      	LSR  R31
000e2d 95e7      	ROR  R30
                 __LSRW2:
000e2e 95f6      	LSR  R31
000e2f 95e7      	ROR  R30
000e30 95f6      	LSR  R31
000e31 95e7      	ROR  R30
000e32 9508      	RET
                 
                 __LSRD1:
000e33 9576      	LSR  R23
000e34 9567      	ROR  R22
000e35 95f7      	ROR  R31
000e36 95e7      	ROR  R30
000e37 9508      	RET
                 
                 __LSRD16:
000e38 2fe6      	MOV  R30,R22
000e39 2ff7      	MOV  R31,R23
000e3a e060      	LDI  R22,0
000e3b e070      	LDI  R23,0
000e3c 9508      	RET
                 
                 __LSLD16:
000e3d 2f6e      	MOV  R22,R30
000e3e 2f7f      	MOV  R23,R31
000e3f e0e0      	LDI  R30,0
000e40 e0f0      	LDI  R31,0
000e41 9508      	RET
                 
                 __CWD1:
000e42 2f6f      	MOV  R22,R31
000e43 0f66      	ADD  R22,R22
000e44 0b66      	SBC  R22,R22
000e45 2f76      	MOV  R23,R22
000e46 9508      	RET
                 
                 __MULD12U:
000e47 9f7a      	MUL  R23,R26
000e48 2d70      	MOV  R23,R0
000e49 9f6b      	MUL  R22,R27
000e4a 0d70      	ADD  R23,R0
000e4b 9ff8      	MUL  R31,R24
000e4c 0d70      	ADD  R23,R0
000e4d 9fe9      	MUL  R30,R25
000e4e 0d70      	ADD  R23,R0
000e4f 9f6a      	MUL  R22,R26
000e50 2d60      	MOV  R22,R0
000e51 0d71      	ADD  R23,R1
000e52 9ffb      	MUL  R31,R27
000e53 0d60      	ADD  R22,R0
000e54 1d71      	ADC  R23,R1
000e55 9fe8      	MUL  R30,R24
000e56 0d60      	ADD  R22,R0
000e57 1d71      	ADC  R23,R1
000e58 2788      	CLR  R24
000e59 9ffa      	MUL  R31,R26
000e5a 2df0      	MOV  R31,R0
000e5b 0d61      	ADD  R22,R1
000e5c 1f78      	ADC  R23,R24
000e5d 9feb      	MUL  R30,R27
000e5e 0df0      	ADD  R31,R0
000e5f 1d61      	ADC  R22,R1
000e60 1f78      	ADC  R23,R24
000e61 9fea      	MUL  R30,R26
000e62 2de0      	MOV  R30,R0
000e63 0df1      	ADD  R31,R1
000e64 1f68      	ADC  R22,R24
000e65 1f78      	ADC  R23,R24
000e66 9508      	RET
                 
                 __DIVW21U:
000e67 2400      	CLR  R0
000e68 2411      	CLR  R1
000e69 e190      	LDI  R25,16
                 __DIVW21U1:
000e6a 0faa      	LSL  R26
000e6b 1fbb      	ROL  R27
000e6c 1c00      	ROL  R0
000e6d 1c11      	ROL  R1
000e6e 1a0e      	SUB  R0,R30
000e6f 0a1f      	SBC  R1,R31
000e70 f418      	BRCC __DIVW21U2
000e71 0e0e      	ADD  R0,R30
000e72 1e1f      	ADC  R1,R31
000e73 c001      	RJMP __DIVW21U3
                 __DIVW21U2:
000e74 60a1      	SBR  R26,1
                 __DIVW21U3:
000e75 959a      	DEC  R25
000e76 f799      	BRNE __DIVW21U1
000e77 01fd      	MOVW R30,R26
000e78 01d0      	MOVW R26,R0
000e79 9508      	RET
                 
                 __DIVD21U:
000e7a 933f      	PUSH R19
000e7b 934f      	PUSH R20
000e7c 935f      	PUSH R21
000e7d 2400      	CLR  R0
000e7e 2411      	CLR  R1
000e7f 2744      	CLR  R20
000e80 2755      	CLR  R21
000e81 e230      	LDI  R19,32
                 __DIVD21U1:
000e82 0faa      	LSL  R26
000e83 1fbb      	ROL  R27
000e84 1f88      	ROL  R24
000e85 1f99      	ROL  R25
000e86 1c00      	ROL  R0
000e87 1c11      	ROL  R1
000e88 1f44      	ROL  R20
000e89 1f55      	ROL  R21
000e8a 1a0e      	SUB  R0,R30
000e8b 0a1f      	SBC  R1,R31
000e8c 0b46      	SBC  R20,R22
000e8d 0b57      	SBC  R21,R23
000e8e f428      	BRCC __DIVD21U2
000e8f 0e0e      	ADD  R0,R30
000e90 1e1f      	ADC  R1,R31
000e91 1f46      	ADC  R20,R22
000e92 1f57      	ADC  R21,R23
000e93 c001      	RJMP __DIVD21U3
                 __DIVD21U2:
000e94 60a1      	SBR  R26,1
                 __DIVD21U3:
000e95 953a      	DEC  R19
000e96 f759      	BRNE __DIVD21U1
000e97 01fd      	MOVW R30,R26
000e98 01bc      	MOVW R22,R24
000e99 01d0      	MOVW R26,R0
000e9a 01ca      	MOVW R24,R20
000e9b 915f      	POP  R21
000e9c 914f      	POP  R20
000e9d 913f      	POP  R19
000e9e 9508      	RET
                 
                 __MODW21U:
000e9f dfc7      	RCALL __DIVW21U
000ea0 01fd      	MOVW R30,R26
000ea1 9508      	RET
                 
                 __MODW21:
000ea2 94e8      	CLT
000ea3 ffb7      	SBRS R27,7
000ea4 c004      	RJMP __MODW211
000ea5 95a0      	COM  R26
000ea6 95b0      	COM  R27
000ea7 9611      	ADIW R26,1
000ea8 9468      	SET
                 __MODW211:
000ea9 fdf7      	SBRC R31,7
000eaa df5a      	RCALL __ANEGW1
000eab dfbb      	RCALL __DIVW21U
000eac 01fd      	MOVW R30,R26
000ead f40e      	BRTC __MODW212
000eae df56      	RCALL __ANEGW1
                 __MODW212:
000eaf 9508      	RET
                 
                 __MODD21U:
000eb0 dfc9      	RCALL __DIVD21U
000eb1 01fd      	MOVW R30,R26
000eb2 01bc      	MOVW R22,R24
000eb3 9508      	RET
                 
                 __GETW1P:
000eb4 91ed      	LD   R30,X+
000eb5 91fc      	LD   R31,X
000eb6 9711      	SBIW R26,1
000eb7 9508      	RET
                 
                 __GETD1P:
000eb8 91ed      	LD   R30,X+
000eb9 91fd      	LD   R31,X+
000eba 916d      	LD   R22,X+
000ebb 917c      	LD   R23,X
000ebc 9713      	SBIW R26,3
000ebd 9508      	RET
                 
                 __GETD1P_INC:
000ebe 91ed      	LD   R30,X+
000ebf 91fd      	LD   R31,X+
000ec0 916d      	LD   R22,X+
000ec1 917d      	LD   R23,X+
000ec2 9508      	RET
                 
                 __PUTDP1:
000ec3 93ed      	ST   X+,R30
000ec4 93fd      	ST   X+,R31
000ec5 936d      	ST   X+,R22
000ec6 937c      	ST   X,R23
000ec7 9508      	RET
                 
                 __PUTDP1_DEC:
000ec8 937e      	ST   -X,R23
000ec9 936e      	ST   -X,R22
000eca 93fe      	ST   -X,R31
000ecb 93ee      	ST   -X,R30
000ecc 9508      	RET
                 
                 __GETD1S0:
000ecd 81e8      	LD   R30,Y
000ece 81f9      	LDD  R31,Y+1
000ecf 816a      	LDD  R22,Y+2
000ed0 817b      	LDD  R23,Y+3
000ed1 9508      	RET
                 
                 __GETD2S0:
000ed2 81a8      	LD   R26,Y
000ed3 81b9      	LDD  R27,Y+1
000ed4 818a      	LDD  R24,Y+2
000ed5 819b      	LDD  R25,Y+3
000ed6 9508      	RET
                 
                 __PUTD1S0:
000ed7 83e8      	ST   Y,R30
000ed8 83f9      	STD  Y+1,R31
000ed9 836a      	STD  Y+2,R22
000eda 837b      	STD  Y+3,R23
000edb 9508      	RET
                 
                 __PUTDZ20:
000edc 83a0      	ST   Z,R26
000edd 83b1      	STD  Z+1,R27
000ede 8382      	STD  Z+2,R24
000edf 8393      	STD  Z+3,R25
000ee0 9508      	RET
                 
                 __PUTPARD1:
000ee1 937a      	ST   -Y,R23
000ee2 936a      	ST   -Y,R22
000ee3 93fa      	ST   -Y,R31
000ee4 93ea      	ST   -Y,R30
000ee5 9508      	RET
                 
                 __SWAPD12:
000ee6 2e18      	MOV  R1,R24
000ee7 2f86      	MOV  R24,R22
000ee8 2d61      	MOV  R22,R1
000ee9 2e19      	MOV  R1,R25
000eea 2f97      	MOV  R25,R23
000eeb 2d71      	MOV  R23,R1
                 
                 __SWAPW12:
000eec 2e1b      	MOV  R1,R27
000eed 2fbf      	MOV  R27,R31
000eee 2df1      	MOV  R31,R1
                 
                 __SWAPB12:
000eef 2e1a      	MOV  R1,R26
000ef0 2fae      	MOV  R26,R30
000ef1 2de1      	MOV  R30,R1
000ef2 9508      	RET
                 
                 __CPD10:
000ef3 9730      	SBIW R30,0
000ef4 4060      	SBCI R22,0
000ef5 4070      	SBCI R23,0
000ef6 9508      	RET
                 
                 __CPW02:
000ef7 2400      	CLR  R0
000ef8 160a      	CP   R0,R26
000ef9 060b      	CPC  R0,R27
000efa 9508      	RET
                 
                 __CPD02:
000efb 2400      	CLR  R0
000efc 160a      	CP   R0,R26
000efd 060b      	CPC  R0,R27
000efe 0608      	CPC  R0,R24
000eff 0609      	CPC  R0,R25
000f00 9508      	RET
                 
                 __CPD12:
000f01 17ea      	CP   R30,R26
000f02 07fb      	CPC  R31,R27
000f03 0768      	CPC  R22,R24
000f04 0779      	CPC  R23,R25
000f05 9508      	RET
                 
                 __CPD21:
000f06 17ae      	CP   R26,R30
000f07 07bf      	CPC  R27,R31
000f08 0786      	CPC  R24,R22
000f09 0797      	CPC  R25,R23
000f0a 9508      	RET
                 
                 __SAVELOCR6:
000f0b 935a      	ST   -Y,R21
                 __SAVELOCR5:
000f0c 934a      	ST   -Y,R20
                 __SAVELOCR4:
000f0d 933a      	ST   -Y,R19
                 __SAVELOCR3:
000f0e 932a      	ST   -Y,R18
                 __SAVELOCR2:
000f0f 931a      	ST   -Y,R17
000f10 930a      	ST   -Y,R16
000f11 9508      	RET
                 
                 __LOADLOCR6:
000f12 815d      	LDD  R21,Y+5
                 __LOADLOCR5:
000f13 814c      	LDD  R20,Y+4
                 __LOADLOCR4:
000f14 813b      	LDD  R19,Y+3
                 __LOADLOCR3:
000f15 812a      	LDD  R18,Y+2
                 __LOADLOCR2:
000f16 8119      	LDD  R17,Y+1
000f17 8108      	LD   R16,Y
000f18 9508      	RET
                 
                 __LOADLOCR2P:
000f19 9109      	LD   R16,Y+
000f1a 9119      	LD   R17,Y+
000f1b 9508      	RET
                 
                 ;END OF CODE MARKER
                 __END_OF_CODE:


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega8L register use summary:
r0 :  45 r1 :  23 r2 :   0 r3 :   0 r4 :   4 r5 :  13 r6 :   4 r7 :   2 
r8 :   0 r9 :   3 r10:  11 r11:   8 r12:   0 r13:   0 r14:   0 r15:   0 
r16:  65 r17:  86 r18:  29 r19:  30 r20:  13 r21:  14 r22: 124 r23: 113 
r24:  73 r25:  53 r26: 217 r27:  91 r28:  38 r29:   1 r30: 785 r31: 245 
x  :  46 y  : 285 z  :  18 
Registers used: 28 out of 35 (80.0%)

ATmega8L instruction use summary:
.lds  :   0 .lds.l:   0 .sts  :   0 .sts.l:   0 adc   :  19 add   :  16 
adiw  :  42 and   :   0 andi  :  34 asr   :   0 bclr  :   0 bld   :   0 
brbc  :   0 brbs  :   0 brcc  :   3 brcs  :   0 break :   0 breq  : 109 
brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 brie  :   0 brlo  :  12 
brlt  :   0 brmi  :   0 brne  : 160 brpl  :   0 brsh  :  18 brtc  :   1 
brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 bst   :   0 cbi   :   6 
cbr   :   0 clc   :   0 clh   :   0 cli   :   1 cln   :   0 clr   :  23 
cls   :   0 clt   :   1 clv   :   0 clz   :   0 com   :   2 cp    :  25 
cpc   :  63 cpi   : 138 cpse  :   0 dec   :   5 des   :   0 eor   :   0 
fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :  15 
inc   :   1 ld    :  53 ldd   : 145 ldi   : 368 lds   : 206 lpm   :   7 
lsl   :   9 lsr   :   6 mov   :  43 movw  :  72 mul   :  11 muls  :   0 
mulsu :   0 neg   :   2 nop   :   0 or    :  11 ori   :   1 out   :  26 
pop   :  14 push  :  14 rcall : 947 ret   : 202 reti  :   0 rjmp  : 235 
rol   :  18 ror   :  10 sbc   :  17 sbci  :  26 sbi   :   9 sbic  :   1 
sbis  :   3 sbiw  :  48 sbr   :   2 sbrc  :   1 sbrs  :   1 sec   :   0 
seh   :   0 sei   :   0 sen   :   0 ser   :   0 ses   :   0 set   :   1 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :  81 std   :  66 
sts   : 119 sub   :  11 subi  :  24 swap  :   0 tst   :  10 wdr   :   1 

Instructions used: 59 out of 114 (51.8%)

ATmega8L memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x001e38   7674     62   7736    8192  94.4%
[.dseg] 0x000060 0x0003e1      0    737    737    1119  65.9%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 7 warnings
